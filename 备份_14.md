# é¡¹ç›®ä»£ç æ±‡æ€»

ç”Ÿæˆæ—¶é—´: 2026-01-04 11:51:14
æ–‡ä»¶æ€»æ•°: 41

---

## æ–‡ä»¶: ClipboardPro_2.py

```python
# -*- coding: utf-8 -*-
import sys
import logging
import traceback
from PyQt5.QtWidgets import QApplication
from PyQt5.QtCore import Qt, QObject
from PyQt5.QtNetwork import QLocalServer, QLocalSocket

# === é…ç½®æ—¥å¿— ===
log_format = logging.Formatter('%(asctime)s [%(levelname)s] %(name)s: %(message)s', datefmt='%H:%M:%S')
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.DEBUG)
console_handler.setFormatter(log_format)
root_logger = logging.getLogger()
root_logger.setLevel(logging.DEBUG)
root_logger.addHandler(console_handler)
log = logging.getLogger("MainEntry")

def exception_hook(exctype, value, tb):
    error_msg = ''.join(traceback.format_exception(exctype, value, tb))
    log.critical(f"ğŸ”¥ å´©æºƒä¿¡æ¯:\n{error_msg}")
    sys.__excepthook__(exctype, value, tb)

sys.excepthook = exception_hook

# --- App Controller ---
class AppController(QObject):
    def __init__(self, app):
        super().__init__()
        self.app = app
        
        from data.database import DBManager
        from quick import MainWindow as QuickPanelWindow
        from ui.ball import FloatingBall
        from ui.tray_manager import TrayManager
        
        self.db_manager = DBManager()
        self.quick_panel = QuickPanelWindow(db_manager=self.db_manager)
        self.ball = FloatingBall(main_window=self.quick_panel)
        self.tray = TrayManager()
        
        self._connect_signals()
        
        self.ball.show()
        self.quick_panel.show()
        self.tray.show()

    def _connect_signals(self):
        self.ball.request_show_quick_window.connect(self.toggle_quick_panel)
        self.ball.double_clicked.connect(self.toggle_quick_panel)
        self.ball.request_show_main_window.connect(self.quick_panel._launch_main_app)
        self.ball.request_quit_app.connect(self.app.quit)
        
        self.tray.request_show_quick_panel.connect(self.toggle_quick_panel)
        self.tray.request_quit.connect(self.app.quit)
        
    def toggle_quick_panel(self):
        if self.quick_panel.isVisible():
            self.quick_panel.hide()
        else:
            self.quick_panel.show()
            self.quick_panel.activateWindow()
            self.quick_panel.raise_()
            
    def activate_window(self):
        """æ¿€æ´»å¹¶æ˜¾ç¤ºå¿«é€Ÿé¢æ¿"""
        self.quick_panel.show()
        self.quick_panel.activateWindow()
        self.quick_panel.raise_()

def main():
    log.info("ğŸš€ å¯åŠ¨å°è±¡è®°å¿†_Pro...")
    
    if hasattr(Qt, 'AA_EnableHighDpiScaling'):
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    if hasattr(Qt, 'AA_UseHighDpiPixmaps'):
        QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)

    app = QApplication(sys.argv)
    app.setApplicationName("ClipboardManagerPro")
    app.setQuitOnLastWindowClosed(False)
    
    # --- å•ä¾‹é€»è¾‘ ---
    server_name = "ClipboardPro_Instance_Server"
    socket = QLocalSocket()
    socket.connectToServer(server_name)
    
    if socket.waitForConnected(500):
        log.info("âš ï¸ åº”ç”¨å·²åœ¨è¿è¡Œä¸­, æ¿€æ´»ç°æœ‰çª—å£.")
        socket.write(b'RAISE')
        socket.waitForBytesWritten(500)
        socket.disconnectFromServer()
        return # æ–°å®ä¾‹é€€å‡º
        
    # æ²¡æœ‰ç°æœ‰å®ä¾‹ï¼Œåˆ›å»ºæœåŠ¡å™¨
    server = QLocalServer()
    server.listen(server_name)

    try:
        controller = AppController(app)
        
        # è¿æ¥æœåŠ¡å™¨çš„æ–°è¿æ¥ä¿¡å·
        def handle_new_connection():
            new_socket = server.nextPendingConnection()
            if new_socket:
                new_socket.waitForReadyRead(1000)
                command = new_socket.readAll().data().decode()
                if command == 'RAISE':
                    log.info("æ”¶åˆ°æ¿€æ´»è¯·æ±‚, æ­£åœ¨æ˜¾ç¤ºçª—å£...")
                    controller.activate_window()
                new_socket.disconnectFromServer()

        server.newConnection.connect(handle_new_connection)
        
        sys.exit(app.exec_())
    except Exception as e:
        log.critical(f"âŒ å¯åŠ¨å¤±è´¥: {e}", exc_info=True)
    finally:
        # æ¸…ç†æœåŠ¡å™¨
        server.close()
        server.removeServer(server_name)

if __name__ == "__main__":
    main()
```

## æ–‡ä»¶: quick.py

```python
# -*- coding: utf-8 -*-
import sys
import os
import ctypes
from ctypes import wintypes
import time
import datetime
import subprocess
from PyQt5.QtWidgets import (QApplication, QWidget, QVBoxLayout, QListWidget, QLineEdit,
                             QListWidgetItem, QHBoxLayout, QTreeWidget, QTreeWidgetItem,
                             QPushButton, QStyle, QAction, QSplitter, QGraphicsDropShadowEffect, QLabel)
from PyQt5.QtCore import Qt, QTimer, QPoint, QRect, QSettings, QUrl, QMimeData
from PyQt5.QtGui import QImage, QColor, QCursor

# Import the new dialog
from ui.dialog_new_idea import NewIdeaDialog

# =================================================================================
#   Win32 API å®šä¹‰
# =================================================================================
user32 = ctypes.windll.user32
kernel32 = ctypes.windll.kernel32

KEYEVENTF_KEYUP = 0x0002
VK_CONTROL = 0x11
VK_V = 0x56

# SetWindowPos Flags
HWND_TOPMOST = -1
HWND_NOTOPMOST = -2
SWP_NOMOVE = 0x0002
SWP_NOSIZE = 0x0001
SWP_NOACTIVATE = 0x0010
SWP_FLAGS = SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE

class GUITHREADINFO(ctypes.Structure):
    _fields_ = [
        ("cbSize", wintypes.DWORD),
        ("flags", wintypes.DWORD),
        ("hwndActive", wintypes.HWND),
        ("hwndFocus", wintypes.HWND),      
        ("hwndCapture", wintypes.HWND),
        ("hwndMenuOwner", wintypes.HWND),
        ("hwndMoveSize", wintypes.HWND),
        ("hwndCaret", wintypes.HWND),
        ("rcCaret", wintypes.RECT)
    ]

user32.GetGUIThreadInfo.argtypes = [wintypes.DWORD, ctypes.POINTER(GUITHREADINFO)]
user32.GetGUIThreadInfo.restype = wintypes.BOOL
user32.SetFocus.argtypes = [wintypes.HWND]
user32.SetFocus.restype = wintypes.HWND
user32.SetWindowPos.argtypes = [wintypes.HWND, wintypes.HWND, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_int, ctypes.c_uint]

# =================================================================================
#   æ—¥å¿—ç³»ç»Ÿ
# =================================================================================
def log(message):
    try: print(message, flush=True)
    except: pass

# =================================================================================
#   æ•°æ®åº“æ¨¡æ‹Ÿ
# =================================================================================
try:
    from data.database import DBManager
    from services.clipboard import ClipboardManager
except ImportError:
    class DBManager:
        def get_items(self, **kwargs): return []
        def get_partitions_tree(self): return []
    class ClipboardManager:
        def __init__(self, db_manager): pass
        def process_clipboard(self, mime_data): pass

# =================================================================================
#   æ ·å¼è¡¨
# =================================================================================
DARK_STYLESHEET = """
QWidget#Container {
    background-color: #2E2E2E;
    border: 1px solid #444; 
    border-radius: 8px;    
}
QWidget {
    color: #F0F0F0;
    font-family: "Microsoft YaHei", "Segoe UI Emoji";
    font-size: 14px;
}

/* æ ‡é¢˜æ æ–‡å­—æ ·å¼ */
QLabel#TitleLabel {
    color: #AAAAAA;
    font-weight: bold;
    font-size: 13px;
    padding-left: 5px;
}

QListWidget, QTreeWidget {
    border: none;
    background-color: #2E2E2E;
    alternate-background-color: #383838;
    outline: none;
}
QListWidget::item { padding: 8px; border: none; }
QListWidget::item:selected, QTreeWidget::item:selected {
    background-color: #4D79C4; color: #FFFFFF;
}
QListWidget::item:hover { background-color: #444444; }

QSplitter::handle { background-color: #444; width: 2px; }
QSplitter::handle:hover { background-color: #4D79C4; }

QLineEdit {
    background-color: #3C3C3C;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 6px;
    font-size: 16px;
}

/* é€šç”¨å·¥å…·æ æŒ‰é’® */
QPushButton#ToolButton, QPushButton#MinButton, QPushButton#CloseButton, QPushButton#PinButton, QPushButton#MaxButton { 
    background-color: transparent; 
    border-radius: 4px; 
    padding: 0px;  
    font-size: 16px;
    font-weight: bold;
    text-align: center;
}

QPushButton#ToolButton:hover, QPushButton#MinButton:hover, QPushButton#MaxButton:hover { background-color: #444; }
QPushButton#ToolButton:checked, QPushButton#MaxButton:checked { background-color: #555; border: 1px solid #666; }

QPushButton#CloseButton:hover { background-color: #E81123; color: white; }

/* ç½®é¡¶æŒ‰é’®ç‰¹æ®ŠçŠ¶æ€ */
QPushButton#PinButton:hover { background-color: #444; }
QPushButton#PinButton:checked { background-color: #0078D4; color: white; border: 1px solid #005A9E; }
"""

class MainWindow(QWidget):
    RESIZE_MARGIN = 18 

    def __init__(self, db_manager):
        super().__init__()
        self.db = db_manager
        self.settings = QSettings("MyTools", "ClipboardPro")
        
        self.m_drag = False
        self.m_DragPosition = QPoint()
        self.resize_area = None
        
        self._is_pinned = False
        self.last_active_hwnd = None
        self.last_focus_hwnd = None
        self.last_thread_id = None
        self.my_hwnd = None
        self.main_window_instance = None # æŒæœ‰ä¸»çª—å£å®ä¾‹
        
        # --- Clipboard Manager ---
        self.cm = ClipboardManager(self.db)
        self.clipboard = QApplication.clipboard()
        self.clipboard.dataChanged.connect(self.on_clipboard_changed)
        self.cm.data_captured.connect(self._update_list)
        self._processing_clipboard = False
        
        self._init_ui()
        self._restore_window_state()
        
        self.setMouseTracking(True)
        self.container.setMouseTracking(True)
        
        self.monitor_timer = QTimer(self)
        self.monitor_timer.timeout.connect(self._monitor_foreground_window)
        self.monitor_timer.start(200)

        self.search_timer = QTimer(self)
        self.search_timer.setSingleShot(True)
        self.search_timer.timeout.connect(self._update_list)
        
        self.search_box.textChanged.connect(self._on_search_text_changed)
        self.list_widget.itemActivated.connect(self._on_item_activated)
        self.partition_tree.currentItemChanged.connect(self._on_partition_selection_changed)
        
        self.clear_action.triggered.connect(self.search_box.clear)
        self.search_box.textChanged.connect(lambda text: self.clear_action.setVisible(bool(text)))
        self.clear_action.setVisible(False)
        
        # æŒ‰é’®ä¿¡å·è¿æ¥
        self.btn_stay_top.clicked.connect(self._toggle_stay_on_top)
        self.btn_toggle_side.clicked.connect(self._toggle_partition_panel)
        self.btn_open_full.clicked.connect(self._launch_main_app) # è¿æ¥å¯åŠ¨åŠŸèƒ½
        self.btn_minimize.clicked.connect(self.showMinimized) 
        self.btn_close.clicked.connect(self.close)
        
        self._update_partition_tree()
        self._update_list()
        
        # å¦‚æœæ•°æ®åº“ä¸ºç©ºï¼Œåˆ™æ·»åŠ è°ƒè¯•æ•°æ®
        if not self.db.get_items(limit=1):
            self._add_debug_test_item()

    def quick_add_idea(self, text):
        """ä»æ‚¬æµ®çƒå¿«é€Ÿæ·»åŠ æ–‡æœ¬åˆ°æ•°æ®åº“"""
        log(f"ğŸ’¡ ä»æ‚¬æµ®çƒæ¥æ”¶åˆ°å¿«é€Ÿæ·»åŠ è¯·æ±‚: {text}")
        self.db.add_item(text, item_type='text')
        self._update_list() # æ·»åŠ ååˆ·æ–°åˆ—è¡¨

    def new_idea(self):
        """å¼¹å‡º'æ–°å»ºçµæ„Ÿ'å¯¹è¯æ¡†ï¼Œå¹¶å¤„ç†ç»“æœ"""
        log("ğŸ’¡ 'æ–°å»ºçµæ„Ÿ' è¢«è§¦å‘ï¼Œæ­£åœ¨æ‰“å¼€å¯¹è¯æ¡†...")
        
        # ç¡®ä¿å¿«é€Ÿé¢æ¿å¯è§ï¼Œå¦åˆ™å¯¹è¯æ¡†å¯èƒ½æ— æ³•æ­£ç¡®æ˜¾ç¤ºæˆ–æˆä¸ºç„¦ç‚¹
        self.show()
        self.activateWindow()
        
        dialog = NewIdeaDialog(self)
        
        # ä»¥æ¨¡æ€æ–¹å¼æ‰§è¡Œå¯¹è¯æ¡†
        if dialog.exec_(): # exec_() for PyQt5
            idea_text = dialog.get_idea_text()
            if idea_text:
                log(f"âœ… å¯¹è¯æ¡†è¢«æ¥å—ï¼Œä¿å­˜æ–°çµæ„Ÿ: '{idea_text[:50]}...'")
                # ä½¿ç”¨ç°æœ‰çš„æ–¹æ³•æ·»åŠ  item
                self.db.add_item(idea_text, item_type='text')
                # åˆ·æ–°åˆ—è¡¨ä»¥æ˜¾ç¤ºæ–°é¡¹ç›®
                self._update_list()
                
                # å¯é€‰ï¼šå°†æ–°é¡¹ç›®æ»šåŠ¨åˆ°è§†é‡ä¸­å¹¶é€‰ä¸­
                if self.list_widget.count() > 0:
                    self.list_widget.setCurrentRow(0)
            else:
                log("ğŸŸ¡ å¯¹è¯æ¡†è¢«æ¥å—ï¼Œä½†å†…å®¹ä¸ºç©ºï¼Œä¸æ‰§è¡Œä»»ä½•æ“ä½œã€‚")
        else:
            log("âŒ å¯¹è¯æ¡†è¢«å–æ¶ˆã€‚")

    def _init_ui(self):
        self.setWindowTitle("Clipboard Pro")
        self.resize(830, 630)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.Window)
        
        self.root_layout = QVBoxLayout(self)
        self.root_layout.setContentsMargins(15, 15, 15, 15) 
        
        self.container = QWidget()
        self.container.setObjectName("Container")
        self.root_layout.addWidget(self.container)
        
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(20)
        shadow.setColor(QColor(0, 0, 0, 160))
        self.container.setGraphicsEffect(shadow)
        
        self.setStyleSheet(DARK_STYLESHEET)
        
        self.main_layout = QVBoxLayout(self.container)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(10)
        
        # --- Title Bar ---
        title_bar_layout = QHBoxLayout()
        title_bar_layout.setContentsMargins(0, 0, 0, 0)
        title_bar_layout.setSpacing(5)
        
        self.title_label = QLabel("Clipboard Pro")
        self.title_label.setObjectName("TitleLabel")
        title_bar_layout.addWidget(self.title_label)
        
        title_bar_layout.addStretch()
        
        # --- æŒ‰é’®åˆ›å»ºåŒº ---
        
        # 1. ä¿æŒç½®é¡¶ (Pin)
        self.btn_stay_top = QPushButton("ğŸ“Œ", self)
        self.btn_stay_top.setObjectName("PinButton")
        self.btn_stay_top.setToolTip("ä¿æŒç½®é¡¶")
        self.btn_stay_top.setCheckable(True)
        self.btn_stay_top.setFixedSize(32, 32)

        # 2. ä¾§è¾¹æ å¼€å…³ (Eye)
        self.btn_toggle_side = QPushButton("ğŸ‘ï¸", self)
        self.btn_toggle_side.setObjectName("ToolButton")
        self.btn_toggle_side.setToolTip("æ˜¾ç¤º/éšè—ä¾§è¾¹æ ")
        self.btn_toggle_side.setFixedSize(32, 32)
        
        # 3. å¯åŠ¨å®Œæ•´ç•Œé¢ (Open Main)
        self.btn_open_full = QPushButton(self)
        self.btn_open_full.setObjectName("MaxButton")
        self.btn_open_full.setToolTip("æ‰“å¼€ä¸»ç¨‹åºç•Œé¢")
        self.btn_open_full.setIcon(self.style().standardIcon(QStyle.SP_TitleBarMaxButton))
        self.btn_open_full.setFixedSize(32, 32)

        # 4. æœ€å°åŒ– (Minimize)
        self.btn_minimize = QPushButton("â€”", self)
        self.btn_minimize.setObjectName("MinButton")
        self.btn_minimize.setToolTip("æœ€å°åŒ–")
        self.btn_minimize.setFixedSize(32, 32)
        
        # 5. å…³é—­ (Close)
        self.btn_close = QPushButton(self)
        self.btn_close.setObjectName("CloseButton")
        self.btn_close.setToolTip("å…³é—­")
        self.btn_close.setIcon(self.style().standardIcon(QStyle.SP_TitleBarCloseButton))
        self.btn_close.setFixedSize(32, 32)
        
        # æ·»åŠ åˆ°å¸ƒå±€
        title_bar_layout.addWidget(self.btn_stay_top)
        title_bar_layout.addWidget(self.btn_toggle_side)
        title_bar_layout.addWidget(self.btn_open_full) # æ–°å¢
        title_bar_layout.addWidget(self.btn_minimize)
        title_bar_layout.addWidget(self.btn_close)
        
        self.main_layout.addLayout(title_bar_layout)
        
        # --- Search Bar ---
        self.search_box = QLineEdit(self)
        self.search_box.setPlaceholderText("æœç´¢å‰ªè´´æ¿å†å²...")
        self.clear_action = QAction(self)
        self.clear_action.setIcon(self.style().standardIcon(QStyle.SP_DialogCloseButton))
        self.search_box.addAction(self.clear_action, QLineEdit.TrailingPosition)
        
        self.main_layout.addWidget(self.search_box)
        
        # --- Splitter Content ---
        content_widget = QWidget()
        content_layout = QHBoxLayout(content_widget)
        content_layout.setContentsMargins(0, 0, 0, 0)
        
        self.splitter = QSplitter(Qt.Horizontal)
        self.splitter.setHandleWidth(4)
        
        self.list_widget = QListWidget()
        self.list_widget.setFocusPolicy(Qt.StrongFocus)
        self.list_widget.setAlternatingRowColors(True)
        self.list_widget.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.list_widget.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)

        self.partition_tree = QTreeWidget()
        self.partition_tree.setHeaderHidden(True)
        self.partition_tree.setFocusPolicy(Qt.NoFocus)
        self.partition_tree.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.partition_tree.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        
        self.splitter.addWidget(self.list_widget)
        self.splitter.addWidget(self.partition_tree)
        self.splitter.setStretchFactor(0, 1)
        self.splitter.setStretchFactor(1, 0)
        self.splitter.setSizes([550, 150])
        
        content_layout.addWidget(self.splitter)
        self.main_layout.addWidget(content_widget)

    # --- Launch Main App Logic ---
    def _launch_main_app(self):
        """åˆ›å»ºå¹¶æ˜¾ç¤ºä¸»æ•°æ®ç®¡ç†çª—å£"""
        try:
            if self.main_window_instance and self.main_window_instance.isVisible():
                self.main_window_instance.activateWindow()
                self.main_window_instance.raise_()
            else:
                from ui.main_window import MainWindow
                
                # åˆ›å»ºå¹¶æŒæœ‰å®ä¾‹
                self.main_window_instance = MainWindow()
                self.main_window_instance.show()
                
                # å±…ä¸­æ˜¾ç¤º
                screen_geo = QApplication.desktop().screenGeometry()
                window_geo = self.main_window_instance.geometry()
                self.main_window_instance.move(
                    (screen_geo.width() - window_geo.width()) // 2,
                    (screen_geo.height() - window_geo.height()) // 2
                )

        except Exception as e:
            log(f"âŒ å¯åŠ¨ä¸»çª—å£å¤±è´¥: {e}")

    # --- Restore & Save State ---
    def _restore_window_state(self):
        geometry = self.settings.value("geometry")
        if geometry:
            self.restoreGeometry(geometry)
        else:
            screen_geo = QApplication.desktop().screenGeometry()
            win_geo = self.geometry()
            x = (screen_geo.width() - win_geo.width()) // 2
            y = (screen_geo.height() - win_geo.height()) // 2
            self.move(x, y)
        splitter_state = self.settings.value("splitter_state")
        if splitter_state: self.splitter.restoreState(splitter_state)

    def closeEvent(self, event):
        self.settings.setValue("geometry", self.saveGeometry())
        self.settings.setValue("splitter_state", self.splitter.saveState())
        super().closeEvent(event)

    # --- Mouse Logic ---
    def _get_resize_area(self, pos):
        x, y = pos.x(), pos.y()
        w, h = self.width(), self.height()
        m = self.RESIZE_MARGIN
        areas = []
        if x < m: areas.append('left')
        elif x > w - m: areas.append('right')
        if y < m: areas.append('top')
        elif y > h - m: areas.append('bottom')
        return areas

    def _set_cursor_shape(self, areas):
        if not areas: self.setCursor(Qt.ArrowCursor); return
        if 'left' in areas and 'top' in areas: self.setCursor(Qt.SizeFDiagCursor)
        elif 'right' in areas and 'bottom' in areas: self.setCursor(Qt.SizeFDiagCursor)
        elif 'left' in areas and 'bottom' in areas: self.setCursor(Qt.SizeBDiagCursor)
        elif 'right' in areas and 'top' in areas: self.setCursor(Qt.SizeBDiagCursor)
        elif 'left' in areas or 'right' in areas: self.setCursor(Qt.SizeHorCursor)
        elif 'top' in areas or 'bottom' in areas: self.setCursor(Qt.SizeVerCursor)

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            areas = self._get_resize_area(event.pos())
            if areas:
                self.resize_area = areas
                self.m_drag = False
            else:
                self.resize_area = None
                self.m_drag = True
                self.m_DragPosition = event.globalPos() - self.pos()
            event.accept()

    def mouseMoveEvent(self, event):
        if event.buttons() == Qt.NoButton:
            areas = self._get_resize_area(event.pos())
            self._set_cursor_shape(areas)
            event.accept()
            return
        if event.buttons() == Qt.LeftButton:
            if self.resize_area:
                global_pos = event.globalPos()
                rect = self.geometry()
                if 'left' in self.resize_area:
                    new_w = rect.right() - global_pos.x()
                    if new_w > 100: rect.setLeft(global_pos.x())
                elif 'right' in self.resize_area:
                    new_w = global_pos.x() - rect.left()
                    if new_w > 100: rect.setWidth(new_w)
                if 'top' in self.resize_area:
                    new_h = rect.bottom() - global_pos.y()
                    if new_h > 100: rect.setTop(global_pos.y())
                elif 'bottom' in self.resize_area:
                    new_h = global_pos.y() - rect.top()
                    if new_h > 100: rect.setHeight(new_h)
                self.setGeometry(rect)
                event.accept()
            elif self.m_drag:
                self.move(event.globalPos() - self.m_DragPosition)
                event.accept()

    def mouseReleaseEvent(self, event):
        self.m_drag = False
        self.resize_area = None
        self.setCursor(Qt.ArrowCursor)

    # --- Core Logic ---
    def showEvent(self, event):
        if not self.my_hwnd: self.my_hwnd = int(self.winId())
        super().showEvent(event)

    def _monitor_foreground_window(self):
        current_hwnd = user32.GetForegroundWindow()
        if current_hwnd == 0 or current_hwnd == self.my_hwnd: return
        if current_hwnd != self.last_active_hwnd:
            self.last_active_hwnd = current_hwnd
            self.last_thread_id = user32.GetWindowThreadProcessId(current_hwnd, None)
            self.last_focus_hwnd = None
            curr_thread = kernel32.GetCurrentThreadId()
            attached = False
            if curr_thread != self.last_thread_id:
                attached = user32.AttachThreadInput(curr_thread, self.last_thread_id, True)
            try:
                gui_info = GUITHREADINFO()
                gui_info.cbSize = ctypes.sizeof(GUITHREADINFO)
                if user32.GetGUIThreadInfo(self.last_thread_id, ctypes.byref(gui_info)):
                    self.last_focus_hwnd = gui_info.hwndFocus or gui_info.hwndActive
            except: pass
            finally:
                if attached: user32.AttachThreadInput(curr_thread, self.last_thread_id, False)

    def _on_search_text_changed(self): self.search_timer.start(300)

    def _update_list(self):
        search_text = self.search_box.text()
        partition_filter = None
        date_modify_filter = None # æ–°å¢å˜é‡
        current_partition = self.partition_tree.currentItem()
        if current_partition:
            partition_data = current_partition.data(0, Qt.UserRole)
            if partition_data:
                if partition_data['type'] == 'today':
                    date_modify_filter = 'ä»Šæ—¥'
                    # partition_filter ä¿æŒä¸º None
                elif partition_data['type'] != 'all':
                    partition_filter = partition_data
        # 1. ä»æ•°æ®åº“è·å–æœªç»è¿‡æ»¤çš„æ•°æ®
        all_items = self.db.get_items(partition_filter=partition_filter, date_modify_filter=date_modify_filter, limit=None)
        
        # 2. åœ¨å†…å­˜ä¸­è¿›è¡Œæœç´¢è¿‡æ»¤
        if search_text:
            search_text_lower = search_text.lower()
            filtered_items = []
            for item in all_items:
                content_match = search_text_lower in getattr(item, 'content', '').lower()
                note_match = search_text_lower in getattr(item, 'note', '').lower()
                if content_match or note_match:
                    filtered_items.append(item)
            items = filtered_items
        else:
            items = all_items

        self.list_widget.clear()
        for item in items:
            display_text = self._get_content_display(item)
            list_item = QListWidgetItem(display_text)
            list_item.setData(Qt.UserRole, item)
            if getattr(item, 'content', ''):
                list_item.setToolTip(str(item.content)[:500])
            self.list_widget.addItem(list_item)
        if self.list_widget.count() > 0: self.list_widget.setCurrentRow(0)

    def _get_content_display(self, item):
        if getattr(item, 'item_type', '') == 'file' and getattr(item, 'file_path', ''):
            return os.path.basename(item.file_path)
        elif getattr(item, 'item_type', '') == 'url' and getattr(item, 'url_domain', None):
            return f"[{item.url_domain}] {item.url_title or ''}"
        elif getattr(item, 'item_type', '') == 'image':
            return "[å›¾ç‰‡] " + (os.path.basename(item.image_path) if getattr(item, 'image_path', None) else "")
        else:
            return getattr(item, 'content', '').replace('\n', ' ').replace('\r', '').strip()[:150]

    def _create_color_icon(self, color_str):
        from PyQt5.QtGui import QPixmap, QPainter, QIcon
        pixmap = QPixmap(16, 16)
        pixmap.fill(Qt.transparent)
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.setBrush(QColor(color_str or "#808080"))
        painter.setPen(Qt.NoPen)
        painter.drawRoundedRect(2, 2, 12, 12, 4, 4)
        painter.end()
        return QIcon(pixmap)

    def _update_partition_tree(self):
        current_selection = self.partition_tree.currentItem().data(0, Qt.UserRole) if self.partition_tree.currentItem() else None
        self.partition_tree.clear()
        
        counts = self.db.get_partition_item_counts()
        partition_counts = counts.get('partitions', {})

        # -- æ·»åŠ é™æ€é¡¹ --
        static_items = [
            ("å…¨éƒ¨æ•°æ®", {'type': 'all', 'id': -1}, QStyle.SP_DirHomeIcon, counts.get('total', 0)),
            ("ä»Šæ—¥æ•°æ®", {'type': 'today', 'id': -5}, QStyle.SP_FileDialogDetailedView, counts.get('today_modified', 0)),
        ]
        
        for name, data, icon, count in static_items:
            item = QTreeWidgetItem(self.partition_tree, [f"{name} ({count})"])
            item.setData(0, Qt.UserRole, data)
            item.setIcon(0, self.style().standardIcon(icon))
        
        # -- é€’å½’æ·»åŠ ç”¨æˆ·åˆ†åŒº --
        top_level_partitions = self.db.get_partitions_tree()
        self._add_partition_recursive(top_level_partitions, self.partition_tree, partition_counts)

        self.partition_tree.expandAll()
        
        # æ¢å¤ä¹‹å‰çš„é€‰æ‹©
        if current_selection:
            it = QTreeWidgetItemIterator(self.partition_tree)
            while it.value():
                item = it.value()
                item_data = item.data(0, Qt.UserRole)
                if item_data and item_data.get('id') == current_selection.get('id') and item_data.get('type') == current_selection.get('type'):
                    self.partition_tree.setCurrentItem(item)
                    break
                it += 1
        else:
            if self.partition_tree.topLevelItemCount() > 0:
                self.partition_tree.setCurrentItem(self.partition_tree.topLevelItem(0))

    def _add_partition_recursive(self, partitions, parent_item, partition_counts):
        for partition in partitions:
            count = partition_counts.get(partition.id, 0)
            item = QTreeWidgetItem(parent_item, [f"{partition.name} ({count})"])
            item.setData(0, Qt.UserRole, {'type': 'partition', 'id': partition.id, 'color': partition.color})
            item.setIcon(0, self._create_color_icon(partition.color))
            
            if partition.children:
                self._add_partition_recursive(partition.children, item, partition_counts)

    def _on_partition_selection_changed(self, c, p): self._update_list()
    def _toggle_partition_panel(self): self.partition_tree.setVisible(not self.partition_tree.isVisible())
    
    def _toggle_stay_on_top(self):
        self._is_pinned = self.btn_stay_top.isChecked()
        hwnd = int(self.winId())
        if self._is_pinned:
            user32.SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_FLAGS)
        else:
            user32.SetWindowPos(hwnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_FLAGS)

    def _on_item_activated(self, item):
        db_item = item.data(Qt.UserRole)
        if not db_item: return
        try:
            clipboard = QApplication.clipboard()
            
            # 1. å¤„ç†å›¾ç‰‡
            if getattr(db_item, 'item_type', '') == 'image' and getattr(db_item, 'data_blob', None):
                image = QImage()
                image.loadFromData(db_item.data_blob)
                clipboard.setImage(image)
            
            # 2. å¤„ç†æ–‡ä»¶ï¼šæ„å»º URI åˆ—è¡¨
            elif getattr(db_item, 'item_type', '') == 'file' and getattr(db_item, 'file_path', ''):
                mime_data = QMimeData()
                urls = [QUrl.fromLocalFile(p) for p in db_item.file_path.split(';') if p]
                mime_data.setUrls(urls)
                clipboard.setMimeData(mime_data)
                
            # 3. å¤„ç†æ™®é€šæ–‡æœ¬/é“¾æ¥
            else:
                clipboard.setText(db_item.content)
            
            self._paste_ditto_style()
        except Exception as e: log(f"âŒ æ“ä½œå¤±è´¥: {e}")

    def _paste_ditto_style(self):
        target_win = self.last_active_hwnd
        target_focus = self.last_focus_hwnd
        target_thread = self.last_thread_id
        if not target_win or not user32.IsWindow(target_win): return
        curr_thread = kernel32.GetCurrentThreadId()
        attached = False
        if target_thread and curr_thread != target_thread:
            attached = user32.AttachThreadInput(curr_thread, target_thread, True)
        try:
            if user32.IsIconic(target_win): user32.ShowWindow(target_win, 9)
            user32.SetForegroundWindow(target_win)
            if target_focus and user32.IsWindow(target_focus): user32.SetFocus(target_focus)
            time.sleep(0.1)
            user32.keybd_event(VK_CONTROL, 0, 0, 0)
            user32.keybd_event(VK_V, 0, 0, 0)
            user32.keybd_event(VK_V, 0, KEYEVENTF_KEYUP, 0)
            user32.keybd_event(VK_CONTROL, 0, KEYEVENTF_KEYUP, 0)
        except Exception as e: log(f"âŒ ç²˜è´´å¼‚å¸¸: {e}")
        finally:
            if attached: user32.AttachThreadInput(curr_thread, target_thread, False)

    def on_clipboard_changed(self):
        if self._processing_clipboard:
            return
        self._processing_clipboard = True
        try:
            mime = self.clipboard.mimeData()
            # quick.py é»˜è®¤ä¸ä¸ç‰¹å®šåˆ†åŒºå…³è”ï¼Œæ‰€ä»¥ä¼ å…¥ None
            self.cm.process_clipboard(mime, None)
        finally:
            self._processing_clipboard = False

    def keyPressEvent(self, event):
        key = event.key()
        if key == Qt.Key_Escape: self.close()
        elif key in (Qt.Key_Up, Qt.Key_Down):
            if not self.list_widget.hasFocus():
                self.list_widget.setFocus()
                QApplication.sendEvent(self.list_widget, event)
        else: super().keyPressEvent(event)

    def _add_debug_test_item(self):
        """ä»…åœ¨æ•°æ®åº“ä¸ºç©ºæ—¶ï¼Œç”¨äºå¡«å……ä¸€äº›ç¤ºä¾‹æ•°æ®"""
        for i in range(20):
            item = QListWidgetItem(f"æµ‹è¯•æ•°æ® {i+1}")
            mock_data = type('obj', (object,), {'item_type': 'text', 'content': f'Content {i}'})
            item.setData(Qt.UserRole, mock_data)
            self.list_widget.addItem(item)
```

## æ–‡ä»¶: core\settings.py

```python
# core/settings.py
import json
import os

SETTINGS_FILE = 'settings.json'

def save_setting(key, value):
    """ä¿å­˜å•ä¸ªè®¾ç½®é¡¹åˆ° JSON æ–‡ä»¶"""
    settings = {}
    if os.path.exists(SETTINGS_FILE):
        try:
            with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
                settings = json.load(f)
        except (json.JSONDecodeError, IOError):
            # å¦‚æœæ–‡ä»¶å­˜åœ¨ä½†ä¸ºç©ºæˆ–æŸåï¼Œåˆ™å¿½ç•¥
            pass
    
    settings[key] = value
    
    try:
        with open(SETTINGS_FILE, 'w', encoding='utf-8') as f:
            json.dump(settings, f, indent=4)
        # print(f"[Settings] å·²ä¿å­˜ '{key}': {value}")
        pass
    except IOError as e:
        # print(f"[Settings] é”™è¯¯ï¼šæ— æ³•å†™å…¥è®¾ç½®æ–‡ä»¶ {SETTINGS_FILE}: {e}")
        pass

def load_setting(key, default=None):
    """ä» JSON æ–‡ä»¶åŠ è½½å•ä¸ªè®¾ç½®é¡¹"""
    if not os.path.exists(SETTINGS_FILE):
        return default
        
    try:
        with open(SETTINGS_FILE, 'r', encoding='utf-8') as f:
            settings = json.load(f)
            value = settings.get(key, default)
            # print(f"[Settings] å·²åŠ è½½ '{key}': {value}")
            pass
            return value
    except (json.JSONDecodeError, IOError) as e:
        # print(f"[Settings] é”™è¯¯ï¼šæ— æ³•è¯»å–è®¾ç½®æ–‡ä»¶ {SETTINGS_FILE}: {e}")
        pass
        return default
```

## æ–‡ä»¶: core\shared.py

```python
ï»¿# -*- coding: utf-8 -*-
from PyQt5.QtGui import QColor, QPixmap, QIcon, QPainter
from PyQt5.QtCore import Qt

# è¿™ä¸ªæ–‡ä»¶ç°åœ¨å˜å¾—å¾ˆå¹²å‡€ï¼Œåªå­˜æ”¾é€»è¾‘å·¥å…·ï¼Œä¸å­˜æ”¾ä¸€å¤§ä¸²CSSä»£ç äº†

def format_size(text):
    """æ ¼å¼åŒ–æ˜¾ç¤ºå¤§å°"""
    if not text: return "0 B"
    b = len(text.encode('utf-8'))
    if b < 1024: return f"{b} B"
    elif b < 1024**2: return f"{b/1024:.1f} KB"
    else: return f"{b/1024**2:.1f} MB"

def get_color_icon(hex_color):
    """ç”Ÿæˆé¢œè‰²åœ†ç‚¹å›¾æ ‡"""
    if not hex_color: return QIcon()
    px = QPixmap(16, 16)
    px.fill(Qt.transparent)
    p = QPainter(px)
    p.setRenderHint(QPainter.Antialiasing)
    p.setBrush(QColor(hex_color))
    p.setPen(Qt.NoPen)
    p.drawEllipse(1, 1, 14, 14)
    p.end()
    return QIcon(px)
```

## æ–‡ä»¶: core\__init__.py

```python

```

## æ–‡ä»¶: data\database.py

```python
# -*- coding: utf-8 -*-
import sys
import os
import hashlib
import logging
from datetime import datetime, timedelta, time
from sqlalchemy import create_engine, Column, Integer, String, Text, Boolean, DateTime, ForeignKey, Table, Index, Float, func, or_, exists, and_, BLOB
from sqlalchemy.orm import declarative_base, relationship, sessionmaker, joinedload

log = logging.getLogger("Database")
Base = declarative_base()

item_tags = Table(
    'item_tags', Base.metadata,
    Column('item_id', Integer, ForeignKey('clipboard_items.id'), primary_key=True),
    Column('tag_id', Integer, ForeignKey('tags.id'), primary_key=True),
    Index('idx_tag_item', 'tag_id', 'item_id')
)

partition_tags = Table(
    'partition_tags', Base.metadata,
    Column('partition_id', Integer, ForeignKey('partitions.id'), primary_key=True),
    Column('tag_id', Integer, ForeignKey('tags.id'), primary_key=True)
)

class Partition(Base):
    __tablename__ = 'partitions'
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(50), nullable=False)
    color = Column(String(20), default=None)
    sort_index = Column(Float, default=0.0)
    parent_id = Column(Integer, ForeignKey('partitions.id'), nullable=True)
    parent = relationship("Partition", remote_side=[id], back_populates="children")
    children = relationship("Partition", back_populates="parent", cascade="all, delete-orphan", order_by="Partition.sort_index")
    tags = relationship("Tag", secondary=partition_tags, back_populates="partitions")
    items = relationship(
        "ClipboardItem", 
        primaryjoin="and_(Partition.id==ClipboardItem.partition_id, ClipboardItem.is_deleted != True)",
        back_populates="partition", 
        order_by="ClipboardItem.sort_index"
    )

class ClipboardItem(Base):
    __tablename__ = 'clipboard_items'
    id = Column(Integer, primary_key=True, autoincrement=True)
    content = Column(Text, nullable=False)
    content_hash = Column(String(64), index=True, unique=True)
    note = Column(Text, default="")
    created_at = Column(DateTime, default=datetime.now)
    modified_at = Column(DateTime, default=datetime.now, onupdate=datetime.now)
    last_visited_at = Column(DateTime, default=datetime.now)
    visit_count = Column(Integer, default=0)
    sort_index = Column(Float, default=0.0)
    star_level = Column(Integer, default=0) 
    is_favorite = Column(Boolean, default=False)
    is_locked = Column(Boolean, default=False)
    is_pinned = Column(Boolean, default=False)
    is_deleted = Column(Boolean, default=False, index=True)
    custom_color = Column(String(20), default=None)
    is_file = Column(Boolean, default=False)
    file_path = Column(Text, default=None)
    item_type = Column(String(20), default='text')
    image_path = Column(Text, default=None)
    data_blob = Column(BLOB, nullable=True)
    partition_id = Column(Integer, ForeignKey('partitions.id'), nullable=True)
    original_partition_id = Column(Integer, nullable=True)
    partition = relationship("Partition", back_populates="items")
    tags = relationship("Tag", secondary=item_tags, back_populates="items")

class Tag(Base):
    __tablename__ = 'tags'
    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(50), unique=True, nullable=False)
    items = relationship("ClipboardItem", secondary=item_tags, back_populates="tags")
    partitions = relationship("Partition", secondary=partition_tags, back_populates="tags")

class DBManager:
    def __init__(self, db_name='clipboard_data.db'):
        if getattr(sys, 'frozen', False):
            base_dir = os.path.dirname(sys.executable)
        else:
            base_dir = os.path.dirname(os.path.abspath(sys.argv[0]))
        
        db_path = os.path.join(base_dir, db_name)
        log.info(f"æ•°æ®åº“è·¯å¾„: {db_path}")

        try:
            self.engine = create_engine(f'sqlite:///{db_path}?check_same_thread=False', echo=False)
            Base.metadata.create_all(self.engine)
            self.Session = sessionmaker(bind=self.engine)
            self._check_migrations()
        except Exception as e:
            log.critical(f"æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥: {e}", exc_info=True)

    def _check_migrations(self):
        from sqlalchemy import inspect, text
        try:
            log.info("é€šç”¨è¿ç§»æ£€æŸ¥ï¼šä½¿ç”¨ SQLAlchemy Inspector")
            inspector = inspect(self.engine)
            
            with self.engine.connect() as connection:
                add_col_transaction = connection.begin()
                try:
                    for table_name, table in Base.metadata.tables.items():
                        log.debug(f"æ£€æŸ¥è¡¨ '{table_name}' çš„è¿ç§»...")
                        existing_cols = {c['name'] for c in inspector.get_columns(table_name)}
                        for column in table.columns:
                            if column.name not in existing_cols:
                                col_type = column.type.compile(self.engine.dialect)
                                stmt = text(f'ALTER TABLE {table_name} ADD COLUMN {column.name} {col_type}')
                                connection.execute(stmt)
                                log.info(f"âœ… è¡¨ '{table_name}' ä¸­æ·»åŠ å­—æ®µ: {column.name}")
                    add_col_transaction.commit()
                except Exception as e:
                    log.error(f"æ·»åŠ æ–°åˆ—å¤±è´¥ï¼Œæ­£åœ¨å›æ»š: {e}")
                    add_col_transaction.rollback()
                    raise

                if inspector.has_table("partition_groups"):
                    log.info("æ£€æµ‹åˆ°æ—§çš„ partition_groups è¡¨ï¼Œå¼€å§‹æ•°æ®è¿ç§»...")
                    migration_transaction = connection.begin()
                    try:
                        groups = connection.execute(text("SELECT id, name, color, sort_index FROM partition_groups ORDER BY id")).fetchall()
                        group_tags_results = connection.execute(text("SELECT partition_group_id, tag_id FROM partition_group_tags")).fetchall()
                        group_tags_map = {}
                        for group_id, tag_id in group_tags_results:
                            group_tags_map.setdefault(group_id, []).append(tag_id)

                        for old_group_id, name, color, sort_index in groups:
                            result = connection.execute(text(
                                "INSERT INTO partitions (name, color, sort_index, parent_id) VALUES (:name, :color, :sort_index, NULL)"
                            ), {"name": name, "color": color, "sort_index": sort_index})
                            
                            new_parent_id = result.lastrowid
                            log.info(f"  - åˆ†ç»„ '{name}' (ID:{old_group_id}) å·²è¿ç§»ä¸ºé¡¶å±‚åˆ†åŒº (ID:{new_parent_id})")

                            update_stmt = text("UPDATE partitions SET parent_id = :parent_id WHERE group_id = :group_id")
                            connection.execute(update_stmt, {"parent_id": new_parent_id, "group_id": old_group_id})

                            if old_group_id in group_tags_map:
                                for tag_id in group_tags_map[old_group_id]:
                                    connection.execute(text(
                                        "INSERT INTO partition_tags (partition_id, tag_id) VALUES (:p_id, :t_id)"
                                    ), {"p_id": new_parent_id, "t_id": tag_id})
                                log.info(f"    - æˆåŠŸè¿ç§» {len(group_tags_map[old_group_id])} ä¸ªæ ‡ç­¾")

                        connection.execute(text("DROP TABLE partition_group_tags"))
                        connection.execute(text("DROP TABLE partition_groups"))
                        log.info("æ—§çš„ partition_group_tags å’Œ partition_groups è¡¨å·²æˆåŠŸåˆ é™¤ã€‚")
                        
                        log.warning("æ—§çš„ partitions.group_id åˆ—å·²ä¿ç•™åœ¨æ•°æ®åº“ä¸­ï¼Œä½†ä¸ä¼šè¢«ä½¿ç”¨ã€‚")

                        migration_transaction.commit()
                        log.info("âœ… åˆ†åŒºæ•°æ®è¿ç§»æˆåŠŸå®Œæˆï¼")
                    except Exception as e:
                        log.error(f"åˆ†åŒºæ•°æ®è¿ç§»å¤±è´¥ï¼Œæ­£åœ¨å›æ»š: {e}")
                        migration_transaction.rollback()
                        raise
        except Exception as e:
            log.error(f"è¿ç§»æ£€æŸ¥å¤±è´¥: {e}", exc_info=True)

    def get_session(self):
        return self.Session()

    def add_item(self, text, is_file=False, file_path=None, item_type='text', image_path=None, partition_id=None, data_blob=None):
        session = self.get_session()
        try:
            text_hash = hashlib.sha256(text.encode('utf-8')).hexdigest()
            existing = session.query(ClipboardItem).filter_by(content_hash=text_hash).first()
            if existing:
                existing.last_visited_at = datetime.now()
                existing.modified_at = datetime.now()
                existing.visit_count += 1
                if partition_id and not existing.partition_id:
                     existing.partition_id = partition_id
                session.commit()
                return existing, False
            
            min_sort = session.query(func.min(ClipboardItem.sort_index)).scalar()
            new_sort = (min_sort - 1.0) if min_sort is not None else 0.0
            note_txt = os.path.basename(file_path) if is_file and file_path else text.split('\n')[0][:50]
            
            new_item = ClipboardItem(
                content=text, content_hash=text_hash, sort_index=new_sort, note=note_txt,
                is_file=is_file, file_path=file_path, item_type=item_type, image_path=image_path,
                partition_id=partition_id, data_blob=data_blob
            )
            session.add(new_item)
            try:
                session.commit()
                session.refresh(new_item)
                return new_item, True
            except Exception:
                session.rollback()
                existing = session.query(ClipboardItem).filter_by(content_hash=text_hash).first()
                if existing:
                    existing.last_visited_at = datetime.now()
                    existing.visit_count += 1
                    session.commit()
                    return existing, False
                return None, False
        except Exception as e:
            log.error(f"å†™å…¥å¤±è´¥: {e}")
            session.rollback()
            return None, False
        finally:
            session.close()

    def _build_query(self, session, sort_mode="manual", date_filter=None, date_modify_filter=None, partition_filter=None, include_deleted=False):
        log.debug(f"ğŸ” æ„å»ºæŸ¥è¯¢: sort={sort_mode}, date={date_filter}, date_modify={date_modify_filter}, partition={partition_filter}, deleted={include_deleted}")
        q = session.query(ClipboardItem).options(joinedload(ClipboardItem.tags))
        if include_deleted:
            q = q.filter(ClipboardItem.is_deleted == True)
        else:
            q = q.filter(ClipboardItem.is_deleted != True)
        
        if partition_filter:
            ptype = partition_filter.get('type')
            pid = partition_filter.get('id')
            if ptype == 'partition':
                q = q.filter(ClipboardItem.partition_id.in_(self._get_all_descendant_ids(session, pid)))
            elif ptype == 'uncategorized':
                q = q.filter(ClipboardItem.partition_id == None)
            elif ptype == 'untagged':
                q = q.filter(~exists().where(item_tags.c.item_id == ClipboardItem.id))
        
        def apply_date_filter(query, column, filter_str):
            if not filter_str:
                return query
            today = datetime.now().date()
            start_dt, end_dt = None, None
            if filter_str == "ä»Šæ—¥":
                start_dt, end_dt = datetime.combine(today, time.min), datetime.combine(today, time.max)
            elif filter_str == "æ˜¨æ—¥":
                start_dt, end_dt = datetime.combine(today - timedelta(days=1), time.min), datetime.combine(today - timedelta(days=1), time.max)
            elif filter_str == "å‘¨å†…":
                start_dt = datetime.combine(today - timedelta(days=7), time.min)
            elif filter_str == "ä¸¤å‘¨":
                start_dt = datetime.combine(today - timedelta(days=14), time.min)
            elif filter_str == "æœ¬æœˆ":
                start_dt = datetime.combine(today.replace(day=1), time.min)
            elif filter_str == "ä¸Šæœˆ":
                first_day = today.replace(day=1)
                last_month_end = first_day - timedelta(days=1)
                start_dt, end_dt = datetime.combine(last_month_end.replace(day=1), time.min), datetime.combine(last_month_end, time.max)
            
            if start_dt:
                query = query.filter(column >= start_dt)
            if end_dt:
                query = query.filter(column <= end_dt)
            return query

        q = apply_date_filter(q, ClipboardItem.created_at, date_filter)
        q = apply_date_filter(q, ClipboardItem.modified_at, date_modify_filter)
            
        if sort_mode == "manual":
            q = q.order_by(ClipboardItem.is_pinned.desc(), ClipboardItem.sort_index.asc())
        elif sort_mode == "time":
            q = q.order_by(ClipboardItem.is_pinned.desc(), ClipboardItem.created_at.desc())
        return q

    def get_items(self, sort_mode="manual", limit=50, offset=0, date_filter=None, date_modify_filter=None, partition_filter=None):
        session = self.get_session()
        try:
            include_deleted = (partition_filter and partition_filter.get('type') == 'trash')
            q = self._build_query(session, sort_mode=sort_mode, date_filter=date_filter, date_modify_filter=date_modify_filter, partition_filter=partition_filter, include_deleted=include_deleted)
            if limit is not None:
                q = q.limit(limit)
            if offset > 0:
                q = q.offset(offset)
            return q.all()
        except Exception as e:
            log.error(f"æŸ¥è¯¢å¤±è´¥: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def get_count(self, date_filter=None, date_modify_filter=None, partition_filter=None):
        session = self.get_session()
        try:
            include_deleted = (partition_filter and partition_filter.get('type') == 'trash')
            q = self._build_query(session, date_filter=date_filter, date_modify_filter=date_modify_filter, partition_filter=partition_filter, include_deleted=include_deleted)
            return q.count()
        except Exception as e:
            log.error(f"è®¡æ•°å¤±è´¥: {e}", exc_info=True)
            return 0
        finally:
            session.close()

    def update_item(self, item_id, **kwargs):
        session = self.get_session()
        try:
            item = session.query(ClipboardItem).get(item_id)
            if item:
                for k, v in kwargs.items():
                    setattr(item, k, v)
                session.commit()
                return True
            return False
        except Exception as e:
            log.error(f"æ›´æ–°å¤±è´¥: {e}")
            session.rollback()
            return False
        finally:
            session.close()

    def move_items_to_trash(self, ids):
        session = self.get_session()
        try:
            items = session.query(ClipboardItem).filter(ClipboardItem.id.in_(ids), ClipboardItem.is_locked == False).all()
            for item in items:
                item.original_partition_id = item.partition_id
                item.partition_id = None
                item.is_deleted = True
            session.commit()
        except Exception as e:
            log.error(f"ç§»åŠ¨åˆ°å›æ”¶ç«™å¤±è´¥: {e}")
            session.rollback()
        finally:
            session.close()

    def restore_items_from_trash(self, ids):
        session = self.get_session()
        try:
            items = session.query(ClipboardItem).filter(ClipboardItem.id.in_(ids)).all()
            if not items:
                return
            existing_pids = {p_id for p_id, in session.query(Partition.id).all()}
            for item in items:
                item.is_deleted = False
                item.partition_id = item.original_partition_id if item.original_partition_id in existing_pids else None
                item.original_partition_id = None
            session.commit()
        except Exception as e:
            log.error(f"ä»å›æ”¶ç«™æ¢å¤å¤±è´¥: {e}")
            session.rollback()
        finally:
            session.close()

    def delete_items_permanently(self, ids):
        session = self.get_session()
        try:
            session.query(ClipboardItem).filter(ClipboardItem.id.in_(ids)).delete(synchronize_session=False)
            session.commit()
        except Exception as e:
            log.error(f"æ°¸ä¹…åˆ é™¤å¤±è´¥: {e}")
            session.rollback()
        finally:
            session.close()

    def update_sort_order(self, ids):
        session = self.get_session()
        try:
            for idx, i in enumerate(ids):
                item = session.query(ClipboardItem).get(i)
                if item:
                    item.sort_index = float(idx)
            session.commit()
        except Exception as e:
            log.error(f"æ›´æ–°æ’åºå¤±è´¥: {e}")
            session.rollback()
        finally:
            session.close()

    def get_stats(self):
        stats = {'tags': [], 'stars': {}, 'colors': {}, 'types': {}}
        session = self.get_session()
        try:
            last_used = func.max(ClipboardItem.modified_at).label("last_used")
            stats['tags'] = session.query(Tag.name, func.count(item_tags.c.item_id)).outerjoin(item_tags).outerjoin(ClipboardItem).group_by(Tag.id).order_by(last_used.desc()).all()
            stats['stars'] = {s: c for s, c in session.query(ClipboardItem.star_level, func.count(ClipboardItem.id)).group_by(ClipboardItem.star_level).all()}
            stats['colors'] = {c: count for c, count in session.query(ClipboardItem.custom_color, func.count(ClipboardItem.id)).group_by(ClipboardItem.custom_color).all() if c}
            return stats
        except Exception as e:
            log.error(f"è·å–ç»Ÿè®¡å¤±è´¥: {e}", exc_info=True)
            return stats
        finally:
            session.close()

    def add_tags_to_items(self, item_ids, tag_names):
        session = self.get_session()
        try:
            items = session.query(ClipboardItem).filter(ClipboardItem.id.in_(item_ids)).all()
            if not items:
                return
            for name in [name.strip() for name in tag_names if name.strip()]:
                tag = session.query(Tag).filter_by(name=name).first() or Tag(name=name)
                session.add(tag)
                session.flush()
                for item in items:
                    if tag not in item.tags:
                        item.tags.append(tag)
            session.commit()
        except Exception as e:
            log.error(f"æ‰¹é‡æ·»åŠ æ ‡ç­¾å¤±è´¥: {e}")
            session.rollback()
        finally:
            session.close()

    def remove_tag_from_item(self, item_id, tag_name):
        session = self.get_session()
        try:
            item = session.query(ClipboardItem).get(item_id)
            tag = session.query(Tag).filter_by(name=tag_name).first()
            if item and tag and tag in item.tags:
                item.tags.remove(tag)
                session.commit()
        except Exception as e:
            log.error(f"ç§»é™¤æ ‡ç­¾å¤±è´¥: {e}")
            session.rollback()
        finally:
            session.close()

    def auto_delete_old_data(self, days=21):
        session = self.get_session()
        try:
            count = session.query(ClipboardItem).filter(
                ClipboardItem.created_at < datetime.now() - timedelta(days=days),
                ClipboardItem.is_locked == False
            ).delete(synchronize_session=False)
            session.commit()
            return count
        except Exception as e:
            log.error(f"æ¸…ç†æ—§æ•°æ®å¤±è´¥: {e}")
            session.rollback()
            return 0
        finally:
            session.close()

    def get_partitions_tree(self):
        session = self.get_session()
        try:
            all_partitions = session.query(Partition).order_by(Partition.sort_index).all()
            for p in all_partitions:
                len(p.children)
            return [p for p in all_partitions if p.parent_id is None]
        except Exception as e:
            log.error(f"è·å–åˆ†åŒºæ ‘å¤±è´¥: {e}", exc_info=True)
            return []
        finally:
            session.close()

    def add_partition(self, name, parent_id=None):
        session = self.get_session()
        try:
            new_p = Partition(name=name, parent_id=parent_id)
            session.add(new_p)
            session.commit()
            session.refresh(new_p)
            return new_p
        except Exception as e:
            log.error(f"æ·»åŠ åˆ†åŒºå¤±è´¥: {e}", exc_info=True)
            session.rollback()
            return None
        finally:
            session.close()

    def rename_partition(self, partition_id, new_name):
        session = self.get_session()
        try:
            p = session.query(Partition).get(partition_id)
            if p:
                p.name = new_name
                session.commit()
            return True
        except Exception as e:
            log.error(f"é‡å‘½ååˆ†åŒºå¤±è´¥: {e}")
            session.rollback()
            return False
        finally:
            session.close()

    def _get_all_descendant_ids(self, session, partition_id):
        cte = session.query(Partition.id).filter(Partition.id == partition_id).cte(name="cte", recursive=True)
        cte = cte.union_all(session.query(Partition.id).filter(Partition.parent_id == cte.c.id))
        return [i[0] for i in session.query(cte.c.id).all()]

    def delete_partition(self, partition_id):
        session = self.get_session()
        try:
            p_to_del = session.query(Partition).get(partition_id)
            if not p_to_del:
                return False
            all_ids = self._get_all_descendant_ids(session, partition_id)
            item_ids = [i[0] for i in session.query(ClipboardItem.id).filter(ClipboardItem.partition_id.in_(all_ids)).all()]
            if item_ids:
                self.move_items_to_trash(item_ids)
            session.delete(p_to_del)
            session.commit()
            return True
        except Exception as e:
            log.error(f"é€’å½’åˆ é™¤åˆ†åŒºå¤±è´¥: {e}")
            session.rollback()
            return False
        finally:
            session.close()

    def update_partition(self, partition_id, **kwargs):
        session = self.get_session()
        try:
            p = session.query(Partition).get(partition_id)
            if p:
                for k, v in kwargs.items():
                    setattr(p, k, v)
                session.commit()
            return True
        except Exception as e:
            log.error(f"æ›´æ–°åˆ†åŒºå¤±è´¥: {e}")
            session.rollback()
            return False
        finally:
            session.close()

    def get_partition_item_counts(self):
        session = self.get_session()
        try:
            base_q = session.query(ClipboardItem).filter(ClipboardItem.is_deleted != True)
            direct_counts = dict(base_q.with_entities(ClipboardItem.partition_id, func.count(ClipboardItem.id)).group_by(ClipboardItem.partition_id).all())
            uncategorized = direct_counts.pop(None, 0)
            total_counts = direct_counts.copy()
            partitions = session.query(Partition).all()
            p_map = {p.id: p for p in partitions}
            for p in partitions:
                direct_count = direct_counts.get(p.id, 0)
                if direct_count > 0:
                    parent = p_map.get(p.parent_id)
                    while parent:
                        total_counts[parent.id] = total_counts.get(parent.id, 0) + direct_count
                        parent = p_map.get(parent.parent_id)
            today_start = datetime.combine(datetime.now().date(), time.min)
            return {
                'total': base_q.count(),
                'partitions': total_counts,
                'uncategorized': uncategorized,
                'untagged': base_q.filter(~exists().where(item_tags.c.item_id == ClipboardItem.id)).count(),
                'trash': session.query(func.count(ClipboardItem.id)).filter(ClipboardItem.is_deleted == True).scalar(),
                'today_modified': base_q.filter(ClipboardItem.modified_at >= today_start).count()
            }
        except Exception as e:
            log.error(f"è·å–åˆ†åŒºé¡¹ç›®è®¡æ•°å¤±è´¥: {e}", exc_info=True)
            return {}
        finally:
            session.close()

    def move_items_to_partition(self, item_ids, partition_id):
        session = self.get_session()
        try:
            session.query(ClipboardItem).filter(ClipboardItem.id.in_(item_ids)).update({'partition_id': partition_id}, synchronize_session=False)
            session.commit()
            return True
        except Exception as e:
            log.error(f"ç§»åŠ¨é¡¹ç›®åˆ°åˆ†åŒºå¤±è´¥: {e}", exc_info=True)
            session.rollback()
            return False
        finally:
            session.close()

    def restore_and_move_items(self, item_ids, target_partition_id):
        session = self.get_session()
        try:
            items = session.query(ClipboardItem).filter(ClipboardItem.id.in_(item_ids)).all()
            if not items:
                return False
            for item in items:
                item.is_deleted = False
                item.partition_id = target_partition_id
                item.original_partition_id = None
            session.commit()
            return True
        except Exception as e:
            log.error(f"æ¢å¤å¹¶ç§»åŠ¨é¡¹ç›®å¤±è´¥: {e}", exc_info=True)
            session.rollback()
            return False
        finally:
            session.close()
```

## æ–‡ä»¶: data\__init__.py

```python

```

## æ–‡ä»¶: handlers\base_handler.py

```python
# -*- coding: utf-8 -*-
"""
å‰ªè´´æ¿å¤„ç†å™¨åŸºç±»
å®šä¹‰æ‰€æœ‰å¤„ç†å™¨çš„æŠ½è±¡æ¥å£
"""
from abc import ABC, abstractmethod
from PyQt5.QtCore import QMimeData
import logging

log = logging.getLogger("BaseHandler")


class BaseHandler(ABC):
    """å‰ªè´´æ¿å¤„ç†å™¨æŠ½è±¡åŸºç±»"""
    
    def __init__(self, priority=100):
        """
        åˆå§‹åŒ–å¤„ç†å™¨
        
        Args:
            priority: å¤„ç†å™¨ä¼˜å…ˆçº§ï¼Œæ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜
        """
        self.priority = priority
        self.last_content = ""  # ç”¨äºå»é‡
    
    @abstractmethod
    def can_handle(self, mime_data: QMimeData) -> bool:
        """
        åˆ¤æ–­æ˜¯å¦èƒ½å¤„ç†è¯¥å‰ªè´´æ¿æ•°æ®
        
        Args:
            mime_data: Qtå‰ªè´´æ¿æ•°æ®å¯¹è±¡
            
        Returns:
            bool: Trueè¡¨ç¤ºå¯ä»¥å¤„ç†ï¼ŒFalseè¡¨ç¤ºä¸èƒ½å¤„ç†
        """
        pass
    
    @abstractmethod
    def handle(self, mime_data: QMimeData, db_manager, partition_info: dict = None):
        """
        å¤„ç†å‰ªè´´æ¿æ•°æ®
        
        Args:
            mime_data: Qtå‰ªè´´æ¿æ•°æ®å¯¹è±¡
            db_manager: æ•°æ®åº“ç®¡ç†å™¨å®ä¾‹
            partition_info: (å¯é€‰) åˆ†åŒºä¿¡æ¯ {'type': 'group'/'partition', 'id': ID}
            
        Returns:
            Tuple[Optional[ClipboardItem], bool]: (æ–°é¡¹ç›®, æ˜¯å¦ä¸ºæ–°)
        """
        pass
    
    def _is_duplicate(self, content: str) -> bool:
        """
        æ£€æŸ¥å†…å®¹æ˜¯å¦é‡å¤
        
        Args:
            content: è¦æ£€æŸ¥çš„å†…å®¹
            
        Returns:
            bool: Trueè¡¨ç¤ºé‡å¤ï¼ŒFalseè¡¨ç¤ºä¸é‡å¤
        """
        if content == self.last_content:
            return True
        self.last_content = content
        return False
```

## æ–‡ä»¶: handlers\file_handler.py

```python
# -*- coding: utf-8 -*-
"""
æ–‡ä»¶å¤„ç†å™¨
å¤„ç†æ–‡ä»¶å‰ªè´´æ¿æ•°æ®ï¼Œå°†å•ä¸ªæˆ–å¤šä¸ªæ–‡ä»¶æ‰“åŒ…å­˜å…¥æ•°æ®åº“
"""
import logging
import os
import io
import zipfile
from PyQt5.QtCore import QMimeData
from handlers.base_handler import BaseHandler

log = logging.getLogger("FileHandler")


class FileHandler(BaseHandler):
    """æ–‡ä»¶å¤„ç†å™¨ (æ”¯æŒå¤šæ–‡ä»¶æ‰“åŒ…)"""
    
    def __init__(self):
        super().__init__(priority=20)
    
    def can_handle(self, mime_data: QMimeData) -> bool:
        """åˆ¤æ–­å‰ªè´´æ¿ä¸­æ˜¯å¦æœ‰æœ¬åœ°æ–‡ä»¶"""
        if not mime_data.hasUrls():
            return False
        
        # æ£€æŸ¥å¹¶ç¡®è®¤è‡³å°‘æœ‰ä¸€ä¸ªURLæ˜¯æœ¬åœ°æ–‡ä»¶
        for url in mime_data.urls():
            if url.isLocalFile():
                return True
        return False
    
    def handle(self, mime_data: QMimeData, db_manager, partition_info: dict = None):
        """å¤„ç†æ–‡ä»¶ï¼Œå°†å•ä¸ªæ–‡ä»¶æˆ–å¤šä¸ªæ–‡ä»¶çš„ZIPåŒ…å­˜å…¥æ•°æ®åº“"""
        try:
            local_files = [u.toLocalFile() for u in mime_data.urls() if u.isLocalFile()]
            
            if not local_files:
                return None, False
            
            # --- ç”ŸæˆUIæ˜¾ç¤ºæ–‡æœ¬ ---
            filenames = [os.path.basename(p) for p in local_files]
            if len(local_files) == 1:
                display_text = f"æ–‡ä»¶: {filenames[0]}"
            else:
                display_text = f"å‹ç¼©åŒ… ({len(filenames)}ä¸ªæ–‡ä»¶): {', '.join(filenames)}"
            
            # æ™ºèƒ½æˆªæ–­ï¼Œé¿å…è¿‡é•¿
            if len(display_text) > 150:
                 display_text = f"å‹ç¼©åŒ… ({len(filenames)}ä¸ªæ–‡ä»¶): {filenames[0]}, {filenames[1]}..."

            # --- å»é‡æ£€æŸ¥ (åŸºäºç”Ÿæˆçš„æ˜¾ç¤ºæ–‡æœ¬) ---
            if self._is_duplicate(display_text):
                log.debug("æ–‡ä»¶ç»„åˆé‡å¤ï¼Œè·³è¿‡")
                return None, False
            
            # --- å¤„ç†æ–‡ä»¶æ•°æ® ---
            file_blob = None
            if len(local_files) == 1:
                # å•ä¸ªæ–‡ä»¶: ç›´æ¥è¯»å–äºŒè¿›åˆ¶å†…å®¹
                log.info(f"è¯»å–å•ä¸ªæ–‡ä»¶: {local_files[0]}")
                with open(local_files[0], 'rb') as f:
                    file_blob = f.read()
            else:
                # å¤šä¸ªæ–‡ä»¶: åœ¨å†…å­˜ä¸­åˆ›å»ºZIPå‹ç¼©åŒ…
                log.info(f"æ‰“åŒ… {len(local_files)} ä¸ªæ–‡ä»¶åˆ°å†…å­˜ZIP...")
                mem_zip = io.BytesIO()
                with zipfile.ZipFile(mem_zip, mode='w', compression=zipfile.ZIP_DEFLATED) as zf:
                    for file_path in local_files:
                        zf.write(file_path, arcname=os.path.basename(file_path))
                mem_zip.seek(0)
                file_blob = mem_zip.read()
            
            if not file_blob:
                log.warning("æœªèƒ½æˆåŠŸç”Ÿæˆæ–‡ä»¶æˆ–å‹ç¼©åŒ…çš„äºŒè¿›åˆ¶æ•°æ®")
                return None, False

            # --- å­˜å…¥æ•°æ®åº“ ---
            partition_id = partition_info.get('id') if partition_info and partition_info.get('type') == 'partition' else None
            
            item, is_new = db_manager.add_item(
                text=display_text,
                item_type='file',
                is_file=True,
                file_path=';'.join(local_files),  # å­˜å‚¨åŸå§‹è·¯å¾„åˆ—è¡¨ï¼Œç”¨åˆ†å·åˆ†éš”
                data_blob=file_blob,              # å­˜å‚¨å®é™…çš„æ–‡ä»¶äºŒè¿›åˆ¶æ•°æ®æˆ–ZIPæ•°æ®
                partition_id=partition_id
            )
            
            if is_new:
                log.info(f"âœ… æˆåŠŸæ•è· {len(local_files)} ä¸ªæ–‡ä»¶åˆ°æ•°æ®åº“")

            return item, is_new
            
        except Exception as e:
            log.error(f"å¤„ç†æ–‡ä»¶å‰ªè´´æ¿æ•°æ®å¤±è´¥: {e}", exc_info=True)
            return None, False
```

## æ–‡ä»¶: handlers\image_handler.py

```python
# -*- coding: utf-8 -*-
"""
å›¾ç‰‡å¤„ç†å™¨
å¤„ç†å›¾ç‰‡å‰ªè´´æ¿æ•°æ®ï¼ˆæ–°åŠŸèƒ½ï¼‰
"""
import logging
import os
import sys
import hashlib
from datetime import datetime
from PyQt5.QtCore import QMimeData, QBuffer, QByteArray, QIODevice
from PyQt5.QtGui import QImage
from handlers.base_handler import BaseHandler

log = logging.getLogger("ImageHandler")


class ImageHandler(BaseHandler):
    """å›¾ç‰‡å¤„ç†å™¨"""
    
    def __init__(self):
        super().__init__(priority=10)
    
    def can_handle(self, mime_data: QMimeData) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºå›¾ç‰‡æ•°æ®"""
        return mime_data.hasImage()
    
    def handle(self, mime_data: QMimeData, db_manager, partition_info: dict = None):
        """å¤„ç†å›¾ç‰‡æ•°æ®"""
        try:
            image = mime_data.imageData()
            if not image or image.isNull():
                log.warning("å›¾ç‰‡æ•°æ®ä¸ºç©º")
                return None, False
            
            qimage = QImage(image)
            if qimage.isNull():
                log.warning("æ— æ³•è§£æå›¾ç‰‡")
                return None, False

            # å°† QImage è½¬æ¢ä¸ºäºŒè¿›åˆ¶æ•°æ® (PNGæ ¼å¼)
            byte_array = QByteArray()
            buffer = QBuffer(byte_array)
            buffer.open(QIODevice.WriteOnly)
            qimage.save(buffer, "PNG")
            image_blob = byte_array.data()

            # è®¡ç®—å“ˆå¸Œç”¨äºå»é‡
            img_hash = hashlib.md5(image_blob).hexdigest()
            if self._is_duplicate(img_hash):
                log.debug("å›¾ç‰‡é‡å¤ï¼Œè·³è¿‡")
                return None, False

            # ç”Ÿæˆç¼©ç•¥å›¾çš„äºŒè¿›åˆ¶æ•°æ®
            thumbnail_blob = self._create_thumbnail_blob(qimage)

            partition_id = partition_info.get('id') if partition_info and partition_info.get('type') == 'partition' else None
            
            item, is_new = db_manager.add_item(
                text=f"[å›¾ç‰‡] {qimage.width()}x{qimage.height()}",
                item_type='image',
                is_file=False,
                data_blob=image_blob,
                thumbnail_blob=thumbnail_blob,
                partition_id=partition_id
            )
            
            if is_new:
                size_kb = len(image_blob) / 1024
                log.info(f"âœ… æ•è·å›¾ç‰‡: {qimage.width()}x{qimage.height()} ({size_kb:.1f}KB)")

            return item, is_new
            
        except Exception as e:
            log.error(f"å›¾ç‰‡å¤„ç†å¤±è´¥: {e}", exc_info=True)
            return None, False

    def _create_thumbnail_blob(self, qimage: QImage) -> bytes:
        """åˆ›å»ºç¼©ç•¥å›¾å¹¶è¿”å›å…¶äºŒè¿›åˆ¶æ•°æ®"""
        try:
            thumb_size = 200
            thumbnail = qimage.scaled(thumb_size, thumb_size, aspectRatioMode=Qt.KeepAspectRatio, transformMode=Qt.SmoothTransformation)
            
            byte_array = QByteArray()
            buffer = QBuffer(byte_array)
            buffer.open(QIODevice.WriteOnly)
            thumbnail.save(buffer, "PNG")
            return byte_array.data()
        except Exception as e:
            log.error(f"åˆ›å»ºç¼©ç•¥å›¾å¤±è´¥: {e}")
            return None
```

## æ–‡ä»¶: handlers\text_handler.py

```python
# -*- coding: utf-8 -*-
"""
æ–‡æœ¬å¤„ç†å™¨
å¤„ç†çº¯æ–‡æœ¬å‰ªè´´æ¿æ•°æ®ï¼ˆæ’é™¤URLï¼‰
"""
import logging
import re
from PyQt5.QtCore import QMimeData
from handlers.base_handler import BaseHandler

log = logging.getLogger("TextHandler")


class TextHandler(BaseHandler):
    """çº¯æ–‡æœ¬å¤„ç†å™¨"""
    
    def __init__(self):
        super().__init__(priority=40)  # æœ€ä½ä¼˜å…ˆçº§ï¼Œä½œä¸ºå…œåº•
        self.url_pattern = re.compile(
            r'https?://(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b'
            r'(?:[-a-zA-Z0-9()@:%_\+.~#?&/=]*)'
        )
    
    def can_handle(self, mime_data: QMimeData) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºçº¯æ–‡æœ¬ï¼ˆæ’é™¤URLï¼‰"""
        if not mime_data.hasText():
            return False
        
        text = mime_data.text().strip()
        if not text:
            return False
        
        # å¦‚æœæ˜¯URLï¼Œäº¤ç»™URLå¤„ç†å™¨
        if self.url_pattern.match(text):
            return False
        
        return True
    
    def handle(self, mime_data: QMimeData, db_manager, partition_info: dict = None):
        """å¤„ç†çº¯æ–‡æœ¬"""
        try:
            text = mime_data.text().strip()
            
            # å»é‡æ£€æŸ¥
            if self._is_duplicate(text):
                log.debug("æ–‡æœ¬é‡å¤ï¼Œè·³è¿‡")
                return None, False
            
            partition_id = partition_info.get('id') if partition_info and partition_info.get('type') == 'partition' else None
            
            # ä¿å­˜åˆ°æ•°æ®åº“
            item, is_new = db_manager.add_item(
                text=text,
                item_type='text',
                is_file=False,
                partition_id=partition_id
            )
            
            if is_new:
                log.info(f"âœ… æ•è·æ–‡æœ¬: {text[:50]}...")
            
            return item, is_new
            
        except Exception as e:
            log.error(f"æ–‡æœ¬å¤„ç†å¤±è´¥: {e}", exc_info=True)
            return None, False
```

## æ–‡ä»¶: handlers\url_handler.py

```python
# -*- coding: utf-8 -*-
"""
URLå¤„ç†å™¨
å¤„ç†URLé“¾æ¥å‰ªè´´æ¿æ•°æ®ï¼ˆæ–°åŠŸèƒ½ï¼‰
"""
import logging
import re
from urllib.parse import urlparse
from PyQt5.QtCore import QMimeData
from handlers.base_handler import BaseHandler

log = logging.getLogger("URLHandler")


class URLHandler(BaseHandler):
    """URLé“¾æ¥å¤„ç†å™¨"""
    
    def __init__(self):
        super().__init__(priority=30)  # ä¸­ç­‰ä¼˜å…ˆçº§
        # URLæ­£åˆ™è¡¨è¾¾å¼
        self.url_pattern = re.compile(
            r'https?://(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b'
            r'(?:[-a-zA-Z0-9()@:%_\+.~#?&/=]*)'
        )
    
    def can_handle(self, mime_data: QMimeData) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºURL"""
        if not mime_data.hasText():
            return False
        
        text = mime_data.text().strip()
        if not text:
            return False
        
        # æ£€æŸ¥æ˜¯å¦åŒ¹é…URLæ ¼å¼
        return bool(self.url_pattern.match(text))
    
    def handle(self, mime_data: QMimeData, db_manager, partition_info: dict = None):
        """å¤„ç†URL"""
        try:
            url = mime_data.text().strip()
            
            # å»é‡æ£€æŸ¥
            if self._is_duplicate(url):
                log.debug("URLé‡å¤ï¼Œè·³è¿‡")
                return None, False
            
            # è§£æURL
            parsed = urlparse(url)
            domain = parsed.netloc or "æœªçŸ¥åŸŸå"
            
            # æå–è·¯å¾„ä½œä¸ºç®€çŸ­æè¿°
            path = parsed.path.strip('/') or "é¦–é¡µ"
            if len(path) > 30:
                path = path[:27] + "..."
            
            # æ„å»ºæ˜¾ç¤ºæ–‡æœ¬
            display_text = f"[é“¾æ¥] {domain}/{path}"
            
            partition_id = partition_info.get('id') if partition_info and partition_info.get('type') == 'partition' else None
            
            # ä¿å­˜åˆ°æ•°æ®åº“
            item, is_new = db_manager.add_item(
                text=url,
                item_type='url',
                is_file=False,
                url=url,
                url_domain=domain,
                url_title=path,  # æš‚æ—¶ä½¿ç”¨è·¯å¾„ä½œä¸ºæ ‡é¢˜
                partition_id=partition_id
            )
            
            if is_new:
                log.info(f"âœ… æ•è·URL: {domain}")
            
            return item, is_new
            
        except Exception as e:
            log.error(f"URLå¤„ç†å¤±è´¥: {e}", exc_info=True)
            return None, False
```

## æ–‡ä»¶: handlers\__init__.py

```python
# -*- coding: utf-8 -*-
"""
å‰ªè´´æ¿å¤„ç†å™¨æ¨¡å—
å¯¼å‡ºæ‰€æœ‰å¤„ç†å™¨ç±»
"""
from handlers.base_handler import BaseHandler
from handlers.text_handler import TextHandler
from handlers.file_handler import FileHandler
from handlers.image_handler import ImageHandler
from handlers.url_handler import URLHandler

__all__ = [
    'BaseHandler',
    'TextHandler',
    'FileHandler',
    'ImageHandler',
    'URLHandler'
]
```

## æ–‡ä»¶: services\clipboard.py

```python
# -*- coding: utf-8 -*-
"""
å‰ªè´´æ¿ç®¡ç†å™¨
ä½¿ç”¨ç­–ç•¥æ¨¡å¼å¤„ç†ä¸åŒç±»å‹çš„å‰ªè´´æ¿æ•°æ®
"""
import logging
from PyQt5.QtCore import QObject, pyqtSignal, QMimeData

log = logging.getLogger("ClipboardSvc")


class ClipboardManager(QObject):
    """å‰ªè´´æ¿ç®¡ç†å™¨ - ä½¿ç”¨ç­–ç•¥æ¨¡å¼"""
    
    data_captured = pyqtSignal(bool)

    def __init__(self, db_manager):
        super().__init__()
        self.db = db_manager
        self.handlers = []
        self._register_handlers()
    
    def _register_handlers(self):
        """æ³¨å†Œæ‰€æœ‰å¤„ç†å™¨ï¼ŒæŒ‰ä¼˜å…ˆçº§æ’åº"""
        try:
            from handlers import ImageHandler, FileHandler, URLHandler, TextHandler
            
            # åˆ›å»ºå¤„ç†å™¨å®ä¾‹
            self.handlers = [
                ImageHandler(),   # ä¼˜å…ˆçº§ 10 - æœ€é«˜
                FileHandler(),    # ä¼˜å…ˆçº§ 20
                URLHandler(),     # ä¼˜å…ˆçº§ 30
                TextHandler(),    # ä¼˜å…ˆçº§ 40 - æœ€ä½ï¼ˆå…œåº•ï¼‰
            ]
            
            # æŒ‰ä¼˜å…ˆçº§æ’åºï¼ˆæ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜ï¼‰
            self.handlers.sort(key=lambda h: h.priority)
            
            log.info(f"âœ… æ³¨å†Œäº† {len(self.handlers)} ä¸ªå¤„ç†å™¨")
            for handler in self.handlers:
                log.debug(f"  - {handler.__class__.__name__} (ä¼˜å…ˆçº§: {handler.priority})")
                
        except Exception as e:
            log.error(f"å¤„ç†å™¨æ³¨å†Œå¤±è´¥: {e}", exc_info=True)
            self.handlers = []
    
    def process_clipboard(self, mime_data: QMimeData, partition_info: dict = None):
        """
        ä½¿ç”¨è´£ä»»é“¾æ¨¡å¼å¤„ç†å‰ªè´´æ¿æ•°æ®
        
        Args:
            mime_data: Qtå‰ªè´´æ¿æ•°æ®å¯¹è±¡
            partition_info: (å¯é€‰) å½“å‰é€‰ä¸­çš„åˆ†åŒºä¿¡æ¯
            
        Returns:
            bool: Trueè¡¨ç¤ºæˆåŠŸå¤„ç†ï¼ŒFalseè¡¨ç¤ºæœªå¤„ç†
        """
        try:
            # éå†æ‰€æœ‰å¤„ç†å™¨
            for handler in self.handlers:
                if handler.can_handle(mime_data):
                    log.debug(f"ä½¿ç”¨ {handler.__class__.__name__} å¤„ç†")
                    item, is_new = handler.handle(mime_data, self.db, partition_info)
                    
                    if item and is_new:
                        # æˆåŠŸåˆ›å»ºäº†æ–°é¡¹ç›®
                        # æ£€æŸ¥æ˜¯å¦éœ€è¦æ·»åŠ é¢„è®¾æ ‡ç­¾ (åˆå¹¶ç»„å’ŒåŒºçš„æ ‡ç­¾)
                        if partition_info and partition_info.get('type') == 'partition' and item.partition:
                            all_tags = set()
                            
                            # è·å–åŒºçš„æ ‡ç­¾
                            partition_tags = self.db.get_partition_tags(item.partition.id)
                            if partition_tags:
                                all_tags.update(partition_tags)
                            
                            # è·å–ç»„çš„æ ‡ç­¾
                            if item.partition.group_id:
                                group_tags = self.db.get_partition_group_tags(item.partition.group_id)
                                if group_tags:
                                    all_tags.update(group_tags)

                            if all_tags:
                                final_tags = list(all_tags)
                                log.info(f"ä¸ºæ–°é¡¹ç›® {item.id} æ·»åŠ é¢„è®¾æ ‡ç­¾: {final_tags}")
                                self.db.add_tags_to_items([item.id], final_tags)

                        self.data_captured.emit(True)
                        return True
                    elif not is_new and item:
                        # é¡¹ç›®å·²å­˜åœ¨
                        return False
            
            # æ²¡æœ‰å¤„ç†å™¨èƒ½å¤„ç†è¯¥æ•°æ®
            formats = mime_data.formats()
            log.debug(f"æ²¡æœ‰åˆé€‚çš„å¤„ç†å™¨ã€‚å¯ç”¨æ ¼å¼: {list(formats)}")
            return False
            
        except Exception as e:
            log.error(f"å¤„ç†é”™è¯¯: {e}", exc_info=True)
            return False
```

## æ–‡ä»¶: services\__init__.py

```python

```

## æ–‡ä»¶: themes\dark.py

```python
# -*- coding: utf-8 -*-
"""
æ·±è‰²ä¸»é¢˜æ ·å¼è¡¨ - æç®€ç°ä»£ç‰ˆ
å»é™¤å¤šä½™è£…é¥°(ä¸‰è§’å½¢æŒ‡ç¤ºå™¨)ï¼Œä¼˜åŒ–é—´è·ï¼Œé‡æ„æ»šåŠ¨æ¡
"""

STYLESHEET = """
/* =======================================================
   å…¨å±€åŸºç¡€è®¾å®š
   ======================================================= */
* {
    font-family: "Microsoft YaHei", "Segoe UI", sans-serif;
    font-size: 14px;
    outline: none;
}

QWidget {
    background-color: #2b2b2b;
    color: #e0e0e0;
}

QWidget:disabled {
    color: #6e6e6e;
}

QToolTip {
    background-color: #3f3f3f;
    color: #ffffff;
    border: 1px solid #555555;
    padding: 4px;
    border-radius: 4px;
}

/* =======================================================
   å»é™¤æ‰€æœ‰èœå•æŒ‡ç¤ºå™¨ (æ ¸å¿ƒéœ€æ±‚)
   ======================================================= */
QToolButton::menu-indicator, 
QPushButton::menu-indicator, 
QComboBox::drop-down {
    image: none;
    border: none;
    width: 0px;
    height: 0px;
    padding: 0px;
}

/* =======================================================
   ä¸»çª—å£å®¹å™¨
   ======================================================= */
#MainFrame {
    background-color: #1e1e1e;
    border: 1px solid #454545;
    border-radius: 8px;
}

/* =======================================================
   æ ‡é¢˜æ  (CustomTitleBar)
   ======================================================= */
CustomTitleBar {
    background-color: #252526;
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
    border-bottom: 1px solid #333333;
}

#WindowTitle {
    font-weight: bold;
    font-size: 14px;
    color: #cccccc;
    background-color: transparent;
    padding-left: 5px;
}

#TitleBarSeparator {
    color: #3e3e42;
    background-color: transparent;
}

/* çª—å£æ§åˆ¶æŒ‰é’® - ç§»é™¤å†…è¾¹è·ï¼Œç¡®ä¿å›¾æ ‡å±…ä¸­ */
#WindowControlButton, #WindowCloseButton {
    background-color: transparent;
    border: none;
    border-radius: 4px;
    color: #aaaaaa;
    padding: 0px; /* æ ¸å¿ƒä¿®å¤ï¼šç§»é™¤ä¸åˆç†çš„å†…è¾¹è· */
    margin: 0px;
}
#WindowControlButton:hover { background-color: #3e3e42; color: #ffffff; }
#WindowCloseButton:hover { background-color: #e81123; color: #ffffff; }

/* å·¥å…·æ æŒ‰é’® - ç§»é™¤å†…è¾¹è· */
#ToolBarButton {
    background-color: transparent;
    border: 1px solid transparent;
    border-radius: 4px;
    color: #cccccc;
    padding: 0px; /* æ ¸å¿ƒä¿®å¤ï¼šç§»é™¤å†…è¾¹è· */
    margin: 0px;
}
#ToolBarButton:hover { background-color: #3e3e42; border-color: #555555; }
#ToolBarButton:checked { background-color: #264f78; border-color: #555555; color: #ffffff; }

/* æœç´¢æ¡† */
#ToolbarSearchBar {
    background-color: #3c3c3c;
    border: 1px solid #3c3c3c;
    border-radius: 12px;
    padding: 2px 10px;
    color: #f0f0f0;
    selection-background-color: #264f78;
}
#ToolbarSearchBar:focus {
    border: 1px solid #007fd4;
    background-color: #252526;
}

/* æ˜¾ç¤ºæ¡æ•°æŒ‰é’® - çº¯æ–‡å­—æ¨¡å¼ï¼Œæ— è¾¹æ¡†èƒŒæ™¯ */
#DisplayCountButton {
    background: transparent;
    color: #aaaaaa;
    border: none;
    padding: 4px 8px;
    text-align: center;
}
#DisplayCountButton:hover { 
    color: #ffffff; 
    background-color: #3e3e42;
    border-radius: 4px;
}

/* =======================================================
   æ»šåŠ¨æ¡é‡æ„ (æç®€ç°ä»£é£æ ¼)
   ======================================================= */
/* å‚ç›´æ»šåŠ¨æ¡ */
QScrollBar:vertical {
    border: none;
    background: transparent; /* é€æ˜è½¨é“ */
    width: 6px; /* æç»†å®½åº¦ */
    margin: 0px;
}
QScrollBar::handle:vertical {
    background: #424242; /* æ·±ç°è‰²æ»‘å— */
    min-height: 30px;
    border-radius: 3px; /* åœ†è§’ */
}
QScrollBar::handle:vertical:hover {
    background: #686868; /* æ‚¬åœå˜äº® */
}
QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
    height: 0px; /* ç§»é™¤ä¸Šä¸‹ç®­å¤´æŒ‰é’® */
    background: none;
}
QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical {
    background: none; /* ç‚¹å‡»è½¨é“ä¸è·³è½¬æˆ–æ— èƒŒæ™¯ */
}

/* æ°´å¹³æ»šåŠ¨æ¡ */
QScrollBar:horizontal {
    border: none;
    background: transparent;
    height: 6px;
    margin: 0px;
}
QScrollBar::handle:horizontal {
    background: #424242;
    min-width: 30px;
    border-radius: 3px;
}
QScrollBar::handle:horizontal:hover {
    background: #686868;
}
QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
    width: 0px;
    background: none;
}
QScrollBar::add-page:horizontal, QScrollBar::sub-page:horizontal {
    background: none;
}

/* =======================================================
   Dock é¢æ¿æ¡†æ¶
   ======================================================= */
QMainWindow::separator {
    background-color: #1e1e1e;
    width: 4px;
    height: 4px;
}
QMainWindow::separator:hover {
    background-color: #007fd4;
}

#CustomDockTitleBar {
    background-color: #252526;
    border-bottom: 1px solid #333333;
}
#customDockLabel {
    font-weight: bold;
    font-size: 13px;
    color: #cccccc;
    background: transparent;
}
#customDockMenuButton {
    background: transparent;
    border: none;
    color: #888888;
    padding: 0px;
}
#customDockMenuButton:hover { color: #ffffff; background-color: #3e3e42; border-radius: 3px; }

/* =======================================================
   ä¸»åˆ—è¡¨è¡¨æ ¼
   ======================================================= */
QTableWidget {
    background-color: #1e1e1e;
    gridline-color: transparent;
    border: none;
    selection-background-color: #094771;
    selection-color: #ffffff;
    alternate-background-color: #252526;
}
QTableWidget::item {
    padding: 4px;
    border: none;
}
QTableWidget::item:hover {
    background-color: #2a2d2e;
}
QTableWidget::item:selected {
    background-color: #37373d;
    color: #ffffff;
}

QHeaderView::section {
    background-color: #252526;
    color: #cccccc;
    padding: 5px;
    border: none;
    border-right: 1px solid #333333;
    border-bottom: 1px solid #333333;
    font-weight: bold;
}
QTableCornerButton::section {
    background-color: #252526;
    border: none;
}

/* =======================================================
   å·¦ä¾§æ ‘å½¢åˆ—è¡¨
   ======================================================= */
QTreeWidget {
    background-color: #252526;
    border: none;
}
QTreeWidget::item {
    padding: 6px;
    border-radius: 4px;
    margin-right: 8px;
}
QTreeWidget::item:hover {
    background-color: #2a2d2e;
}
QTreeWidget::item:selected {
    background-color: #37373d;
    color: #ffffff;
}

/* =======================================================
   å…¶ä»–æ§ä»¶
   ======================================================= */
#PreviewBox, #NoteInput, #TagInputWidget QLineEdit {
    background-color: #1e1e1e;
    border: 1px solid #333333;
    border-radius: 4px;
    padding: 6px;
    color: #cccccc;
}
#NoteInput:focus, #TagInputWidget QLineEdit:focus {
    border: 1px solid #007fd4;
    background-color: #000000;
}

#TagInputWidget {
    background-color: #1e1e1e;
    border: 1px solid #333333;
    border-radius: 6px;
}

/* æ ‡ç­¾èƒ¶å›Š */
#TagChip {
    background-color: #3c3c3c;
    border-radius: 4px;
}
#TagCloseButton {
    background: transparent;
    color: #aaaaaa;
    border-radius: 7px;
    font-weight: bold;
    padding: 0; 
    margin: 0;
}
#TagCloseButton:hover {
    background-color: #e81123;
    color: #ffffff;
}

#SectionTitle {
    color: #569cd6;
    font-weight: bold;
    font-size: 13px;
    margin-top: 5px;
}
#PartitionInfoLabel { color: #888888; font-size: 12px; }

#StatusLabel, #PageLabel { color: #888888; background: transparent; }

/* é€šç”¨æŒ‰é’® (åº•éƒ¨æ ç­‰) */
QPushButton {
    background-color: #333333;
    border: 1px solid #454545;
    color: #cccccc;
    border-radius: 4px;
    padding: 4px 10px;
}
QPushButton:hover {
    background-color: #3e3e42;
    border-color: #666666;
}
QPushButton:pressed {
    background-color: #1e1e1e;
}

/* èœå• */
QMenu {
    background-color: #252526;
    border: 1px solid #454545;
    padding: 4px 0px;
}
QMenu::item {
    background: transparent;
    padding: 6px 30px 6px 10px;
    color: #cccccc;
}
QMenu::item:selected {
    background-color: #094771;
    color: #ffffff;
}
QMenu::separator {
    height: 1px;
    background: #454545;
    margin: 4px 0px;
}

/* =======================================================
   æ ‡ç­¾æ‚¬æµ®é¢æ¿
   ======================================================= */
#TagPopupContainer {
    background-color: #252526;
    border-radius: 6px;
    border: 1px solid #454545;
}

#TagPopupHeader {
    color: #888888;
    font-size: 12px;
    padding: 0px 4px;
    background: transparent;
}

#TagPopupButton {
    background-color: transparent;
    border: 1px solid #454545;
    color: #cccccc;
    border-radius: 12px;
    padding: 4px 10px;
    text-align: left;
}
#TagPopupButton:hover {
    background-color: #3e3e42;
}

#TagPopupButton[selected="true"] {
    background-color: #094771;
    border-color: #007fd4;
    color: #ffffff;
}

#TagCreateButton {
    background-color: transparent;
    border: none;
    color: #569cd6;
    padding: 8px 4px;
    text-align: left;
    border-radius: 4px;
}
#TagCreateButton:hover {
    background-color: #3e3e42;
}

#TagPopupTip {
    font-size: 11px;
    color: #666666;
    background: transparent;
    padding: 2px 4px;
}
"""
```

## æ–‡ä»¶: themes\light.py

```python
# -*- coding: utf-8 -*-
"""
æµ…è‰²ä¸»é¢˜æ ·å¼è¡¨
"""

STYLESHEET = """
/* =======================================================
   å…¨å±€åŸºç¡€è®¾å®š
   ======================================================= */
* {
    font-family: "Microsoft YaHei", "Segoe UI", sans-serif;
    font-size: 14px;
    outline: none;
}

QWidget {
    background-color: #ffffff;
    color: #333333;
}

/* =======================================================
   ä¸»çª—å£å®¹å™¨
   ======================================================= */
#MainFrame {
    background-color: #f3f3f3;
    border: 1px solid #cccccc;
    border-radius: 8px;
}

/* =======================================================
   æ ‡é¢˜æ 
   ======================================================= */
CustomTitleBar {
    background-color: #ffffff;
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
    border-bottom: 1px solid #e0e0e0;
}

#WindowTitle {
    font-weight: bold;
    font-size: 14px;
    color: #555555;
    background: transparent;
}

#WindowControlButton, #WindowCloseButton {
    background: transparent;
    color: #666666;
}
#WindowControlButton:hover { background-color: #e5e5e5; color: #000000; }
#WindowCloseButton:hover { background-color: #e81123; color: white; }

#ToolbarSearchBar {
    background-color: #f0f0f0;
    border: 1px solid #e0e0e0;
    border-radius: 12px;
    color: #333333;
}
#ToolbarSearchBar:focus {
    background-color: #ffffff;
    border: 1px solid #0078d4;
}

#ToolBarButton {
    background: transparent;
    color: #666666;
    border: 1px solid transparent;
}
#ToolBarButton:hover { background-color: #f0f0f0; }
#ToolBarButton:checked { background-color: #e6f7ff; color: #0078d4; border: 1px solid #1890ff; }

/* =======================================================
   Dock é¢æ¿
   ======================================================= */
#CustomDockTitleBar {
    background-color: #f9f9f9;
    border-bottom: 1px solid #e0e0e0;
}
#customDockLabel {
    color: #333333;
    font-weight: bold;
}
#customDockMenuButton {
    background: transparent;
    color: #666666;
}
#customDockMenuButton:hover { background-color: #e5e5e5; }

QMainWindow::separator {
    background-color: #e0e0e0;
}

/* =======================================================
   åˆ—è¡¨/è¡¨æ ¼/æ ‘
   ======================================================= */
QTableWidget, QTreeWidget {
    background-color: #ffffff;
    border: none;
    alternate-background-color: #fcfcfc;
}

QTableWidget::item:hover, QTreeWidget::item:hover {
    background-color: #f0f0f0;
}

QTableWidget::item:selected, QTreeWidget::item:selected {
    background-color: #e6f7ff;
    color: #000000;
}

QHeaderView::section {
    background-color: #f9f9f9;
    color: #555555;
    border: none;
    border-right: 1px solid #e0e0e0;
    border-bottom: 1px solid #e0e0e0;
}

/* =======================================================
   è¾“å…¥æ§ä»¶ & è¯¦æƒ…
   ======================================================= */
#NoteInput, #PreviewBox, #TagInputWidget QLineEdit {
    background-color: #ffffff;
    border: 1px solid #d9d9d9;
    color: #333333;
}
#NoteInput:focus, #PreviewBox:focus, #TagInputWidget QLineEdit:focus {
    border: 1px solid #0078d4;
}

#TagInputWidget {
    background-color: #ffffff;
    border: 1px solid #d9d9d9;
    border-radius: 6px;
}
#TagInputWidget:focus-within {
    border: 1px solid #0078d4;
}

/* Tag Chips */
#ChipsContainer QFrame {
    background-color: #e6e6e6;
    border: 1px solid #cccccc;
    border-radius: 12px;
    color: #333333;
}
#TagCloseButton {
    color: #666666;
}
#TagCloseButton:hover {
    color: #ff0000;
}

#SectionTitle { color: #0078d4; font-weight: bold; }
#PartitionInfoLabel { color: #888888; }

/* =======================================================
   æ ‡ç­¾å¼¹çª— (TagPopup)
   ======================================================= */
#TagPopupContainer {
    background-color: #ffffff;
    border: 1px solid #cccccc;
    border-radius: 6px;
}
#TagPopupHeader { color: #888888; border-bottom: 1px solid #eeeeee; }

#TagPopupButton {
    background-color: #f5f5f5;
    border: 1px solid #eeeeee;
    color: #333333;
}
#TagPopupButton:hover {
    background-color: #e6f7ff;
    border: 1px solid #1890ff;
}
#TagPopupButton:checked {
    background-color: #1890ff;
    color: #ffffff;
}

#TagCreateButton {
    background-color: #f0f9ff;
    color: #1890ff;
    border: 1px dashed #1890ff;
}
#TagCreateButton:hover {
    background-color: #1890ff;
    color: white;
}

/* =======================================================
   å…¶ä»–
   ======================================================= */
QPushButton {
    background-color: #ffffff;
    border: 1px solid #d9d9d9;
    color: #333333;
    border-radius: 4px;
}
QPushButton:hover {
    background-color: #f5f5f5;
    border-color: #0078d4;
}

QScrollBar:vertical, QScrollBar:horizontal {
    background: #f3f3f3;
}
QScrollBar::handle {
    background: #c1c1c1;
    border-radius: 4px;
}
QScrollBar::handle:hover {
    background: #a8a8a8;
}

QMenu {
    background-color: #ffffff;
    border: 1px solid #cccccc;
}
QMenu::item:selected {
    background-color: #e6f7ff;
    color: #000000;
}
"""
```

## æ–‡ä»¶: themes\__init__.py

```python

```

## æ–‡ä»¶: ui\ball.py

```python
# -*- coding: utf-8 -*-
# ui/ball.py
import math
import random
from PyQt5.QtWidgets import QWidget, QMenu
from PyQt5.QtCore import Qt, pyqtSignal, QPoint, QTimer, QRectF, QPointF
from PyQt5.QtGui import (QPainter, QColor, QPen, QBrush, 
                         QLinearGradient, QPainterPath, QPolygonF)
from core.settings import save_setting

class FloatingBall(QWidget):
    request_show_quick_window = pyqtSignal()
    request_show_main_window = pyqtSignal()
    request_quit_app = pyqtSignal()
    double_clicked = pyqtSignal()

    # --- çš®è‚¤æšä¸¾ ---
    SKIN_MOCHA = 0   
    SKIN_CLASSIC = 1 
    SKIN_ROYAL = 2   
    SKIN_MATCHA = 3  
    SKIN_OPEN = 4    

    def __init__(self, main_window):
        super().__init__()
        self.mw = main_window 
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint | Qt.Tool)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setFixedSize(130, 130) # åŠ å¤§ç”»å¸ƒä»¥å®¹çº³å®Œæ•´çš„ç¬”è¿¹
        self.setAcceptDrops(True)

        self.dragging = False
        self.is_hovering = False 
        
        # --- çŠ¶æ€ä¸é…ç½® ---
        self.current_skin = self.SKIN_MOCHA 
        self.is_writing = False 
        self.write_timer = 0     
        self.offset = QPoint()
        
        # --- åŠ¨ç”»ç‰©ç†é‡ ---
        self.time_step = 0.0
        self.pen_x = 0.0
        self.pen_y = 0.0
        self.pen_angle = -45.0 
        self.book_y = 0.0
        
        # --- å¢¨è¿¹ç³»ç»Ÿ (æ ¸å¿ƒæ–°å¢) ---
        self.trail_points = [] # å­˜å‚¨ç¬”å°–è½¨è¿¹ç‚¹
        self.particles = [] 

        self.timer = QTimer(self)
        self.timer.timeout.connect(self._update_physics)
        self.timer.start(16) # ~60 FPS

    def trigger_clipboard_feedback(self):
        """è§¦å‘è®°å½•æˆåŠŸç‰¹æ•ˆ"""
        self.is_writing = True
        self.write_timer = 0

    def switch_skin(self, skin_id):
        self.current_skin = skin_id
        self.update()

    def _update_physics(self):
        self.time_step += 0.05
        
        # 1. å¾…æœºæ‚¬æµ® (Breathing)
        idle_pen_y = math.sin(self.time_step * 0.5) * 4
        idle_book_y = math.sin(self.time_step * 0.5 - 1.0) * 2
        
        target_pen_angle = -45
        target_pen_x = 0
        target_pen_y = idle_pen_y
        
        # 2. ä¹¦å†™åŠ¨ç”» (Right-hand Scribble)
        if self.is_writing or self.is_hovering:
            self.write_timer += 1
            
            # A. å§¿æ€ï¼šå³æ‰‹æ¡ç¬”é€šå¸¸ç¨å¾®å‘å³å€¾æ–œ (-55åº¦å·¦å³)
            target_pen_angle = -55 
            
            # B. è½¨è¿¹ï¼šæ¨¡æ‹Ÿè¿ç¬”å­— (Signature Wave)
            # é¢‘ç‡åŠ å¿«ï¼Œå¹…åº¦é€‚ä¸­ï¼Œæ¨¡æ‹ŸçœŸå®çš„å¿«é€Ÿä¹¦å†™
            write_speed = self.time_step * 5.0 
            
            # Xè½´ï¼šå·¦å³æ‰«åŠ¨ (åƒå†™ä¸€æ’å­—)
            flow_x = math.sin(write_speed) * 10
            # Yè½´ï¼šä¸Šä¸‹èµ·ä¼ (ç¬”ç”»ç»“æ„) + æ•´ä½“ç¨å¾®ä¸‹å‹
            flow_y = math.cos(write_speed * 2) * 3 
            
            target_pen_x = flow_x
            target_pen_y = 10 + flow_y # ç¬”å°–è´´è¿‘çº¸é¢
            idle_book_y = -3 

            # C. è®°å½•å¢¨è¿¹ç‚¹ (Ink Trail Logic)
            # è®¡ç®—ç¬”å°–åœ¨å…¨å±€åæ ‡ç³»ä¸­çš„ä½ç½®
            # ç¬”çš„ä¸­å¿ƒ(æ—‹è½¬ç‚¹)åœ¨: cx + pen_x, cy + pen_y - 15
            # ç¬”å°–è·ç¦»ä¸­å¿ƒçº¦ä¸º 38px (åŠé•¿ + ç¬”å°–é•¿)
            cx, cy = self.width()/2, self.height()/2
            pivot_x = cx + self.pen_x
            pivot_y = cy + self.pen_y - 15
            
            rad = math.radians(self.pen_angle)
            tip_length = 38 
            
            # æ—‹è½¬å‘é‡å…¬å¼
            tip_x = pivot_x - math.sin(rad) * tip_length
            tip_y = pivot_y + math.cos(rad) * tip_length
            
            # æ·»åŠ è½¨è¿¹ç‚¹ (x, y, opacity)
            self.trail_points.append([tip_x, tip_y, 1.0])

            if self.is_writing and self.write_timer > 90: 
                self.is_writing = False
        
        # 3. ç‰©ç†å¹³æ»‘
        easing = 0.15 # ç¨å¾®åŠ å¿«å“åº”é€Ÿåº¦ï¼Œè®©ä¹¦å†™æ›´è·Ÿæ‰‹
        self.pen_angle += (target_pen_angle - self.pen_angle) * easing
        self.pen_x += (target_pen_x - self.pen_x) * easing
        self.pen_y += (target_pen_y - self.pen_y) * easing
        self.book_y += (idle_book_y - self.book_y) * easing

        # 4. å¢¨è¿¹ä¸ç²’å­æ·¡å‡ºæ›´æ–°
        self._update_trails_and_particles()
        self.update()

    def _update_trails_and_particles(self):
        # A. æ›´æ–°è½¨è¿¹ (Fade out ink)
        alive_trail = []
        for pt in self.trail_points:
            pt[2] -= 0.04 # å¢¨æ°´å¹²å¾—æ¯”è¾ƒå¿«
            if pt[2] > 0:
                alive_trail.append(pt)
        self.trail_points = alive_trail
        
        # B. æ›´æ–°ç²’å­ (Gold Dust / Ink Splatter)
        if (self.is_writing or self.is_hovering) and len(self.particles) < 10:
            if random.random() < 0.2:
                # ä»æœ€æ–°è½¨è¿¹ç‚¹ç”Ÿæˆç²’å­
                if self.trail_points:
                    last_pt = self.trail_points[-1]
                    self.particles.append({
                        'x': last_pt[0],
                        'y': last_pt[1],
                        'vx': random.uniform(-0.5, 0.5),
                        'vy': random.uniform(-0.5, 0.5),
                        'life': 1.0,
                        'size': random.uniform(1, 2)
                    })

        alive_particles = []
        for p in self.particles:
            p['x'] += p['vx']
            p['y'] += p['vy']
            p['life'] -= 0.05
            if p['life'] > 0:
                alive_particles.append(p)
        self.particles = alive_particles

    def paintEvent(self, e):
        p = QPainter(self)
        p.setRenderHint(QPainter.Antialiasing)
        
        w, h = self.width(), self.height()
        cx, cy = w / 2, h / 2
        
        # --- 1. ç»˜åˆ¶é˜´å½± ---
        p.save()
        p.translate(cx, cy + self.book_y + 18)
        p.setPen(Qt.NoPen)
        p.setBrush(QColor(0, 0, 0, 40))
        p.drawEllipse(QRectF(-35, -10, 70, 20))
        p.restore()

        # --- 2. ç»˜åˆ¶ç¬”è®°æœ¬ ---
        p.save()
        p.translate(cx, cy + self.book_y)
        if self.current_skin != self.SKIN_OPEN:
            p.rotate(-6)
            
        if self.current_skin == self.SKIN_MOCHA: self._draw_book_mocha(p)
        elif self.current_skin == self.SKIN_CLASSIC: self._draw_book_classic(p)
        elif self.current_skin == self.SKIN_ROYAL: self._draw_book_royal(p)
        elif self.current_skin == self.SKIN_MATCHA: self._draw_book_matcha(p)
        elif self.current_skin == self.SKIN_OPEN: self._draw_book_open(p)
        
        # === 3. ç»˜åˆ¶å¢¨æ°´è½¨è¿¹ (Ink Trail) - åœ¨ä¹¦æœ¬ä¹‹ä¸Šï¼Œç¬”ä¹‹ä¸‹ ===
        # æ ¹æ®çš®è‚¤é€‰æ‹©å¢¨æ°´é¢œè‰²
        ink_color = QColor(20, 20, 30) # é»˜è®¤é»‘å¢¨æ°´
        if self.current_skin == self.SKIN_ROYAL: ink_color = QColor(25, 25, 112) # è“å¢¨æ°´
        elif self.current_skin == self.SKIN_MOCHA: ink_color = QColor(60, 30, 20) # è¤å¢¨æ°´
        
        if len(self.trail_points) > 1:
            path = QPainterPath()
            path.moveTo(QPointF(self.trail_points[0][0], self.trail_points[0][1]))
            # ä½¿ç”¨äºŒæ¬¡è´å¡å°”æ›²çº¿è¿æ¥ç‚¹ï¼Œä½¿çº¿æ¡å¹³æ»‘
            for i in range(1, len(self.trail_points) - 1):
                # å–ä¸­ç‚¹ä½œä¸ºæ§åˆ¶ç‚¹
                p1 = self.trail_points[i]
                p2 = self.trail_points[i+1]
                mid_x = (p1[0] + p2[0]) / 2
                mid_y = (p1[1] + p2[1]) / 2
                path.quadTo(p1[0], p1[1], mid_x, mid_y)
            
            # ç»˜åˆ¶ä¸åŒé€æ˜åº¦çš„è½¨è¿¹ (æ¨¡æ‹Ÿæ¸éš)
            # è¿™é‡Œä¸ºäº†æ€§èƒ½å’Œæ•ˆæœï¼Œæˆ‘ä»¬ç®€å•ç»˜åˆ¶ä¸€æ¡è·¯å¾„ï¼Œé€æ˜åº¦å–ä¸­é—´å€¼
            # æ›´å®Œç¾çš„æ–¹æ³•æ˜¯åˆ†æ®µç»˜åˆ¶ï¼Œä½†å¯¹äºå°å›¾æ ‡ï¼Œä¸€æ¡åŠé€æ˜çº¿è¶³çŸ£
            pen_ink = QPen(ink_color)
            pen_ink.setWidthF(1.8)
            pen_ink.setCapStyle(Qt.RoundCap)
            # æ•´ä½“é€æ˜åº¦éšæœ€æ—©çš„ç‚¹è¡°å‡
            opacity = int(255 * 0.8) 
            if self.trail_points:
                opacity = int(255 * max(0.2, self.trail_points[0][2]))
            
            ink_color.setAlpha(opacity)
            pen_ink.setColor(ink_color)
            
            # åæ ‡ç³»å·²ç»åœ¨translate(cx, cy+book_y)é‡Œäº†? 
            # ä¸ï¼Œtrail_points è®°å½•çš„æ˜¯å…¨å±€åæ ‡ã€‚
            # æˆ‘ä»¬éœ€è¦ä¸´æ—¶æ¢å¤åæ ‡ç³»æ¥ç”»çº¿ï¼Œæˆ–è€…é€†å˜æ¢ã€‚
            # ç®€å•åšæ³•ï¼šrestoreååœ¨ç”»ç¬”å‰ç”»çº¿ã€‚
            p.restore() # æ¢å¤åˆ° (0,0)
            
            p.setPen(pen_ink)
            p.setBrush(Qt.NoBrush)
            p.drawPath(path)
        else:
            p.restore() # æ²¡è½¨è¿¹ä¹Ÿè¦æ¢å¤

        # --- 4. ç»˜åˆ¶ç¬”çš„æŠ•å½± ---
        p.save()
        # æŠ•å½±åœ¨çº¸ä¸Šï¼Œè·Ÿéšç¬”çš„XYï¼Œä½†ç¨å¾®æ»å
        p.translate(cx + self.pen_x + 6, cy + self.book_y - 2 + self.pen_y * 0.6) 
        p.rotate(self.pen_angle)
        p.setPen(Qt.NoPen)
        p.setBrush(QColor(40, 30, 20, 50)) 
        p.drawRoundedRect(QRectF(-4, -15, 8, 40), 4, 4)
        p.restore()

        # --- 5. ç»˜åˆ¶é’¢ç¬” ---
        p.save()
        # ç¬”çš„æ—‹è½¬ä¸­å¿ƒ
        p.translate(cx + self.pen_x, cy + self.pen_y - 15)
        p.rotate(self.pen_angle)
        self._draw_universal_pen(p)
        p.restore()
        
        # --- 6. ç»˜åˆ¶ç²’å­ ---
        for pt in self.particles:
            c = QColor(255, 215, 0, int(255 * pt['life'])) # é‡‘ç²‰
            p.setPen(Qt.NoPen)
            p.setBrush(c)
            p.drawEllipse(QRectF(pt['x']-pt['size']/2, pt['y']-pt['size']/2, pt['size'], pt['size']))

    # ... (Drawing Helper Functions remain largely the same, optimized for looks) ...
    def _draw_universal_pen(self, p):
        """ä¸€æ”¯é«˜è´¨æ„Ÿé’¢ç¬”"""
        w_pen, h_pen = 12, 46
        # é¢œè‰²é€‚é…
        if self.current_skin == self.SKIN_ROYAL:
            c1, c2, c3 = QColor(60, 60, 70), QColor(20, 20, 25), QColor(0, 0, 0)
        elif self.current_skin == self.SKIN_MATCHA:
            c1, c2, c3 = QColor(255, 255, 250), QColor(240, 240, 230), QColor(200, 200, 190)
        elif self.current_skin == self.SKIN_CLASSIC:
            c1, c2, c3 = QColor(80, 80, 80), QColor(30, 30, 30), QColor(10, 10, 10)
        else: # Mocha
            c1, c2, c3 = QColor(180, 60, 70), QColor(140, 20, 30), QColor(60, 5, 10)

        body_grad = QLinearGradient(-w_pen/2, 0, w_pen/2, 0)
        body_grad.setColorAt(0.0, c1); body_grad.setColorAt(0.5, c2); body_grad.setColorAt(1.0, c3) 

        path_body = QPainterPath()
        path_body.addRoundedRect(QRectF(-w_pen/2, -h_pen/2, w_pen, h_pen), 5, 5)
        p.setPen(Qt.NoPen); p.setBrush(body_grad); p.drawPath(path_body)
        
        # ç¬”å°–
        path_tip = QPainterPath()
        tip_h = 14
        path_tip.moveTo(-w_pen/2 + 3, h_pen/2); path_tip.lineTo(w_pen/2 - 3, h_pen/2); path_tip.lineTo(0, h_pen/2 + tip_h); path_tip.closeSubpath()
        tip_grad = QLinearGradient(-5, 0, 5, 0)
        tip_grad.setColorAt(0, QColor(240, 230, 180)); tip_grad.setColorAt(1, QColor(190, 170, 100)) 
        p.setBrush(tip_grad); p.drawPath(path_tip)
        
        # ç»†èŠ‚
        p.setBrush(QColor(220, 200, 140)); p.drawRect(QRectF(-w_pen/2, h_pen/2 - 4, w_pen, 4))
        p.setBrush(QColor(210, 190, 130)); p.drawRoundedRect(QRectF(-1.5, -h_pen/2 + 6, 3, 24), 1.5, 1.5)

    def _draw_book_mocha(self, p):
        w, h = 56, 76
        p.setBrush(QColor(245, 240, 225)); p.drawRoundedRect(QRectF(-w/2+6, -h/2+6, w, h), 3, 3)
        grad = QLinearGradient(-w, -h, w, h)
        grad.setColorAt(0, QColor(90, 60, 50)); grad.setColorAt(1, QColor(50, 30, 25))
        p.setBrush(grad); p.drawRoundedRect(QRectF(-w/2, -h/2, w, h), 3, 3)
        p.setBrush(QColor(120, 20, 30)); p.drawRect(QRectF(w/2 - 15, -h/2, 8, h))

    def _draw_book_classic(self, p):
        w, h = 54, 74
        p.setBrush(QColor(235, 235, 230)); p.drawRoundedRect(QRectF(-w/2+6, -h/2+6, w, h), 3, 3)
        grad = QLinearGradient(-w, -h, w, h)
        grad.setColorAt(0, QColor(60, 60, 65)); grad.setColorAt(1, QColor(20, 20, 25))
        p.setBrush(grad); p.drawRoundedRect(QRectF(-w/2, -h/2, w, h), 3, 3)
        p.setBrush(QColor(10, 10, 10, 200)); p.drawRect(QRectF(w/2 - 12, -h/2, 6, h))

    def _draw_book_royal(self, p):
        w, h = 58, 76
        p.setBrush(QColor(240, 240, 235)); p.drawRoundedRect(QRectF(-w/2+6, -h/2+6, w, h), 2, 2)
        grad = QLinearGradient(-w, -h, w, 0)
        grad.setColorAt(0, QColor(40, 40, 100)); grad.setColorAt(1, QColor(10, 10, 50))
        p.setBrush(grad); p.drawRoundedRect(QRectF(-w/2, -h/2, w, h), 2, 2)
        p.setBrush(QColor(218, 165, 32)); c=12; p.drawPolygon(QPolygonF([QPoint(int(w/2), int(-h/2)), QPoint(int(w/2-c), int(-h/2)), QPoint(int(w/2), int(-h/2+c))]))

    def _draw_book_matcha(self, p):
        w, h = 54, 74
        p.setBrush(QColor(250, 250, 245)); p.drawRoundedRect(QRectF(-w/2+5, -h/2+5, w, h), 3, 3)
        grad = QLinearGradient(-w, -h, w, h)
        grad.setColorAt(0, QColor(160, 190, 150)); grad.setColorAt(1, QColor(100, 130, 90))
        p.setBrush(grad); p.drawRoundedRect(QRectF(-w/2, -h/2, w, h), 3, 3)
        p.setBrush(QColor(255, 255, 255, 200)); p.drawRoundedRect(QRectF(-w/2+10, -20, 34, 15), 2, 2)

    def _draw_book_open(self, p):
        w, h = 80, 50
        p.rotate(-5)
        path = QPainterPath(); path.moveTo(-w/2, -h/2); path.lineTo(0, -h/2 + 4); path.lineTo(w/2, -h/2); path.lineTo(w/2, h/2); path.lineTo(0, h/2 + 4); path.lineTo(-w/2, h/2); path.closeSubpath()
        p.setBrush(QColor(248, 248, 245)); p.setPen(Qt.NoPen); p.drawPath(path)
        grad = QLinearGradient(-10, 0, 10, 0); grad.setColorAt(0, QColor(0,0,0,0)); grad.setColorAt(0.5, QColor(0,0,0,20)); grad.setColorAt(1, QColor(0,0,0,0))
        p.setBrush(grad); p.drawRect(QRectF(-5, -h/2+4, 10, h-4))
        p.setPen(QPen(QColor(200, 200, 200), 1))
        for y in range(int(-h/2)+15, int(h/2), 7):
            p.drawLine(int(-w/2+5), y, -5, y+2); p.drawLine(5, y+2, int(w/2-5), y)

    # --- äº¤äº’ ---
    def dragEnterEvent(self, e):
        if e.mimeData().hasText(): e.accept(); self.is_hovering = True
        else: e.ignore()
    def dragLeaveEvent(self, e): self.is_hovering = False
    def dropEvent(self, e):
        self.is_hovering = False
        text = e.mimeData().text()
        if text.strip(): self.mw.quick_add_idea(text); self.trigger_clipboard_feedback(); e.acceptProposedAction()
    def mousePressEvent(self, e):
        if e.button() == Qt.LeftButton: self.dragging = True; self.offset = e.pos(); self.pen_y += 3
    def mouseMoveEvent(self, e):
        if self.dragging: self.move(self.mapToGlobal(e.pos() - self.offset))
    def mouseReleaseEvent(self, e):
        if self.dragging: self.dragging = False; pos = self.pos(); save_setting('floating_ball_pos', {'x': pos.x(), 'y': pos.y()})
    def mouseDoubleClickEvent(self, e):
        if e.button() == Qt.LeftButton: self.double_clicked.emit()
    def contextMenuEvent(self, e):
        m = QMenu(self)
        m.setStyleSheet("QMenu { background-color: #2b2b2b; color: #f0f0f0; border: 1px solid #444; border-radius: 5px; } QMenu::item { padding: 6px 25px; } QMenu::item:selected { background-color: #5D4037; color: #fff; } QMenu::separator { background-color: #444; height: 1px; margin: 4px 0; }")
        sm = m.addMenu("ğŸ¨  åˆ‡æ¢å¤–è§‚")
        sm.addAction("â˜•  æ‘©å¡Â·å‹ƒè‰®ç¬¬", lambda: self.switch_skin(self.SKIN_MOCHA))
        sm.addAction("â™Ÿï¸  ç»å…¸é»‘é‡‘", lambda: self.switch_skin(self.SKIN_CLASSIC))
        sm.addAction("ğŸ“˜  çš‡å®¶è“", lambda: self.switch_skin(self.SKIN_ROYAL))
        sm.addAction("ğŸµ  æŠ¹èŒ¶ç»¿", lambda: self.switch_skin(self.SKIN_MATCHA))
        sm.addAction("ğŸ“–  æ‘Šå¼€æ‰‹ç¨¿", lambda: self.switch_skin(self.SKIN_OPEN))
        m.addSeparator()
        m.addAction('ğŸ“  å¿«é€Ÿç¬”è®°', self.request_show_quick_window.emit)
        m.addAction('ğŸ—‚ï¸  æ‰“å¼€ä¸»ç•Œé¢', self.request_show_main_window.emit)
        m.addAction('âœ¨  æ–°å»ºçµæ„Ÿ', self.mw.new_idea)
        m.addSeparator()
        m.addAction('ğŸšª  é€€å‡º', self.request_quit_app.emit)
        m.exec_(e.globalPos())
```

## æ–‡ä»¶: ui\color_selector.py

```python
# color_selector.py

from PyQt5.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel, 
                             QGridLayout, QPushButton, QLineEdit)
from PyQt5.QtGui import QColor
from PyQt5.QtCore import Qt, QSettings

class ColorSelectorDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("é¢œè‰²é€‰æ‹©")
        self.setMinimumSize(400, 500)
        self.setObjectName("ColorSelectorDialog") # è®¾ç½®ObjectName
        self.selected_color = None
        
        self.init_ui()
        self.load_history()
    
    def init_ui(self):
        layout = QVBoxLayout(self)
        layout.setSpacing(15)
        
        layout.addWidget(QLabel("ğŸ¨ æ¨èé¢œè‰²"))
        grid_rec = QGridLayout()
        grid_rec.setSpacing(8)
        
        rec_colors = [
            "#ffadad", "#ffd6a5", "#fdffb6", "#caffbf", "#9bf6ff", "#a0c4ff", "#bdb2ff", "#ffc6ff",
            "#ef476f", "#ffd166", "#06d6a0", "#118ab2", "#073b4c", "#f72585", "#7209b7", "#3a0ca3"
        ]
        
        for i, color in enumerate(rec_colors):
            btn = self.create_color_btn(color)
            grid_rec.addWidget(btn, i // 8, i % 8)
        layout.addLayout(grid_rec)
        
        layout.addWidget(QLabel("ğŸ•’ æœ€è¿‘ä½¿ç”¨"))
        self.grid_history = QGridLayout()
        self.grid_history.setSpacing(8)
        layout.addLayout(self.grid_history)
        
        layout.addWidget(QLabel("âœï¸ è‡ªå®šä¹‰"))
        custom_layout = QHBoxLayout()
        self.hex_input = QLineEdit()
        self.hex_input.setPlaceholderText("#RRGGBB")
        self.hex_input.textChanged.connect(self.update_preview)
        custom_layout.addWidget(self.hex_input)
        
        self.preview_btn = QPushButton()
        self.preview_btn.setFixedSize(36, 36)
        self.preview_btn.setObjectName("ColorPreviewButton")
        custom_layout.addWidget(self.preview_btn)
        
        btn_pick = QPushButton("è°ƒè‰²æ¿")
        btn_pick.setObjectName("ColorPickButton")
        btn_pick.clicked.connect(self.open_color_dialog)
        custom_layout.addWidget(btn_pick)
        
        layout.addLayout(custom_layout)
        
        layout.addStretch()
        
        btn_layout = QHBoxLayout()
        btn_clear = QPushButton("æ¸…é™¤é¢œè‰²")
        btn_clear.setObjectName("ClearColorButton")
        btn_clear.clicked.connect(self.clear_color)
        btn_layout.addWidget(btn_clear)
        
        btn_layout.addStretch()
        
        btn_cancel = QPushButton("å–æ¶ˆ")
        btn_cancel.setObjectName("CancelButton")
        btn_cancel.clicked.connect(self.reject)
        btn_layout.addWidget(btn_cancel)
        
        btn_ok = QPushButton("ç¡®å®š")
        btn_ok.setObjectName("OkButton")
        btn_ok.clicked.connect(self.accept_custom)
        btn_layout.addWidget(btn_ok)
        
        layout.addLayout(btn_layout)
    
    def create_color_btn(self, color):
        btn = QPushButton()
        btn.setFixedSize(32, 32)
        btn.setObjectName("ColorSelectorButton")
        btn.setProperty("color", color)
        btn.setCursor(Qt.PointingHandCursor)
        btn.clicked.connect(lambda: self.select_color(color))
        return btn
    
    def load_history(self):
        settings = QSettings("ClipboardApp", "ColorHistory")
        history = settings.value("colors", [])
        if not history: history = ["#ffffff", "#000000", "#808080"]
        
        for i in reversed(range(self.grid_history.count())): 
            self.grid_history.itemAt(i).widget().setParent(None)
            
        for i, color in enumerate(history[:16]):
            btn = self.create_color_btn(color)
            self.grid_history.addWidget(btn, i // 8, i % 8)
            
    def save_history(self, color):
        settings = QSettings("ClipboardApp", "ColorHistory")
        history = settings.value("colors", [])
        if color in history: history.remove(color)
        history.insert(0, color)
        settings.setValue("colors", history[:16])
    
    def select_color(self, color):
        self.selected_color = color
        self.save_history(color)
        self.accept()
        
    def update_preview(self, text):
        if QColor(text).isValid():
            self.preview_btn.setStyleSheet(f"background-color: {text};") # Keep this dynamic style
            
    def open_color_dialog(self):
        from PyQt5.QtWidgets import QColorDialog
        color = QColorDialog.getColor()
        if color.isValid():
            self.hex_input.setText(color.name())
            self.selected_color = color.name()
            
    def accept_custom(self):
        text = self.hex_input.text()
        if QColor(text).isValid():
            self.select_color(text)
        elif self.selected_color:
            self.select_color(self.selected_color)
        else:
            self.reject()
            
    def clear_color(self):
        self.selected_color = ""
        self.accept()
```

## æ–‡ä»¶: ui\components.py

```python
# -*- coding: utf-8 -*-
from PyQt5.QtWidgets import (QTableWidget, QAbstractItemView, QLineEdit, QWidget,
                             QHBoxLayout, QPushButton, QTreeWidget, QTreeWidgetItem,
                             QFrame, QLabel, QCompleter, QComboBox, QToolButton, QMenu, QStyledItemDelegate, QStyle)
from PyQt5.QtCore import Qt, pyqtSignal, QSettings, QSize, QEvent, QRect, QStringListModel
from PyQt5.QtGui import QColor, QBrush, QIcon, QPen, QFontMetrics
from core.shared import get_color_icon

# === ä¾§è¾¹æ  ===
class FilterTreeWidget(QTreeWidget):
    filterChanged = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setHeaderHidden(True)
        self.setObjectName("FilterTree") # è®¾ç½®ObjectName
        self.itemChanged.connect(lambda: self.filterChanged.emit())
        
        self.roots = {}
        order = [
            ('stars', 'â­ è¯„çº§'),
            ('colors', 'ğŸ¨ é¢œè‰²'),
            ('tags', 'ğŸ·ï¸ æ ‡ç­¾'),
            ('date_create', 'ğŸ“… åˆ›å»ºæ—¥æœŸ'),
            ('date_modify', 'ğŸ“… ä¿®æ”¹æ—¥æœŸ')
        ]
        
        for key, label in order:
            item = QTreeWidgetItem(self)
            item.setText(0, label)
            item.setExpanded(True)
            item.setFlags(item.flags() & ~Qt.ItemIsUserCheckable)
            self.roots[key] = item
            
        self._add_fixed_date_options('date_create')
        self._add_fixed_date_options('date_modify')

    def _add_fixed_date_options(self, key):
        root = self.roots[key]
        options = ["ä»Šæ—¥", "æ˜¨æ—¥", "å‘¨å†…", "ä¸¤å‘¨", "æœ¬æœˆ", "ä¸Šæœˆ", "è‡ªå®šä¹‰"]
        for opt in options:
            child = QTreeWidgetItem(root)
            child.setText(0, opt)
            child.setData(0, Qt.UserRole, opt)
            child.setCheckState(0, Qt.Unchecked)

    def update_stats(self, stats):
        self.blockSignals(True)
        
        star_data = []
        for i in range(5, 0, -1):
            label = "â˜…" * i
            count = stats['stars'].get(i, 0)
            star_data.append((i, label, count))
        
        if 0 in stats['stars']:
            star_data.append((0, "æ— ", stats['stars'][0]))

        self._refresh('stars', star_data)
        self._refresh('colors', [(c, c.upper(), count) for c, count in stats['colors'].items()], is_col=True)
        self._refresh('tags', stats.get('tags', []), is_tag=True)
        self.blockSignals(False)

    def _refresh(self, key, data, is_tag=False, is_col=False):
        root = self.roots[key]
        checked = {root.child(i).data(0, Qt.UserRole) for i in range(root.childCount()) if root.child(i).checkState(0) == Qt.Checked}
        root.takeChildren()
        
        if not data:
            empty = QTreeWidgetItem(root)
            empty.setText(0, "æš‚æ— ")
            empty.setFlags(Qt.NoItemFlags)
            return

        for v, l, c in data:
            if is_tag: v, l, c = v, v, l
            if c == 0 and v not in checked: continue
            child = QTreeWidgetItem(root); child.setText(0, f"{l} ({c})"); child.setData(0, Qt.UserRole, v)
            child.setCheckState(0, Qt.Checked if v in checked else Qt.Unchecked)
            if is_col: child.setIcon(0, get_color_icon(v))

    def get_checked(self, key):
        root = self.roots[key]
        return [root.child(i).data(0, Qt.UserRole) for i in range(root.childCount()) if root.child(i).checkState(0) == Qt.Checked]

# === è¡¨æ ¼ ===
class DraggableTable(QTableWidget):
    reorder_signal = pyqtSignal(list)
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setDragEnabled(True); self.setAcceptDrops(True); self.setDragDropMode(QAbstractItemView.InternalMove)
        self.setSelectionBehavior(QAbstractItemView.SelectRows); self.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.setShowGrid(False); self.setAlternatingRowColors(True)

    def dropEvent(self, event):
        if event.source() != self: super().dropEvent(event); return
        super().dropEvent(event)
        new_ids = []
        for r in range(self.rowCount()):
            item = self.item(r, 9)
            if item: new_ids.append(int(item.text()))
        self.reorder_signal.emit(new_ids)

# === æœç´¢æ¡† ===

class HistoryCompleterDelegate(QStyledItemDelegate):
    """è‡ªå®šä¹‰å§”æ‰˜ï¼Œç”¨äºåœ¨æœç´¢å†å²è®°å½•çš„æœ«å°¾ç»˜åˆ¶ä¸€ä¸ªåˆ é™¤æŒ‰é’®ã€‚"""
    delete_triggered = pyqtSignal(str)

    def paint(self, painter, option, index):
        # é¦–å…ˆè°ƒç”¨çˆ¶ç±»çš„paintæ–¹æ³•ï¼Œç»˜åˆ¶èƒŒæ™¯ã€æ–‡æœ¬ç­‰åŸºæœ¬å…ƒç´ 
        super().paint(painter, option, index)

        # è·å–åˆ é™¤æŒ‰é’®çš„çŸ©å½¢åŒºåŸŸ
        delete_button_rect = self.get_delete_button_rect(option)

        painter.save()

        # å¦‚æœé¼ æ ‡æ‚¬åœåœ¨è¯¥é¡¹ä¸Šï¼Œåˆ™é«˜äº®åˆ é™¤æŒ‰é’®
        if option.state & QStyle.State_MouseOver:
            pen = QPen(QColor("#d0d0d0"))  # æ‚¬åœæ—¶ä½¿ç”¨æ›´äº®çš„ç°è‰²
        else:
            pen = QPen(QColor("#a0a0a0"))  # é»˜è®¤ä½¿ç”¨æš—ç°è‰²

        painter.setPen(pen)

        # è®¾ç½®å­—ä½“ä»¥ç»˜åˆ¶ "Ã—"
        font = painter.font()
        font.setBold(True)
        painter.setFont(font)

        # åœ¨è®¡ç®—å¥½çš„çŸ©å½¢åŒºåŸŸå†…å±…ä¸­ç»˜åˆ¶ "Ã—"
        painter.drawText(delete_button_rect, Qt.AlignCenter, "Ã—")
        painter.restore()

    def editorEvent(self, event, model, option, index):
        # ä»…åœ¨é¼ æ ‡é‡Šæ”¾äº‹ä»¶æ—¶å“åº”
        if event.type() == QEvent.MouseButtonRelease:
            # æ£€æŸ¥ç‚¹å‡»ä½ç½®æ˜¯å¦åœ¨åˆ é™¤æŒ‰é’®çš„çŸ©å½¢åŒºåŸŸå†…
            if self.get_delete_button_rect(option).contains(event.pos()):
                # å‘å°„ä¿¡å·ï¼Œé€šçŸ¥SearchBaråˆ é™¤æ­¤é¡¹
                self.delete_triggered.emit(index.data())
                return True  # è¿”å›Trueè¡¨ç¤ºäº‹ä»¶å·²è¢«å¤„ç†
        return super().editorEvent(event, model, option, index)

    def get_delete_button_rect(self, option):
        """è®¡ç®—å¹¶è¿”å›åˆ é™¤æŒ‰é’® "Ã—" çš„çŸ©å½¢åŒºåŸŸã€‚"""
        rect = option.rect
        # æŒ‰é’®ä½äºæœ€å³ä¾§ï¼Œå®½åº¦ä¸º20px
        delete_button_rect = QRect(rect.right() - 20, rect.top(), 20, rect.height())
        return delete_button_rect

class SearchBar(QLineEdit):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setPlaceholderText("ğŸ” æœç´¢å†…å®¹...")
        self.settings = QSettings("ClipboardPro", "SearchHistory")
        self.history = self.settings.value("history", [], type=list)

        # ä½¿ç”¨ QStringListModel æ¥ç®¡ç†å†å²è®°å½•
        self.model = QStringListModel(self.history)
        
        self.completer = QCompleter(self.model, self)
        self.completer.setCaseSensitivity(Qt.CaseInsensitive)
        
        # å®ä¾‹åŒ–å¹¶åº”ç”¨è‡ªå®šä¹‰å§”æ‰˜
        self.delegate = HistoryCompleterDelegate(self)
        self.completer.popup().setItemDelegate(self.delegate)

        self.setCompleter(self.completer)
        self.returnPressed.connect(self._save)

        # è¿æ¥å§”æ‰˜çš„åˆ é™¤ä¿¡å·åˆ°åˆ é™¤æ§½å‡½æ•°
        self.delegate.delete_triggered.connect(self.delete_history_item)
        
        self.clearBtn = QPushButton("Ã—", self)
        self.clearBtn.setCursor(Qt.PointingHandCursor)
        self.clearBtn.setFixedSize(20, 20)
        self.clearBtn.setObjectName("SearchBarClearButton") # è®¾ç½®ObjectName
        self.clearBtn.clicked.connect(self.clear)
        self.clearBtn.hide()
        self.textChanged.connect(self._on_text_changed)
        
        # ä¸ºè¾“å…¥æ¡†è®¾ç½®å³è¾¹è·ï¼Œé˜²æ­¢æ–‡æœ¬ä¸æ¸…é™¤æŒ‰é’®é‡å 
        # æŒ‰é’®å®½åº¦ä¸º20px, ä¸è¾¹æ¡†çš„è·ç¦»ä¸º11px, å†é¢å¤–åŠ 4pxçš„æ–‡æœ¬é—´è·
        self.setTextMargins(0, 0, 20 + 11 + 4, 0)

    def _on_text_changed(self, text):
        self.clearBtn.setVisible(bool(text))

    def resizeEvent(self, event):
        button_size = self.clearBtn.sizeHint()
        frame_rect = self.rect()
        # å°†æŒ‰é’®æ”¾ç½®åœ¨æœ€å³ä¾§ï¼Œå¹¶ä¿ç•™11pxçš„è¾¹è· (4pxåŸè¾¹è· + 7pxå·¦ç§»)
        x_pos = frame_rect.right() - button_size.width() - 11
        # å‚ç›´å±…ä¸­
        y_pos = (frame_rect.height() - button_size.height()) // 2
        self.clearBtn.move(x_pos, y_pos)
        super().resizeEvent(event)

    def delete_history_item(self, text):
        """ä»å†å²è®°å½•ä¸­åˆ é™¤æŒ‡å®šçš„é¡¹ã€‚"""
        if text in self.history:
            self.history.remove(text)
            self.settings.setValue("history", self.history)
            # æ›´æ–°æ¨¡å‹ä»¥åˆ·æ–°è§†å›¾
            self.model.setStringList(self.history)

    def _save(self):
        """ä¿å­˜æ–°çš„æœç´¢è®°å½•ã€‚"""
        t = self.text().strip()
        if t and t not in self.history:
            self.history.insert(0, t)
            self.history = self.history[:20]  # é™åˆ¶å†å²è®°å½•æ•°é‡
            self.settings.setValue("history", self.history)
            # æ›´æ–°æ¨¡å‹ä»¥åˆ·æ–°è§†å›¾
            self.model.setStringList(self.history)

# === æ ‡é¢˜æ  ===
class CustomTitleBar(QWidget):
    refresh_clicked = pyqtSignal()
    theme_clicked = pyqtSignal()
    search_changed = pyqtSignal()
    clean_clicked = pyqtSignal()
    color_clicked = pyqtSignal()
    pin_clicked = pyqtSignal(bool)
    mode_clicked = pyqtSignal(bool)
    display_count_changed = pyqtSignal(int)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedHeight(36)
        self.setAttribute(Qt.WA_StyledBackground, True)
        
        layout = QHBoxLayout(self)
        layout.setContentsMargins(15, 0, 0, 0)
        layout.setSpacing(6)
        
        title = QLabel("ğŸ’¾ å°è±¡è®°å¿†")
        title.setObjectName("WindowTitle") # è®¾ç½®ObjectName
        layout.addWidget(title)
        
        layout.addSpacing(20) # å¢åŠ  20px çš„å³åç§»
        
        self.search_bar = SearchBar()
        self.search_bar.setObjectName("ToolbarSearchBar") # ä¸ºæœç´¢æ¡†è®¾ç½®å¯¹è±¡åï¼Œä»¥ä¾¿å•ç‹¬æ§åˆ¶é«˜åº¦
        self.search_bar.setFixedWidth(220)
        self.search_bar.textChanged.connect(lambda: self.search_changed.emit())
        self.search_bar.returnPressed.connect(lambda: self.search_changed.emit())
        layout.addWidget(self.search_bar)
        
        self.btn_display_count = QToolButton()
        self.btn_display_count.setText("æ˜¾ç¤º: 100")
        self.btn_display_count.setPopupMode(QToolButton.InstantPopup)
        self.btn_display_count.setIconSize(QSize(12, 12))
        self.btn_display_count.setObjectName("DisplayCountButton") # è®¾ç½®ObjectName
        
        menu = QMenu(self)
        counts = ["æ˜¾ç¤ºæ¡æ•°", 100, 200, 300, 400, 500, 1000]
        for count in counts:
            action = menu.addAction(str(count))
            action.setData(count if isinstance(count, int) else -1)
        
        menu.triggered.connect(self._on_display_count_changed)
        self.btn_display_count.setMenu(menu)
        layout.addWidget(self.btn_display_count)
        
        layout.addStretch()
        
        self.btn_clean = self._btn("ğŸ—‘ï¸", "æ¸…ç†"); self.btn_clean.setObjectName("ToolBarButton"); self.btn_clean.clicked.connect(self.clean_clicked.emit); layout.addWidget(self.btn_clean)
        self.btn_refresh = self._btn("ğŸ”„", "åˆ·æ–°"); self.btn_refresh.setObjectName("ToolBarButton"); self.btn_refresh.clicked.connect(self.refresh_clicked.emit); layout.addWidget(self.btn_refresh)
        self.btn_color = self._btn("ğŸŒˆ", "è®¾ç½®æ ‡ç­¾é¢œè‰²"); self.btn_color.setObjectName("ToolBarButton"); self.btn_color.clicked.connect(self.color_clicked.emit); layout.addWidget(self.btn_color)
        self.btn_mode = self._btn("ğŸ“", "ç¼–è¾‘æ¨¡å¼", True); self.btn_mode.setObjectName("ToolBarButton"); self.btn_mode.clicked.connect(self.mode_clicked.emit); layout.addWidget(self.btn_mode)
        self.btn_pin = self._btn("ğŸ“Œ", "ç½®é¡¶", True); self.btn_pin.setObjectName("ToolBarButton"); self.btn_pin.clicked.connect(self.pin_clicked.emit); layout.addWidget(self.btn_pin)

        self.btn_settings = QToolButton()
        self.btn_settings.setText("âš™ï¸")
        self.btn_settings.setPopupMode(QToolButton.InstantPopup)
        self.btn_settings.setObjectName("ToolBarButton") # æ¢å¤é€šç”¨IDä»¥ä¿æŒæ ·å¼ç»Ÿä¸€
        self.btn_settings.setProperty("class", "no-arrow") # æ·»åŠ è‡ªå®šä¹‰å±æ€§ç”¨äºç²¾ç¡®æ§åˆ¶
        
        settings_menu = QMenu(self)
        theme_action = settings_menu.addAction("åˆ‡æ¢ä¸»é¢˜")
        theme_action.triggered.connect(self.theme_clicked.emit)
        
        self.reset_layout_action = settings_menu.addAction("æ¢å¤é»˜è®¤å¸ƒå±€")
        
        self.btn_settings.setMenu(settings_menu)
        layout.addWidget(self.btn_settings)
        
        line = QFrame(); line.setFrameShape(QFrame.VLine); line.setFrameShadow(QFrame.Sunken); line.setFixedHeight(20); line.setObjectName("TitleBarSeparator")
        layout.addWidget(line)
        
        self.btn_min = self._win_btn("â€”"); self.btn_min.setObjectName("WindowControlButton"); self.btn_min.clicked.connect(self.window().showMinimized); layout.addWidget(self.btn_min)
        self.btn_max = self._win_btn("â¬œ"); self.btn_max.setObjectName("WindowControlButton"); self.btn_max.clicked.connect(self.toggle_max); layout.addWidget(self.btn_max)
        self.btn_close = self._win_btn("âœ•", True); self.btn_close.setObjectName("WindowCloseButton"); self.btn_close.clicked.connect(self.window().close); layout.addWidget(self.btn_close)

    def _on_display_count_changed(self, action):
        count = action.data()
        self._update_display_count_text(count)
        self.display_count_changed.emit(count)

    def _update_display_count_text(self, count):
        if count == -1:
            self.btn_display_count.setText("æ˜¾ç¤ºæ¡æ•°")
        else:
            self.btn_display_count.setText(f"æ˜¾ç¤º: {count}")

    def set_display_count(self, count):
        self._update_display_count_text(count)
    
    def _btn(self, t, tip, chk=False):
        b = QPushButton(t); b.setToolTip(tip); b.setFixedSize(30, 30)
        if chk:
            b.setCheckable(True)
        return b

    def _win_btn(self, t, cls=False):
        b = QPushButton(t)
        b.setFixedSize(30, 30)
        return b

    def toggle_max(self):
        w = self.window()
        if w.isMaximized(): w.showNormal(); self.btn_max.setText("â¬œ")
        else: w.showMaximized(); self.btn_max.setText("â")
            
    def get_search_text(self): return self.search_bar.text().strip()
```

## æ–‡ä»¶: ui\context_menu.py

```python
# -*- coding: utf-8 -*-
import logging
from PyQt5.QtWidgets import QMenu, QMessageBox
from PyQt5.QtCore import QSettings
from ui.dialogs import ColorDialog
from core.shared import get_color_icon

log = logging.getLogger("ContextMenu")

class ContextMenuHandler:
    def __init__(self, main_window):
        self.mw = main_window
        self.db = main_window.db
        self.table = main_window.table
        log.info("âœ… å³é”®èœå• Handler å°±ç»ª")

    def show_menu(self, pos):
        # 1. åæ ‡è½¬æ¢ä¸æœ‰æ•ˆæ€§æ£€æŸ¥
        global_pos = self.table.mapToGlobal(pos)
        index = self.table.indexAt(pos)
        
        log.info(f"ğŸ–±ï¸ è¡¨æ ¼å³é”®ç‚¹å‡» - å±€éƒ¨åæ ‡:{pos} -> å…¨å±€åæ ‡:{global_pos}")
        
        if not index.isValid():
            log.warning("âŒ ç‚¹å‡»äº†ç©ºç™½åŒºåŸŸï¼Œä¸æ˜¾ç¤ºèœå•")
            return
        
        rows = self.table.selectionModel().selectedRows()
        if not rows:
            log.warning("âŒ æœªé€‰ä¸­ä»»ä½•è¡Œ")
            return
            
        try:
            ids = [int(self.table.item(r.row(), 8).text()) for r in rows]  # IDåˆ—ä»9æ”¹ä¸º8
            log.info(f"âœ… é€‰ä¸­ {len(ids)} ä¸ªæ¡ç›®ï¼ŒID: {ids}")
        except Exception as e:
            log.error(f"âŒ è§£æIDå¤±è´¥: {e}", exc_info=True)
            return

        # 2. æ ¹æ®ä¸Šä¸‹æ–‡æ„å»ºèœå•
        try:
            menu = QMenu()
            
            partition_selection = self.mw.partition_panel.get_current_selection()
            
            if partition_selection and partition_selection.get('type') == 'trash':
                # å›æ”¶ç«™èœå•
                menu.addAction("â™»ï¸ æ¢å¤").triggered.connect(lambda: self.restore_items(ids))
                menu.addSeparator()
                menu.addAction("ğŸ’¥ æ°¸ä¹…åˆ é™¤").triggered.connect(lambda: self.delete_permanently(ids))
            else:
                # å¸¸è§„èœå•
                # æ˜Ÿçº§
                sm = menu.addMenu("â­ è®¾ç½®æ˜Ÿçº§")
                for i in range(6):
                    label = "â˜…" * i if i > 0 else "æ— "
                    sm.addAction(label).triggered.connect(lambda _, l=i, x=ids: self.batch_set_star(x, l))
                
                menu.addSeparator()
                
                # çŠ¶æ€
                menu.addAction(f"â¤ï¸ æ”¶è—/å–æ¶ˆ ({len(ids)})").triggered.connect(lambda: self.batch_toggle(ids, 'is_favorite'))
                menu.addAction(f"ğŸ“Œ ç½®é¡¶/å–æ¶ˆ ({len(ids)})").triggered.connect(lambda: self.batch_toggle(ids, 'is_pinned'))
                menu.addAction(f"ğŸ”’ é”å®š/è§£é” ({len(ids)})").triggered.connect(lambda: self.batch_toggle(ids, 'is_locked'))
                
                menu.addSeparator()
                
                # é¢œè‰²
                cm = menu.addMenu("ğŸ¨ é¢œè‰²æ ‡ç­¾")
                c1 = cm.addMenu("å¸¸ç”¨é¢œè‰²")
                for n, c in [("ç´§æ€¥", "#f38ba8"), ("é‡è¦", "#f9e2af"), ("å®Œæˆ", "#a6e3a1")]:
                    c1.addAction(get_color_icon(c), n).triggered.connect(lambda _, cl=c, x=ids: self.batch_set_color(x, cl))
                
                hists = QSettings("ClipboardPro", "ColorHistory").value("colors", [])
                if hists:
                    c2 = cm.addMenu("å†å²è®°å½•")
                    for c in hists[:5]:
                        c2.addAction(get_color_icon(c), c).triggered.connect(lambda _, cl=c, x=ids: self.batch_set_color(x, cl))
                
                menu.addAction("é€‰æ‹©æ–°é¢œè‰²...").triggered.connect(lambda: self.set_custom_color(ids))
                menu.addAction("æ¸…é™¤é¢œè‰²").triggered.connect(lambda: self.batch_set_color(ids, None))
                
                menu.addSeparator()
                menu.addAction("ğŸ—‘ï¸ ç§»è‡³å›æ”¶ç«™").triggered.connect(lambda: self.move_to_trash(ids))

            log.info("ğŸš€ èœå•æ„å»ºå®Œæˆï¼Œæ­£åœ¨å¼¹å‡º...")
            menu.exec_(global_pos)
            
        except Exception as e:
            log.critical(f"ğŸ”¥ èœå•æ˜¾ç¤ºå´©æºƒ: {e}", exc_info=True)

    # ä¸šåŠ¡é€»è¾‘
    def batch_set_star(self, ids, lvl):
        log.info(f"æ‰§è¡Œ: è®¾ç½®æ˜Ÿçº§ {lvl}")
        for i in ids: self.db.update_item(i, star_level=lvl)
        self.mw.load_data()

    def batch_toggle(self, ids, field):
        log.info(f"æ‰§è¡Œ: åˆ‡æ¢çŠ¶æ€ {field}")
        session = self.db.get_session()
        from data.database import ClipboardItem 
        first = session.query(ClipboardItem).get(ids[0])
        # åŸºäºç¬¬ä¸€ä¸ªå…ƒç´ å–åï¼Œå¦‚æœæ²¡æœ‰åˆ™é»˜è®¤True
        new_val = not getattr(first, field) if first else True
        session.close()
        
        # æ‰¹é‡æ›´æ–°
        for i in ids: self.db.update_item(i, **{field: new_val})
        self.mw.load_data()

    def batch_set_color(self, ids, color):
        log.info(f"æ‰§è¡Œ: è®¾ç½®é¢œè‰² {color}")
        for i in ids: self.db.update_item(i, custom_color=color)
        self.mw.load_data()
        
    def batch_group_smart(self, ids):
        """
        æ™ºèƒ½æˆç»„é€»è¾‘ (Ctrl+G):
        1. æ£€æŸ¥é€‰ä¸­é¡¹ä¸­æ‰€æœ‰ä¸é‡å¤çš„é¢œè‰²ã€‚
        2. å¦‚æœæœ‰å¤šä¸ªé¢œè‰²å†²çª -> å¼¹å‡ºèœå•è®©ç”¨æˆ·é€‰æ‹©åˆå¹¶åˆ°å“ªä¸ªé¢œè‰² (æˆ–éšæœºæ–°è‰²)ã€‚
        3. å¦‚æœåªæœ‰ä¸€ä¸ªé¢œè‰² -> å°è¯•åˆå¹¶åˆ°è¯¥é¢œè‰² (è‹¥å…¨åŒ¹é…åˆ™è§£ç»„)ã€‚
        4. å¦‚æœéƒ½æ— é¢œè‰² -> éšæœºåˆ†é…ä¸€ä¸ªæ–°é¢œè‰²ã€‚
        """
        log.info("æ‰§è¡Œ: æ™ºèƒ½æˆç»„")
        session = self.db.get_session()
        from data.database import ClipboardItem
        items = session.query(ClipboardItem).filter(ClipboardItem.id.in_(ids)).all()
        
        # æ”¶é›†æ‰€æœ‰éç©ºé¢œè‰²
        distinct_colors = set(item.custom_color for item in items if item.custom_color)
        
        apply_color = None
        
        # è«å…°è¿ªè‰²ç³»
        palette = [
            "#ffadad", "#ffd6a5", "#fdffb6", "#caffbf", "#9bf6ff", "#a0c4ff", "#bdb2ff", "#ffc6ff",
            "#f72585", "#b5179e", "#7209b7", "#560bad", "#480ca8", "#3a0ca3", "#3f37c9", "#4361ee",
            "#4895ef", "#4cc9f0", "#f94144", "#f3722c", "#f8961e", "#f9844a", "#f9c74f", "#90be6d",
            "#43aa8b", "#4d908e", "#577590", "#277da1"
        ]
        
        if len(distinct_colors) > 1:
            # åœºæ™¯C: é¢œè‰²å†²çª -> å¼¹å‡ºé€‰æ‹©èœå•
            from PyQt5.QtGui import QCursor
            
            menu = QMenu()
            
            # æ·»åŠ ç°æœ‰é¢œè‰²é€‰é¡¹
            for color in distinct_colors:
                action = menu.addAction(get_color_icon(color), f"åˆå¹¶åˆ°æ­¤é¢œè‰² {color.upper()}")
                action.setData(color)
            
            menu.addSeparator()
            
            # æ·»åŠ éšæœºæ–°è‰²é€‰é¡¹
            import random
            rand_color = random.choice(palette)
            act_random = menu.addAction(get_color_icon(rand_color), "ğŸ¨ ä½¿ç”¨æ–°éšæœºé¢œè‰²")
            act_random.setData(rand_color)
            
            # å¼¹å‡ºèœå•
            selected = menu.exec_(QCursor.pos())
            if selected:
                apply_color = selected.data()
            else:
                # ç”¨æˆ·å–æ¶ˆ
                session.close()
                return

        elif len(distinct_colors) == 1:
            # åœºæ™¯A: åªæœ‰ä¸€ä¸ªä¸»è‰² -> åˆå¹¶æˆ–è§£ç»„
            target_color = list(distinct_colors)[0]
            all_match = all(item.custom_color == target_color for item in items)
            
            if all_match:
                # å…¨éƒ¨å·²æ˜¯è¯¥é¢œè‰² -> å–æ¶ˆ (Toggle Off)
                apply_color = None
                log.info(f"  â†ª å…¨éƒ¨å·²æ˜¯ {target_color} -> å–æ¶ˆåˆ†ç»„")
            else:
                # ç»Ÿä¸€ä¸ºè¯¥é¢œè‰²
                apply_color = target_color
                log.info(f"  â†ª åˆå¹¶åˆ†ç»„è‡³é¢œè‰² -> {target_color}")
        else:
            # åœºæ™¯B: å…¨éƒ¨æ— é¢œè‰² -> æ–°å»ºéšæœºåˆ†ç»„
            import random
            apply_color = random.choice(palette)
            log.info(f"  â†ª æ–°å»ºåˆ†ç»„ -> {apply_color}")
            
        session.close()
        
        # æ‰¹é‡æ›´æ–°
        for i in ids: 
            self.db.update_item(i, custom_color=apply_color, group_color=apply_color)
        self.mw.load_data()

    def set_custom_color(self, ids):
        dlg = ColorDialog(self.mw)
        if dlg.exec_() and dlg.color:
            s = QSettings("ClipboardPro", "ColorHistory")
            h = s.value("colors", [], type=list)
            if dlg.color in h: h.remove(dlg.color)
            h.insert(0, dlg.color)
            s.setValue("colors", h[:10])
            self.batch_set_color(ids, dlg.color)

    def move_to_trash(self, ids):
        if QMessageBox.question(self.mw, "ç¡®è®¤", f"ç§»åŠ¨ {len(ids)} æ¡è®°å½•åˆ°å›æ”¶ç«™?") == QMessageBox.Yes:
            log.info(f"æ‰§è¡Œ: ç§»åŠ¨ {len(ids)} é¡¹åˆ°å›æ”¶ç«™")
            self.db.move_items_to_trash(ids)
            self.mw.load_data()
            self.mw.partition_panel.refresh_partitions()

    def restore_items(self, ids):
        log.info(f"æ‰§è¡Œ: ä»å›æ”¶ç«™æ¢å¤ {len(ids)} é¡¹")
        self.db.restore_items_from_trash(ids)
        self.mw.load_data()
        self.mw.partition_panel.refresh_partitions()

    def delete_permanently(self, ids):
        if QMessageBox.question(self.mw, "è­¦å‘Š", f"å°†æ°¸ä¹…åˆ é™¤ {len(ids)} æ¡è®°å½•ï¼Œæ­¤æ“ä½œä¸å¯æ¢å¤ï¼\nç¡®å®šè¦ç»§ç»­å—?", 
                                QMessageBox.Yes | QMessageBox.No, QMessageBox.No) == QMessageBox.Yes:
            log.info(f"æ‰§è¡Œ: æ°¸ä¹…åˆ é™¤ {len(ids)} é¡¹")
            self.db.delete_items_permanently(ids)
            self.mw.load_data()
            self.mw.partition_panel.refresh_partitions()
```

## æ–‡ä»¶: ui\custom_dock.py

```python
# -*- coding: utf-8 -*-
import logging
from PyQt5.QtWidgets import QWidget, QHBoxLayout, QLabel, QToolButton, QMenu, QAction, QDockWidget, QStylePainter, QStyleOption, QStyle
from PyQt5.QtCore import Qt

# é…ç½®æ—¥å¿—
log = logging.getLogger("CustomDock")

class CustomDockTitleBar(QWidget):
    def __init__(self, title, dock_widget, main_window, parent=None):
        super().__init__(parent)
        self.dock = dock_widget
        self.mw = main_window 
        
        self.setFixedHeight(38) # å¢åŠ é«˜åº¦ï¼Œé¿å…è¢«è§†è§‰æŒ¤å‹
        self.setAttribute(Qt.WA_StyledBackground, True)
        self.setObjectName("CustomDockTitleBar")  # å…³é”®ï¼šè®¾ç½®å¯¹è±¡åä»¥ç¡®ä¿æ ·å¼è¡¨ç”Ÿæ•ˆ
        
        # å…³é”®ä¿®å¤ï¼šè®¾ç½®æ˜¾å¼çš„èƒŒæ™¯è‰²ï¼Œä½œä¸ºæ˜æ˜¾çš„æ‹–æ‹½æ‰‹æŸ„
        layout = QHBoxLayout(self)
        layout.setContentsMargins(10, 6, 5, 6) # å¢åŠ å‚ç›´å†…è¾¹è·
        layout.setSpacing(0)
        
        self.label = QLabel(title)
        self.label.setObjectName("customDockLabel")
        layout.addWidget(self.label)
        
        layout.addStretch()
        
        self.btn_menu = QToolButton()
        self.btn_menu.setObjectName("customDockMenuButton")
        self.btn_menu.setText("â‰¡")
        self.btn_menu.setFixedSize(24, 24)
        self.btn_menu.setCursor(Qt.PointingHandCursor)
        self.btn_menu.setPopupMode(QToolButton.InstantPopup)
        self.btn_menu.clicked.connect(self.show_menu)
        
        layout.addWidget(self.btn_menu)

    def paintEvent(self, event):
        """å¼ºåˆ¶æ¸²æŸ“ QSS èƒŒæ™¯è‰²ï¼Œè§£å†³è‡ªå®šä¹‰ QWidget èƒŒæ™¯ä¸ç”Ÿæ•ˆçš„é—®é¢˜"""
        opt = QStyleOption()
        opt.initFrom(self)
        p = QStylePainter(self)
        p.drawPrimitive(QStyle.PE_Widget, opt)
        super().paintEvent(event)

    def show_menu(self):
        log.info(f"ğŸ” ç‚¹å‡»äº† [{self.label.text()}] çš„èœå•æŒ‰é’®")
        menu = QMenu(self)
        
        # æŸ¥æ‰¾æ‰€æœ‰ Dock
        docks = self.mw.findChildren(QDockWidget)
        log.info(f"ğŸ” æŸ¥æ‰¾åˆ° {len(docks)} ä¸ªé¢æ¿: {[d.windowTitle() for d in docks]}")
        
        if not docks:
            log.warning("âš ï¸ æ²¡æœ‰æ‰¾åˆ°ä»»ä½• Dock é¢æ¿ï¼")
            
        for dock in docks:
            title = dock.windowTitle()
            if not title: continue
            
            action = QAction(title, menu)
            action.setCheckable(True)
            action.setChecked(dock.isVisible())
            # ä½¿ç”¨é—­åŒ…é˜²æ­¢å˜é‡æ±¡æŸ“
            action.triggered.connect(lambda checked, d=dock: self.toggle_dock(d, checked))
            menu.addAction(action)
            
        menu.exec_(self.btn_menu.mapToGlobal(self.btn_menu.rect().bottomLeft()))

    def toggle_dock(self, dock, visible):
        log.info(f"ğŸ”„ åˆ‡æ¢é¢æ¿ [{dock.windowTitle()}] å¯è§æ€§ -> {visible}")
        dock.setVisible(visible)
```

## æ–‡ä»¶: ui\dialogs.py

```python
# -*- coding: utf-8 -*-
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QPushButton, QListWidget, QLineEdit, QColorDialog

class TagDialog(QDialog):
    def __init__(self, db_manager, parent=None):
        super().__init__(parent)
        self.db = db_manager
        self.selected_tag = None
        self.setWindowTitle("æ ‡ç­¾ç®¡ç†")
        self.resize(300, 400)
        layout = QVBoxLayout(self)
        
        self.input = QLineEdit()
        self.input.setPlaceholderText("è¾“å…¥æ–°æ ‡ç­¾...")
        self.input.returnPressed.connect(self.accept_input)
        layout.addWidget(self.input)
        
        self.list = QListWidget()
        self.list.itemClicked.connect(self.item_clicked)
        layout.addWidget(self.list)
        self.refresh_list()
        
    def refresh_list(self):
        self.list.clear()
        tags = self.db.get_stats()['tags']
        for name, count in tags: self.list.addItem(f"{name}")

    def accept_input(self):
        text = self.input.text().strip()
        if text: self.selected_tag = text; self.accept()

    def item_clicked(self, item):
        self.selected_tag = item.text(); self.accept()

class ColorDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.color = None
        self.setWindowTitle("é€‰æ‹©é¢œè‰²")
        layout = QVBoxLayout(self)
        grid = QHBoxLayout()
        for c in ["#f38ba8", "#f9e2af", "#a6e3a1", "#89b4fa", "#cba6f7"]:
            btn = QPushButton()
            btn.setFixedSize(30, 30)
            btn.setObjectName("ColorDialogButton")
            btn.setProperty("color", c) # ä½¿ç”¨setPropertyå­˜å‚¨é¢œè‰²
            btn.clicked.connect(lambda _, col=c: self.done_color(col))
            grid.addWidget(btn)
        layout.addLayout(grid)
        sys_btn = QPushButton("æ›´å¤šé¢œè‰²...")
        sys_btn.clicked.connect(self.pick_sys)
        layout.addWidget(sys_btn)
        
    def done_color(self, c): self.color = c; self.accept()
    def pick_sys(self):
        c = QColorDialog.getColor()
        if c.isValid(): self.color = c.name(); self.accept()
```

## æ–‡ä»¶: ui\dialog_new_idea.py

```python

import sys
from PyQt5.QtWidgets import (
    QApplication, QDialog, QVBoxLayout, QTextEdit,
    QHBoxLayout, QPushButton, QWidget
)
from PyQt5.QtCore import Qt


class NewIdeaDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("æ–°å»ºçµæ„Ÿ")
        self.setMinimumSize(400, 300)

        # Main layout
        main_layout = QVBoxLayout(self)

        # Text edit for multi-line input
        self.text_edit = QTextEdit(self)
        self.text_edit.setPlaceholderText("åœ¨è¿™é‡Œè¾“å…¥ä½ çš„çµæ„Ÿ...")
        main_layout.addWidget(self.text_edit)

        # Button layout
        button_layout = QHBoxLayout()
        button_layout.addStretch() # Push buttons to the right

        # Buttons
        self.cancel_button = QPushButton("å–æ¶ˆ", self)
        self.cancel_button.clicked.connect(self.reject)
        button_layout.addWidget(self.cancel_button)

        self.save_button = QPushButton("ä¿å­˜", self)
        self.save_button.setDefault(True) # Default button (e.g., triggered by Enter)
        self.save_button.clicked.connect(self.accept)
        button_layout.addWidget(self.save_button)

        # Add button layout to main layout
        main_layout.addLayout(button_layout)

    def get_idea_text(self):
        """Returns the text entered in the dialog."""
        return self.text_edit.toPlainText().strip()

# Example usage (for testing)
if __name__ == '__main__':
    app = QApplication(sys.argv)
    dialog = NewIdeaDialog()
    if dialog.exec_(): # Note: exec_() is used in PyQt5
        print("Accepted!")
        print("Idea:", dialog.get_idea_text())
    else:
        print("Rejected!")
    sys.exit(0)
```

## æ–‡ä»¶: ui\dialog_preview.py

```python
# -*- coding: utf-8 -*-
from PyQt5.QtWidgets import (QDialog, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QTextEdit, QFrame, 
                             QSizePolicy, QScrollArea, QPushButton, QGraphicsOpacityEffect, QGraphicsDropShadowEffect)
from PyQt5.QtCore import Qt, QPoint, QTimer, QSize
from PyQt5.QtGui import QPixmap, QCursor, QTransform, QColor

class PreviewDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.Dialog)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        self.resize(1000, 750)
        
        self.current_scale = 1.0
        self.original_pixmap = None
        self.rotation_angle = 0
        self.is_dragging = False
        self.last_mouse_pos = QPoint()
        self.mode = 'image'

        # åˆå§‹åŒ–çª—å£æ‹–åŠ¨æ‰€éœ€çš„å˜é‡
        self.is_window_dragging = False
        self.drag_start_position = QPoint()
        
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(30, 30, 30, 30)
        self.layout.setSpacing(0)
        
        self.container = QFrame()
        self.container.setObjectName("PreviewContainer")
        self.container.setStyleSheet("""
            #PreviewContainer {
                background-color: #2b2b2b;
                border: 1px solid #454545;
                border-radius: 8px;
            }
        """)
        
        # Window Shadow
        window_shadow = QGraphicsDropShadowEffect(self)
        window_shadow.setBlurRadius(50)
        window_shadow.setXOffset(0)
        window_shadow.setYOffset(0)
        window_shadow.setColor(QColor(0, 0, 0, 180))
        self.container.setGraphicsEffect(window_shadow)
        
        self.layout.addWidget(self.container)
        
        self.inner_layout = QVBoxLayout(self.container)
        self.inner_layout.setContentsMargins(2, 2, 2, 2)
        self.inner_layout.setSpacing(0)
        
        self.top_bar = QFrame() 
        self.top_layout = QHBoxLayout(self.top_bar)
        self.top_layout.setContentsMargins(15, 5, 15, 5)
        
        self.lbl_info = QLabel("")
        self.lbl_info.setObjectName("PreviewInfoLabel")
        self.top_layout.addWidget(self.lbl_info)
        self.top_layout.addStretch()
        
        btn_close = QPushButton("Ã—")
        btn_close.setFixedSize(30, 30)
        btn_close.setCursor(Qt.PointingHandCursor)
        btn_close.clicked.connect(self.close)
        btn_close.setObjectName("PreviewDialogCloseButton")
        self.top_layout.addWidget(btn_close)
        
        self.inner_layout.addWidget(self.top_bar)
        
        self.content_area = QFrame()
        self.content_layout = QVBoxLayout(self.content_area)
        self.content_layout.setContentsMargins(0, 0, 0, 0)
        
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(False)
        self.scroll_area.setAlignment(Qt.AlignCenter)
        self.scroll_area.setFrameShape(QFrame.NoFrame)
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        
        # å›¾ç‰‡é¢„è§ˆå®¹å™¨ (ä¸ºäº†å®¹çº³é˜´å½±ï¼Œä¸è¢« ScrollArea æˆªæ–­)
        self.image_container = QWidget()
        self.image_container_layout = QVBoxLayout(self.image_container)
        self.image_container_layout.setContentsMargins(40, 40, 40, 40) # å®½å¤§çš„é˜´å½±å‘¼å¸ç©ºé—´
        self.image_container_layout.setAlignment(Qt.AlignCenter)
        
        self.image_label = QLabel()
        self.image_label.setAlignment(Qt.AlignCenter)
        self.image_label.setObjectName("PreviewImage")
        
        # æ³¨å…¥å¼ºç‰©ç†é˜´å½±
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(30)
        shadow.setXOffset(0)
        shadow.setYOffset(10)
        shadow.setColor(QColor(0, 0, 0, 200))
        self.image_label.setGraphicsEffect(shadow)
        
        self.image_container_layout.addWidget(self.image_label)
        self.scroll_area.setWidget(self.image_container)
        
        self.content_layout.addWidget(self.scroll_area)
        
        self.text_preview = QTextEdit()
        self.text_preview.setReadOnly(True)
        self.text_preview.setObjectName("PreviewTextEdit")
        self.content_layout.addWidget(self.text_preview)
        
        self.inner_layout.addWidget(self.content_area, 1)

        self.controls = QFrame()
        self.controls.setFixedHeight(50)
        self.controls.setObjectName("PreviewControls")
        
        ctrl_layout = QHBoxLayout(self.controls)
        ctrl_layout.setContentsMargins(0, 5, 0, 10)
        ctrl_layout.setAlignment(Qt.AlignCenter)
        
        self.btn_zoom_out = self._create_control_button("ï¼", "ç¼©å° (-)")
        self.btn_zoom_out.clicked.connect(self.zoom_out)
        
        self.btn_100 = self._create_control_button("1:1", "åŸå§‹å°ºå¯¸ (1)")
        self.btn_100.clicked.connect(self.reset_zoom)
        
        self.btn_fit = self._create_control_button("Fit", "é€‚åº”çª—å£ (0)")
        self.btn_fit.clicked.connect(self.fit_to_window)
        
        self.btn_zoom_in = self._create_control_button("ï¼‹", "æ”¾å¤§ (+)")
        self.btn_zoom_in.clicked.connect(self.zoom_in)
        
        self.btn_rot_l = self._create_control_button("â†º", "å·¦æ—‹è½¬ (L)")
        self.btn_rot_l.clicked.connect(lambda: self.rotate(-90))
        
        self.btn_rot_r = self._create_control_button("â†»", "å³æ—‹è½¬ (R)")
        self.btn_rot_r.clicked.connect(lambda: self.rotate(90))

        ctrl_layout.addWidget(self.btn_rot_l)
        ctrl_layout.addWidget(self.btn_zoom_out)
        ctrl_layout.addWidget(self.btn_100)
        ctrl_layout.addWidget(self.btn_fit)
        ctrl_layout.addWidget(self.btn_zoom_in)
        ctrl_layout.addWidget(self.btn_rot_r)
        
        self.inner_layout.addWidget(self.controls)
        
        self.text_preview.installEventFilter(self)
        self.image_label.installEventFilter(self)
        self.image_container.installEventFilter(self)
        self.scroll_area.installEventFilter(self)

    def _create_control_button(self, text, tooltip):
        btn = QPushButton(text)
        btn.setToolTip(tooltip)
        btn.setObjectName("PreviewControlButton")
        btn.setFocusPolicy(Qt.NoFocus)
        return btn

    def eventFilter(self, source, event):
        if event.type() == event.KeyPress:
            if event.key() in [Qt.Key_Space, Qt.Key_Escape]:
                self.close()
                return True
            if event.key() in [Qt.Key_Plus, Qt.Key_Equal]:
                self.zoom_in(); return True
            if event.key() == Qt.Key_Minus:
                self.zoom_out(); return True
            if event.key() == Qt.Key_0:
                self.fit_to_window(); return True
            if event.key() == Qt.Key_1:
                self.reset_zoom(); return True
            if event.key() == Qt.Key_R:
                self.rotate(90); return True
            if event.key() == Qt.Key_L:
                self.rotate(-90); return True

        if source in [self.image_label, self.image_container] and self.mode == 'image':
            if event.type() == event.MouseButtonPress and event.button() == Qt.LeftButton:
                self.is_dragging = True
                self.last_mouse_pos = event.globalPos()
                self.setCursor(Qt.ClosedHandCursor)
                return True
            elif event.type() == event.MouseMove and self.is_dragging:
                delta = event.globalPos() - self.last_mouse_pos
                self.last_mouse_pos = event.globalPos()
                h = self.scroll_area.horizontalScrollBar()
                v = self.scroll_area.verticalScrollBar()
                h.setValue(h.value() - delta.x())
                v.setValue(v.value() - delta.y())
                return True
            elif event.type() == event.MouseButtonRelease:
                self.is_dragging = False
                self.update_cursor()
                return True

        if event.type() == event.Wheel and source == self.text_preview:
             if event.modifiers() == Qt.ControlModifier:
                 delta = event.angleDelta().y()
                 if delta > 0: self.text_preview.zoomIn(1)
                 else: self.text_preview.zoomOut(1)
                 return True

        return super().eventFilter(source, event)

    def load_data(self, content, item_type, file_path=None, image_path=None, image_blob=None):
        self.clear_state()
        
        pixmap = QPixmap()
        can_show_image = False

        if item_type == 'image':
            if image_blob:
                can_show_image = pixmap.loadFromData(image_blob)
            else: # å…¼å®¹æ—§æ•°æ®
                import os
                path_to_try = image_path or file_path
                if path_to_try and os.path.exists(path_to_try):
                    can_show_image = pixmap.load(path_to_try)

        if can_show_image:
            self.mode = 'image'
            self.original_pixmap = pixmap
            self.scroll_area.show()
            self.controls.show()
            self.fit_to_window(fast_mode=True)
            self.update_info_label()
            self.scroll_area.setFocus()
            return

        self.mode = 'text'
        self.text_preview.setPlainText(content)
        self.text_preview.show()
        self.controls.hide() 
        f = self.text_preview.font()
        f.setPointSize(14)
        self.text_preview.setFont(f)
        self.lbl_info.setText("Text View")

    def clear_state(self):
        self.image_label.clear()
        self.image_container.adjustSize()
        self.text_preview.clear()
        self.scroll_area.hide()
        self.text_preview.hide()
        self.current_scale = 1.0
        self.rotation_angle = 0
        self.original_pixmap = None
        self.is_dragging = False
        self.setCursor(Qt.ArrowCursor)

    def update_image_display(self, fast_mode=False):
        if not self.original_pixmap: return
        
        transform = QTransform().rotate(self.rotation_angle)
        processed_pixmap = self.original_pixmap.transformed(transform, Qt.SmoothTransformation)
        
        if self.current_scale <= 0: self.current_scale = 0.1
        
        target_w = min(int(processed_pixmap.width() * self.current_scale), 10000)
        target_h = min(int(processed_pixmap.height() * self.current_scale), 10000)
        
        mode = Qt.FastTransformation if fast_mode or (processed_pixmap.width() > 3000 and self.current_scale < 1.0) else Qt.SmoothTransformation

        final = processed_pixmap.scaled(target_w, target_h, Qt.KeepAspectRatio, mode)
        self.image_label.setPixmap(final)
        self.image_label.setFixedSize(final.size()) # é”å®šæ ‡ç­¾å°ºå¯¸ï¼Œé˜²æ­¢æŠ–åŠ¨
        self.image_container.adjustSize() # é©±åŠ¨å®¹å™¨é‡æ–°è®¡ç®—é˜´å½±è¾¹è·
        
        self.update_cursor()
        self.update_info_label(processed_pixmap.width(), processed_pixmap.height())

    def update_cursor(self):
        if self.mode == 'image' and (self.current_scale > 1.0 or self.image_label.width() > self.scroll_area.width() or self.image_label.height() > self.scroll_area.height()):
            self.setCursor(Qt.OpenHandCursor)
        else:
            self.setCursor(Qt.ArrowCursor)

    def update_info_label(self, w=0, h=0):
        if self.mode == 'image':
            if w == 0 and self.original_pixmap:
                w, h = self.original_pixmap.width(), self.original_pixmap.height()
            self.lbl_info.setText(f"{w}x{h} | {int(self.current_scale*100)}% | {self.rotation_angle}Â°")
        else:
            self.lbl_info.setText("Text View")

    def zoom_in(self):
        if self.mode == 'image': self.current_scale *= 1.2; self.update_image_display()
        else: self.text_preview.zoomIn(1)

    def zoom_out(self):
        if self.mode == 'image': self.current_scale /= 1.2; self.update_image_display()
        else: self.text_preview.zoomOut(1)

    def reset_zoom(self):
        self.current_scale = 1.0
        self.rotation_angle = 0
        self.update_image_display()
    
    def fit_to_window(self, fast_mode=False):
        if not self.original_pixmap: return
        self.rotation_angle = 0
        
        view_w = self.scroll_area.width() - 10
        view_h = self.scroll_area.height() - 10
        
        scale_w = view_w / self.original_pixmap.width()
        scale_h = view_h / self.original_pixmap.height()
        self.current_scale = min(scale_w, scale_h, 1.0)
        
        self.update_image_display(fast_mode=fast_mode)

    def rotate(self, angle):
        self.rotation_angle = (self.rotation_angle + angle) % 360
        self.update_image_display()

    def wheelEvent(self, event):
        delta = event.angleDelta().y()
        if self.mode == 'image':
            if delta > 0: self.zoom_in()
            else: self.zoom_out()
        elif event.modifiers() == Qt.ControlModifier:
            if delta > 0: self.zoom_in()
            else: self.zoom_out()
        else:
            super().wheelEvent(event)

    def closeEvent(self, event):
        self.clear_state()
        super().closeEvent(event)

    # === çª—å£æ‹–åŠ¨é€»è¾‘ ===
    def mousePressEvent(self, event):
        # æ£€æŸ¥æ˜¯å¦åœ¨æ ‡é¢˜æ ä¸ŠæŒ‰ä¸‹å·¦é”®
        if event.button() == Qt.LeftButton and self.top_bar.geometry().contains(event.pos()):
            self.is_window_dragging = True
            self.drag_start_position = event.globalPos() - self.frameGeometry().topLeft()
            event.accept()

    def mouseMoveEvent(self, event):
        if self.is_window_dragging and event.buttons() == Qt.LeftButton:
            self.move(event.globalPos() - self.drag_start_position)
            event.accept()

    def mouseReleaseEvent(self, event):
        self.is_window_dragging = False
        event.accept()
```

## æ–‡ä»¶: ui\flow_layout.py

```python
# -*- coding: utf-8 -*-
# Copyright (C) 2013 Riverbank Computing Limited.
# Copyright (C) 2022 The Qt Company Ltd.
# SPDX-License-Identifier: LicenseRef-Qt-Commercial OR BSD-3-Clause
#
# PyQt5 port of the widgets/layouts/flowlayout example from Qt v6.x

from PyQt5.QtCore import Qt, QMargins, QPoint, QRect, QSize
from PyQt5.QtWidgets import QLayout, QSizePolicy

class FlowLayout(QLayout):
    def __init__(self, parent=None, margin=0, spacing=-1):
        super().__init__(parent)

        if parent is not None:
            self.setContentsMargins(margin, margin, margin, margin)

        if spacing >= 0:
            self.setSpacing(spacing)
        else:
            # use default spacing
            pass

        self._item_list = []

    def __del__(self):
        item = self.takeAt(0)
        while item:
            item = self.takeAt(0)

    def addItem(self, item):
        self._item_list.append(item)

    def count(self):
        return len(self._item_list)

    def itemAt(self, index):
        if 0 <= index < len(self._item_list):
            return self._item_list[index]

        return None

    def takeAt(self, index):
        if 0 <= index < len(self._item_list):
            return self._item_list.pop(index)

        return None

    def expandingDirections(self):
        return Qt.Orientation(0)

    def hasHeightForWidth(self):
        return True

    def heightForWidth(self, width):
        height = self._do_layout(QRect(0, 0, width, 0), True)
        return height

    def setGeometry(self, rect):
        super(FlowLayout, self).setGeometry(rect)
        self._do_layout(rect, False)

    def sizeHint(self):
        return self.minimumSize()

    def minimumSize(self):
        size = QSize()

        for item in self._item_list:
            size = size.expandedTo(item.minimumSize())

        size += QSize(2 * self.contentsMargins().top(), 2 * self.contentsMargins().top())
        return size

    def _do_layout(self, rect, test_only):
        x = rect.x()
        y = rect.y()
        line_height = 0
        spacing = self.spacing()

        for item in self._item_list:
            style = item.widget().style()
            layout_spacing_x = style.layoutSpacing(
                QSizePolicy.ControlType.PushButton, QSizePolicy.ControlType.PushButton,
                Qt.Orientation.Horizontal
            )
            layout_spacing_y = style.layoutSpacing(
                QSizePolicy.ControlType.PushButton, QSizePolicy.ControlType.PushButton,
                Qt.Orientation.Vertical
            )
            space_x = spacing + layout_spacing_x
            space_y = spacing + layout_spacing_y
            next_x = x + item.sizeHint().width() + space_x
            if next_x - space_x > rect.right() and line_height > 0:
                x = rect.x()
                y = y + line_height + space_y
                next_x = x + item.sizeHint().width() + space_x
                line_height = 0

            if not test_only:
                item.setGeometry(QRect(QPoint(x, y), item.sizeHint()))

            x = next_x
            line_height = max(line_height, item.sizeHint().height())

        return y + line_height - rect.y()
```

## æ–‡ä»¶: ui\main_window.py

```python
# -*- coding: utf-8 -*-
import logging
import ctypes
import os
from ctypes.wintypes import MSG
from datetime import datetime, time, timedelta

from PyQt5.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
                             QDockWidget, QLabel, QPushButton, QFrame, 
                             QApplication, QShortcut, QSizeGrip, QMessageBox,
                             QAbstractItemView, QTableWidgetItem, QHeaderView, QMenu)
from PyQt5.QtCore import Qt, QPoint, QTimer, QSettings, QRect
from PyQt5.QtGui import QColor, QKeySequence, QImage
from sqlalchemy.orm import joinedload

# æ ¸å¿ƒé€»è¾‘
from data.database import DBManager, Partition
from services.clipboard import ClipboardManager
from core.shared import format_size, get_color_icon

# UI ç»„ä»¶
from ui.components import CustomTitleBar
from ui.custom_dock import CustomDockTitleBar
from ui.panel_filter import FilterPanel
from ui.panel_table import TablePanel
from ui.panel_detail import DetailPanel
from ui.panel_tags import TagPanel
from ui.panel_partition import PartitionPanel
from ui.dialogs import TagDialog, ColorDialog
from ui.context_menu import ContextMenuHandler
from ui.color_selector import ColorSelectorDialog
from ui.dialog_preview import PreviewDialog

import themes.dark
import themes.light
import platform

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
log = logging.getLogger("MainWindow")

# Windows API
if platform.system() == "Windows":
    SetWindowPos = ctypes.windll.user32.SetWindowPos
    HWND_TOPMOST = -1
    HWND_NOTOPMOST = -2
    SWP_NOMOVE = 0x0002
    SWP_NOSIZE = 0x0001
    SWP_NOACTIVATE = 0x0010
else:
    SetWindowPos = lambda *args: None
    HWND_TOPMOST = -1
    HWND_NOTOPMOST = -2
    SWP_NOMOVE = 0x0002
    SWP_NOSIZE = 0x0001
    SWP_NOACTIVATE = 0x0010


class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        log.info("ğŸš€ åˆå§‹åŒ– MainWindow...")
        self.setWindowTitle("å°è±¡è®°å¿†_Pro")
        
        screen_geo = QApplication.desktop().availableGeometry()
        screen_w, screen_h = screen_geo.width(), screen_geo.height()
        
        init_w = min(1200, int(screen_w * 0.9))
        init_h = min(700, int(screen_h * 0.9))
        self.resize(init_w, init_h)
        self.move((screen_w - init_w) // 2, (screen_h - init_h) // 2)
        
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowSystemMenuHint | Qt.WindowMinimizeButtonHint | Qt.WindowMaximizeButtonHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        self.setMouseTracking(True)
        
        self.border_width = 8
        self.is_pinned = False
        
        self.edit_mode = False
        self.current_sort_mode = "manual"
        self.last_external_hwnd = None
        self.col_alignments = {} 
        self.current_item_id = None
        self.page = 1
        self.page_size = 100
        self.total_items = 0
        self._processing_clipboard = False
        self.item_id_to_select_after_load = None
        
        self.cached_items = []
        self.cached_items_map = {}
        
        self.save_timer = QTimer()
        self.save_timer.setSingleShot(True)
        self.save_timer.setInterval(500)
        self.save_timer.timeout.connect(self.save_window_state)
        
        self.focus_timer = QTimer()
        self.focus_timer.timeout.connect(self.track_active_window)
        self.focus_timer.start(200)
        
        self.db = DBManager()
        self.cm = ClipboardManager(self.db)
        self.cm.data_captured.connect(self.refresh_after_capture) 
        
        self.clipboard = QApplication.clipboard()
        self.clipboard.dataChanged.connect(self.on_clipboard_event)
        
        self.setup_ui()
        self.menu_handler = ContextMenuHandler(self)
        self.setup_shortcuts()
        
        self.restore_window_state()
        self.load_data()
        
        log.info("âœ… ä¸»çª—å£å¯åŠ¨å®Œæ¯•")

    def setup_ui(self):
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.outer_layout = QVBoxLayout(self.central_widget)
        self.outer_layout.setContentsMargins(5, 5, 5, 5) 
        self.outer_layout.setSpacing(0)
        
        self.big_container = QFrame()
        self.big_container.setObjectName("MainFrame")
        self.outer_layout.addWidget(self.big_container)
        self.inner_layout = QVBoxLayout(self.big_container)
        self.inner_layout.setContentsMargins(0, 0, 0, 0)
        self.inner_layout.setSpacing(0)
        
        self.title_bar = CustomTitleBar(self)
        self.title_bar.refresh_clicked.connect(self.load_data)
        self.title_bar.theme_clicked.connect(self.toggle_theme)
        self.title_bar.search_changed.connect(self._apply_frontend_filters)
        self.title_bar.display_count_changed.connect(self.on_display_count_changed)
        self.title_bar.pin_clicked.connect(self.toggle_pin)
        self.title_bar.clean_clicked.connect(self.auto_clean)
        self.title_bar.mode_clicked.connect(self.toggle_edit_mode)
        self.title_bar.color_clicked.connect(self.toolbar_set_color)
        self.inner_layout.addWidget(self.title_bar)
        
        self.dock_container = QMainWindow()
        self.dock_container.setWindowFlags(Qt.Widget)
        self.dock_container.setDockOptions(
            QMainWindow.AllowNestedDocks | QMainWindow.AnimatedDocks | QMainWindow.GroupedDragging
        )
        self.dock_container.setCorner(Qt.TopLeftCorner, Qt.LeftDockWidgetArea)
        self.dock_container.setCorner(Qt.BottomLeftCorner, Qt.LeftDockWidgetArea)
        self.dock_container.setCorner(Qt.TopRightCorner, Qt.RightDockWidgetArea)
        self.dock_container.setCorner(Qt.BottomRightCorner, Qt.RightDockWidgetArea)
        self.inner_layout.addWidget(self.dock_container, 1) 
        
        self.dock_filter = QDockWidget("ç­›é€‰å™¨", self.dock_container)
        self.dock_filter.setObjectName("DockFilter")
        self.dock_filter.setTitleBarWidget(CustomDockTitleBar("ç­›é€‰å™¨", self.dock_filter, self.dock_container))
        self.dock_filter.setFeatures(QDockWidget.AllDockWidgetFeatures)
        self.dock_filter.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        self.filter_panel = FilterPanel() 
        self.filter_panel.filterChanged.connect(self._apply_frontend_filters)
        self.dock_filter.setWidget(self.filter_panel)
        self.dock_container.addDockWidget(Qt.LeftDockWidgetArea, self.dock_filter)
        
        self.dock_partition = QDockWidget("åˆ†åŒºç»„", self.dock_container)
        self.dock_partition.setObjectName("DockPartition")
        self.dock_partition.setTitleBarWidget(CustomDockTitleBar("åˆ†åŒºç»„", self.dock_partition, self.dock_container))
        self.dock_partition.setFeatures(QDockWidget.AllDockWidgetFeatures)
        self.dock_partition.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        self.partition_panel = PartitionPanel(self.db)
        self.partition_panel.partitionSelectionChanged.connect(lambda: self.load_data(reset_page=True))
        self.partition_panel.partitionsUpdated.connect(self.partition_panel.refresh_partitions)
        self.partition_panel.partitionsUpdated.connect(self.load_data)
        self.dock_partition.setWidget(self.partition_panel)
        self.dock_container.addDockWidget(Qt.LeftDockWidgetArea, self.dock_partition)

        self.dock_tags = QDockWidget("æ ‡ç­¾", self.dock_container)
        self.dock_tags.setObjectName("DockTags")
        self.dock_tags.setTitleBarWidget(CustomDockTitleBar("æ ‡ç­¾", self.dock_tags, self.dock_container))
        self.dock_tags.setFeatures(QDockWidget.AllDockWidgetFeatures)
        self.dock_tags.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        self.tag_panel = TagPanel()
        self.tag_panel.setEnabled(False)
        self.tag_panel.tags_committed.connect(self.on_tag_panel_commit_tags)
        self.tag_panel.tag_selected.connect(self.on_tag_selected)
        self.dock_tags.setWidget(self.tag_panel)
        self.dock_container.addDockWidget(Qt.LeftDockWidgetArea, self.dock_tags)
        
        self.dock_container.splitDockWidget(self.dock_filter, self.dock_partition, Qt.Horizontal)
        self.dock_container.splitDockWidget(self.dock_partition, self.dock_tags, Qt.Horizontal)

        self.dock_detail = QDockWidget("è¯¦ç»†ä¿¡æ¯", self.dock_container)
        self.dock_detail.setObjectName("DockDetail")
        self.dock_detail.setTitleBarWidget(CustomDockTitleBar("è¯¦ç»†ä¿¡æ¯", self.dock_detail, self.dock_container))
        self.dock_detail.setFeatures(QDockWidget.AllDockWidgetFeatures)
        self.dock_detail.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        self.detail_panel = DetailPanel() 
        self.detail_panel.update_note_signal.connect(self.save_note)
        self.detail_panel.tags_added_signal.connect(self.on_tags_added)
        self.detail_panel.remove_tag_signal.connect(self.remove_tag)
        self.dock_detail.setWidget(self.detail_panel)
        self.dock_container.addDockWidget(Qt.RightDockWidgetArea, self.dock_detail)
        
        self.table = TablePanel()
        from PyQt5.QtWidgets import QSizePolicy
        self.table.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.table.setMinimumWidth(300)
        self.table.horizontalHeader().customContextMenuRequested.connect(self.show_header_menu)
        self.table.horizontalHeader().sectionResized.connect(self.schedule_save_state)
        self.table.itemSelectionChanged.connect(self.update_detail_panel)
        self.table.itemDoubleClicked.connect(self.on_table_double_click)
        self.table.itemChanged.connect(self.on_item_changed)
        self.table.customContextMenuRequested.connect(self.show_context_menu)
        self.table.reorder_signal.connect(self.reorder_items)
        self.dock_container.setCentralWidget(self.table)
        
        self.filter_panel.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        self.partition_panel.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        self.tag_panel.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        self.detail_panel.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Expanding)
        
        self.dock_container.setMouseTracking(True)
        min_w = 230
        for dock in [self.dock_filter, self.dock_partition, self.dock_tags, self.dock_detail]:
            dock.setMinimumWidth(min_w)
            dock.setMaximumWidth(16777215)
        
        self.bottom_bar = QWidget()
        self.bottom_bar.setFixedHeight(32)
        bl = QHBoxLayout(self.bottom_bar)
        bl.setContentsMargins(10, 0, 10, 0)
        self.lbl_status = QLabel("å°±ç»ª")
        self.lbl_status.setObjectName("StatusLabel")
        bl.addWidget(self.lbl_status)
        bl.addStretch()

        self.btn_first = QPushButton("Â« é¦–é¡µ")
        self.btn_first.setFixedSize(80, 28)
        self.btn_prev = QPushButton("< ä¸Šä¸€é¡µ")
        self.btn_prev.setFixedSize(80, 28)
        self.lbl_page = QLabel("1 / 1")
        self.lbl_page.setObjectName("PageLabel")
        self.btn_next = QPushButton("ä¸‹ä¸€é¡µ >")
        self.btn_next.setFixedSize(80, 28)
        self.btn_last = QPushButton("æœ«é¡µ Â»")
        self.btn_last.setFixedSize(80, 28)
        self.btn_first.clicked.connect(self.go_to_first_page)
        self.btn_prev.clicked.connect(self.prev_page)
        self.btn_next.clicked.connect(self.next_page)
        self.btn_last.clicked.connect(self.go_to_last_page)
        bl.addWidget(self.btn_first)
        bl.addWidget(self.btn_prev)
        bl.addWidget(self.lbl_page)
        bl.addWidget(self.btn_next)
        bl.addWidget(self.btn_last)
        self.size_grip = QSizeGrip(self.bottom_bar)
        self.size_grip.setFixedSize(16, 16)
        bl.addWidget(self.size_grip, 0, Qt.AlignBottom | Qt.AlignRight)
        self.inner_layout.addWidget(self.bottom_bar)
        
        for dock in [self.dock_filter, self.dock_partition, self.dock_tags, self.dock_detail]:
            dock.dockLocationChanged.connect(self.schedule_save_state)
            dock.visibilityChanged.connect(self.handle_dock_visibility_changed)
        
        self.table.horizontalHeader().sectionResized.connect(self.schedule_save_state)
        self.table.horizontalHeader().sectionMoved.connect(self.schedule_save_state)
        QTimer.singleShot(100, self.connect_splitters)

        self.preview_dlg = None
        self.table.installEventFilter(self)
        log.info("âœ… UIåˆå§‹åŒ–å®Œæˆ")

    def connect_splitters(self):
        log.debug("è¿æ¥Dockå®¹å™¨ä¸­çš„QSplitterä¿¡å·...")
        from PyQt5.QtWidgets import QSplitter
        splitters = self.dock_container.findChildren(QSplitter)
        for splitter in splitters:
            splitter.splitterMoved.connect(self.schedule_save_state)
        log.info(f"âœ… å·²è¿æ¥ {len(splitters)} ä¸ªQSplitterçš„ä¿¡å·")

    def toggle_preview(self):
        if self.preview_dlg and self.preview_dlg.isVisible():
            self.preview_dlg.close()
            return
        
        rows = self.table.selectionModel().selectedRows()
        if not rows:
            return
            
        try:
            item_id_item = self.table.item(rows[0].row(), 8)
            if not item_id_item:
                return
            item_id = int(item_id_item.text())
            
            session = self.db.get_session()
            from data.database import ClipboardItem
            item = session.query(ClipboardItem).get(item_id)
            if item:
                if not self.preview_dlg:
                    self.preview_dlg = PreviewDialog(self)
                
                self.preview_dlg.load_data(item.content, item.item_type, item.file_path, item.image_path, item.data_blob)
                self.preview_dlg.show()
                self.preview_dlg.raise_()
                self.preview_dlg.activateWindow()
            session.close()
        except Exception as e:
            log.error(f"é¢„è§ˆå¤±è´¥: {e}")

    def eventFilter(self, source, event):
        if source == self.table and event.type() == event.KeyPress:
            if event.key() == Qt.Key_Space:
                self.toggle_preview()
                return True
        return super().eventFilter(source, event)

    def nativeEvent(self, eventType, message):
        if eventType == "windows_generic_MSG" and platform.system() == "Windows":
            msg = MSG.from_address(message.__int__())
            if msg.message == 0x0084:
                x = ctypes.c_short(msg.lParam & 0xFFFF).value
                y = ctypes.c_short((msg.lParam >> 16) & 0xFFFF).value
                pos = self.mapFromGlobal(QPoint(x, y))
                w, h, m = self.width(), self.height(), self.border_width
                
                is_left = pos.x() < m
                is_right = pos.x() > w - m
                is_top = pos.y() < m
                is_bottom = pos.y() > h - m
                
                if is_top and is_left: return True, 13
                if is_top and is_right: return True, 14
                if is_bottom and is_left: return True, 16
                if is_bottom and is_right: return True, 17
                if is_left: return True, 10
                if is_right: return True, 11
                if is_top: return True, 12
                if is_bottom: return True, 15
                
                if self.title_bar:
                    title_pos = self.title_bar.mapFromGlobal(QPoint(x, y))
                    if self.title_bar.rect().contains(title_pos) and not self.title_bar.childAt(title_pos):
                        return True, 2
                        
        return super().nativeEvent(eventType, message)

    def show_context_menu(self, pos):
        self.menu_handler.show_menu(pos)

    def track_active_window(self):
        if platform.system() == "Windows":
            try:
                hwnd = ctypes.windll.user32.GetForegroundWindow()
                if hwnd and hwnd != int(self.winId()):
                    self.last_external_hwnd = hwnd
            except:
                pass

    def setup_shortcuts(self):
        for i in range(6):
            QShortcut(QKeySequence(f"Ctrl+{i}"), self).activated.connect(lambda l=i: self.batch_set_star_shortcut(l))
        QShortcut(QKeySequence("Ctrl+G"), self).activated.connect(self.group_items_shortcut)
        QShortcut(QKeySequence("Ctrl+E"), self).activated.connect(self.toggle_favorite_shortcut)
        QShortcut(QKeySequence("Ctrl+S"), self).activated.connect(self.toggle_lock_shortcut)
        QShortcut(QKeySequence("Ctrl+F"), self).activated.connect(self.focus_search_shortcut)
        QShortcut(QKeySequence("Del"), self).activated.connect(lambda: self.smart_delete(force_warn=False))
        QShortcut(QKeySequence("Ctrl+Shift+Del"), self).activated.connect(lambda: self.smart_delete(force_warn=True))

    def group_items_shortcut(self):
        self._batch_action("æ™ºèƒ½æˆç»„", lambda ids: self.menu_handler.batch_group_smart(ids))

    def toggle_favorite_shortcut(self):
        self._batch_action("åˆ‡æ¢æ”¶è—", lambda ids: self.menu_handler.batch_toggle(ids, 'is_favorite'))
        
    def toggle_lock_shortcut(self):
        self._batch_action("åˆ‡æ¢é”å®š", lambda ids: self.menu_handler.batch_toggle(ids, 'is_locked'))
        
    def focus_search_shortcut(self):
        if hasattr(self, 'title_bar') and hasattr(self.title_bar, 'search_bar'):
            self.title_bar.search_bar.setFocus()
            self.title_bar.search_bar.selectAll()

    def _batch_action(self, name, action_func):
        rows = self.table.selectionModel().selectedRows()
        if not rows:
            return
        
        ids = []
        for r in rows:
            item = self.table.item(r.row(), 8)
            if item and item.text():
                ids.append(int(item.text()))
        
        if ids:
            log.info(f"âŒ¨ï¸ å¿«æ·é”®è§¦å‘: {name} ({len(ids)} é¡¹)")
            action_func(ids)

    def smart_delete(self, force_warn=False):
        rows = self.table.selectionModel().selectedRows()
        if not rows:
            return
        
        ids = [int(self.table.item(r.row(), 8).text()) for r in rows if self.table.item(r.row(), 8) and self.table.item(r.row(), 8).text()]
        if not ids:
            return
        
        is_in_trash = getattr(self.table, 'is_trash_view', False)
        
        session = self.db.get_session()
        from data.database import ClipboardItem
        items = session.query(ClipboardItem).filter(ClipboardItem.id.in_(ids)).all()
        deletable_ids = [item.id for item in items if not item.is_favorite and not item.is_locked]
        skipped_count = len(ids) - len(deletable_ids)
        session.close()
        
        if not deletable_ids:
            self.lbl_status.setText(f"âš ï¸ é€‰ä¸­çš„ {len(ids)} ä¸ªé¡¹ç›®å‡å—ä¿æŠ¤ï¼Œæ“ä½œå–æ¶ˆ")
            return

        if is_in_trash:
            msg = f"ç¡®å®šè¦ã€æ°¸ä¹…åˆ é™¤ã€‘è¿™ {len(deletable_ids)} ä¸ªé¡¹ç›®å—ï¼Ÿ\nè¯¥æ“ä½œä¸å¯æ’¤é”€ï¼"
            if skipped_count > 0:
                msg += f"\n(å·²è‡ªåŠ¨è·³è¿‡ {skipped_count} ä¸ªå—ä¿æŠ¤çš„é¡¹ç›®)"
            
            if QMessageBox.warning(self, "æ°¸ä¹…åˆ é™¤ç¡®è®¤", msg, QMessageBox.Yes | QMessageBox.No, QMessageBox.No) == QMessageBox.Yes:
                self.db.delete_items_permanently(deletable_ids)
                self.lbl_status.setText(f"ğŸ”¥ å·²æ°¸ä¹…åˆ é™¤ {len(deletable_ids)} é¡¹")
            else:
                return
        else:
            if force_warn or len(deletable_ids) > 10:
                msg = f"ç¡®å®šè¦å°†è¿™ {len(deletable_ids)} ä¸ªé¡¹ç›®ç§»åŠ¨åˆ°å›æ”¶ç«™å—?"
                if skipped_count > 0:
                    msg += f"\n(å·²è‡ªåŠ¨è·³è¿‡ {skipped_count} ä¸ªå—ä¿æŠ¤é¡¹ç›®)"
                if QMessageBox.question(self, "ç¡®è®¤åˆ é™¤", msg, QMessageBox.Yes | QMessageBox.No) != QMessageBox.Yes:
                    return
            
            self.db.move_items_to_trash(deletable_ids)
            self.lbl_status.setText(f"âœ… å·²ç§»åŠ¨ {len(deletable_ids)} é¡¹åˆ°å›æ”¶ç«™")

        self.load_data()
        self.partition_panel.refresh_partitions()

    def batch_set_star_shortcut(self, lvl):
        self._batch_action(f"è®¾ç½®æ˜Ÿçº§ä¸º {lvl}", lambda ids: self.menu_handler.batch_set_star(ids, lvl))

    def schedule_save_state(self):
        self.save_timer.start()

    def save_window_state(self):
        log.info("ğŸ’¾ ä¿å­˜çª—å£çŠ¶æ€...")
        s = QSettings("ClipboardPro", "WindowState_v7")
        s.setValue("geometry", self.saveGeometry())
        s.setValue("windowState", self.dock_container.saveState())
        s.setValue("editMode", self.edit_mode)
        s.setValue("current_theme", self.current_theme)
        s.setValue("columnWidths", [self.table.columnWidth(i) for i in range(self.table.columnCount())])
        header = self.table.horizontalHeader()
        s.setValue("columnOrder", [header.visualIndex(i) for i in range(self.table.columnCount())])
        for i, align in self.col_alignments.items():
            s.setValue(f"col_{i}_align", align)
        s.setValue("is_pinned", self.is_pinned)
        s.setValue("pageSize", self.page_size)
        log.info("âœ… çª—å£çŠ¶æ€å·²ä¿å­˜")

    def restore_window_state(self):
        log.info("ğŸ’¾ æ¢å¤çª—å£çŠ¶æ€...")
        s = QSettings("ClipboardPro", "WindowState_v7")
        
        if g := s.value("geometry"):
            self.restoreGeometry(g)
        
        screen_geo = QApplication.desktop().availableGeometry()
        curr_geo = self.geometry()
        if curr_geo.height() > screen_geo.height() or curr_geo.top() < 0 or curr_geo.left() < 0:
             log.warning("âš ï¸ æ£€æµ‹åˆ°çª—å£å°ºå¯¸å¼‚å¸¸ï¼Œæ­£åœ¨é‡ç½®ä¸ºå®‰å…¨å°ºå¯¸...")
             init_w = min(1200, int(screen_geo.width() * 0.9))
             init_h = min(700, int(screen_geo.height() * 0.9))
             self.resize(init_w, init_h)
             self.move((screen_geo.width() - init_w) // 2, (screen_geo.height() - init_h) // 2)

        if ws := s.value("windowState"):
            self.dock_container.restoreState(ws)
        else:
            main_width = self.dock_container.width()
            left_width = int(main_width * 0.20)
            right_width = int(main_width * 0.25)
            left_docks = [d for d in [self.dock_filter, self.dock_partition, self.dock_tags] if d.isVisible()]
            right_docks = [d for d in [self.dock_detail] if d.isVisible()]
            if left_docks:
                self.dock_container.resizeDocks(left_docks, [left_width] * len(left_docks), Qt.Horizontal)
            if right_docks:
                self.dock_container.resizeDocks(right_docks, [right_width] * len(right_docks), Qt.Horizontal)

        self.is_pinned = s.value("is_pinned", False, type=bool)
        if self.is_pinned:
            self.toggle_pin(True)
        if hasattr(self.title_bar, 'btn_pin'):
            self.title_bar.btn_pin.setChecked(self.is_pinned)

        for dock in [self.dock_filter, self.dock_partition, self.dock_tags, self.dock_detail]:
            dock.setVisible(True)
            dock.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        
        self.edit_mode = s.value("editMode", False, type=bool)
        if hasattr(self.title_bar, 'btn_mode'):
            self.title_bar.btn_mode.setChecked(self.edit_mode)
        self.toggle_edit_mode(self.edit_mode)

        self.page_size = s.value("pageSize", 100, type=int)
        if hasattr(self, 'title_bar'):
            self.title_bar.set_display_count(self.page_size)
        
        if cw := s.value("columnWidths"):
            for i, w in enumerate([int(w) for w in cw]): 
                if i < self.table.columnCount():
                    self.table.setColumnWidth(i, w)
        if co := s.value("columnOrder"):
            header = self.table.horizontalHeader()
            for logical_idx, visual_idx in enumerate(co):
                header.moveSection(header.visualIndex(logical_idx), int(visual_idx))
        
        for i in range(self.table.columnCount()):
            if align := s.value(f"col_{i}_align"):
                self.col_alignments[i] = int(align)
        
        self.apply_theme(s.value("current_theme", "dark"))
        log.info("âœ… çª—å£çŠ¶æ€å·²æ¢å¤")

    def handle_dock_visibility_changed(self, visible):
        if not visible:
            log.info("æ™ºèƒ½å¸ƒå±€è§¦å‘ï¼šä¾§æ å˜åŠ¨")
            left_docks = [d for d in [self.dock_filter, self.dock_partition, self.dock_tags] if d.isVisible() and not d.isFloating()]
            right_docks = [d for d in [self.dock_detail] if d.isVisible() and not d.isFloating()]
            QTimer.singleShot(10, lambda: self._do_smart_resize(left_docks, right_docks))

    def _do_smart_resize(self, left_docks, right_docks):
        try:
            if left_docks:
                self.dock_container.resizeDocks(left_docks, [d.width() for d in left_docks], Qt.Horizontal)
            if right_docks:
                self.dock_container.resizeDocks(right_docks, [d.width() for d in right_docks], Qt.Horizontal)
        except Exception as e:
            log.debug(f"æ™ºèƒ½å¸ƒå±€è°ƒæ•´ç•¥è¿‡: {e}")

    def closeEvent(self, e):
        self.save_window_state()
        e.accept()

    def on_clipboard_event(self):
        if self._processing_clipboard:
            return
        
        self._processing_clipboard = True
        try:
            self.cm.process_clipboard(self.clipboard.mimeData(), self.partition_panel.get_current_selection())
        finally:
            self._processing_clipboard = False

    def refresh_after_capture(self):
        QTimer.singleShot(0, self.load_data)
        QTimer.singleShot(0, self.partition_panel.refresh_partitions)

    def go_to_first_page(self):
        self.page = 1
        self.load_data()

    def go_to_last_page(self):
        if self.page_size > 0:
            total_pages = (self.total_items + self.page_size - 1) // self.page_size
            self.page = total_pages if total_pages > 0 else 1
            self.load_data()

    def prev_page(self): 
        if self.page > 1:
            self.page -= 1
            self.load_data()

    def next_page(self):
        total_pages = (self.total_items + self.page_size - 1) // self.page_size if self.page_size > 0 else 1
        if self.page < total_pages:
            self.page += 1
            self.load_data()

    def load_data(self, reset_page=False):
        try:
            log.info(f"ğŸ”„ å¼€å§‹åŠ è½½æ•°æ® (reset_page={reset_page})")
            if reset_page:
                self.page = 1
            
            partition_filter = self.partition_panel.get_current_selection()
            date_filter = self.filter_panel.get_checked('date_create')[0] if self.filter_panel.get_checked('date_create') else None
            date_modify_filter = self.filter_panel.get_checked('date_modify')[0] if self.filter_panel.get_checked('date_modify') else None
            
            if partition_filter and partition_filter.get('type') == 'today':
                date_modify_filter = 'ä»Šæ—¥'
                partition_filter = None
            
            self.table.setSelectionMode(QAbstractItemView.ExtendedSelection)
            self.table.is_trash_view = bool(partition_filter and partition_filter.get('type') == 'trash')

            log.info(f"ğŸ” æ•°æ®åº“ç­›é€‰æ¡ä»¶: åˆ†åŒº={partition_filter}, åˆ›å»ºæ—¥æœŸ={date_filter}, ä¿®æ”¹æ—¥æœŸ={date_modify_filter}")
            
            self.total_items = self.db.get_count(partition_filter=partition_filter, date_filter=date_filter, date_modify_filter=date_modify_filter)
            
            limit, offset = self.page_size, 0
            if self.page_size != -1:
                self.bottom_bar.show()
                total_pages = (self.total_items + self.page_size - 1) // self.page_size if self.page_size > 0 else 1
                self.lbl_page.setText(f"{self.page} / {max(1, total_pages)}")
                
                is_first = self.page == 1
                is_last = self.page == total_pages or total_pages == 0
                
                self.btn_first.setEnabled(not is_first)
                self.btn_prev.setEnabled(not is_first)
                self.btn_next.setEnabled(not is_last)
                self.btn_last.setEnabled(not is_last)
                
                offset = (self.page - 1) * self.page_size
            else:
                self.bottom_bar.show()
                limit = None
                self.lbl_page.setText("1 / 1")
                self.btn_first.setEnabled(False)
                self.btn_prev.setEnabled(False)
                self.btn_next.setEnabled(False)
                self.btn_last.setEnabled(False)

            items = self.db.get_items(sort_mode=self.current_sort_mode, limit=limit, offset=offset, date_filter=date_filter, date_modify_filter=date_modify_filter, partition_filter=partition_filter)
            
            self.cached_items = items
            self.cached_items_map = {item.id: item for item in items}
            log.info(f"âœ… ä»æ•°æ®åº“åŠ è½½ {len(items)} æ¡æ•°æ®å¹¶ç¼“å­˜")
            
            self.table.blockSignals(True)
            self.table.setRowCount(len(items))
            for row, item in enumerate(items):
                self.table.setItem(row, 8, QTableWidgetItem(str(item.id)))
                
                st_flags = ("ğŸ“Œ" if item.is_pinned else "") + ("â¤ï¸" if item.is_favorite else "") + ("ğŸ”’" if item.is_locked else "")
                display_text = f"{self._get_type_icon(item)} {st_flags}".strip()
                state_item = QTableWidgetItem(display_text)
                if item.custom_color:
                    state_item.setIcon(get_color_icon(item.custom_color))
                self.table.setItem(row, 0, state_item)
                
                self.table.setItem(row, 1, QTableWidgetItem(item.content.replace('\n', ' ')[:100]))
                self.table.setItem(row, 2, QTableWidgetItem(item.note))
                self.table.setItem(row, 3, QTableWidgetItem("â˜…" * item.star_level))
                self.table.setItem(row, 4, QTableWidgetItem(format_size(item.content)))
                
                if item.is_file and item.file_path:
                    _, ext = os.path.splitext(item.file_path)
                    type_str = ext.upper()[1:] if ext else "FILE"
                else:
                    type_str = "TXT"
                self.table.setItem(row, 5, QTableWidgetItem(type_str))
                
                self.table.setItem(row, 6, QTableWidgetItem(item.created_at.strftime("%m-%d %H:%M")))
                self.table.setItem(row, 7, QTableWidgetItem(item.file_path or ""))
                
                for col in range(7):
                    align = self.col_alignments.get(col, Qt.AlignLeft | Qt.AlignVCenter if col in [1,2] else Qt.AlignCenter)
                    table_item = self.table.item(row, col)
                    if table_item:
                        table_item.setTextAlignment(align)
            self.table.blockSignals(False)
            
            self._apply_frontend_filters()
            self.tag_panel.refresh_tags(self.db)
            
            if self.item_id_to_select_after_load is not None:
                self.select_item_in_table(self.item_id_to_select_after_load)
                self.item_id_to_select_after_load = None
            
            log.info("âœ… æ•°æ®åŠ è½½å®Œæˆ")
        except Exception as e:
            log.error(f"Load Error: {e}", exc_info=True)

    def _apply_frontend_filters(self):
        log.info("ğŸ­ åº”ç”¨å‰ç«¯è¿‡æ»¤...")
        search_text = self.title_bar.get_search_text().strip().lower()
        stars = set(self.filter_panel.get_checked('stars'))
        colors = set(self.filter_panel.get_checked('colors'))
        types = set(self.filter_panel.get_checked('types'))
        tags = set(self.filter_panel.get_checked('tags'))
        
        log.debug(f"   ç­›é€‰æ¡ä»¶: æœç´¢='{search_text}', æ˜Ÿçº§={stars}, é¢œè‰²={colors}, ç±»å‹={types}, æ ‡ç­¾={tags}")
        
        visible_count = 0
        for row in range(self.table.rowCount()):
            should_show = True
            id_item = self.table.item(row, 8)
            if not id_item or not id_item.text():
                self.table.setRowHidden(row, True)
                continue
            
            item = self.cached_items_map.get(int(id_item.text()))
            if not item:
                self.table.setRowHidden(row, True)
                continue
            
            if search_text and not (search_text in item.content.lower() or search_text in (item.note or "").lower() or any(search_text in tag.name.lower() for tag in item.tags)):
                should_show = False
            if should_show and stars and item.star_level not in stars:
                should_show = False
            if should_show and colors and (not item.custom_color or item.custom_color not in colors):
                should_show = False
            if should_show and types and self._get_item_type_key(item) not in types:
                should_show = False
            if should_show and tags and not {tag.name for tag in item.tags}.intersection(tags):
                should_show = False
            
            self.table.setRowHidden(row, not should_show)
            if should_show:
                visible_count += 1
        
        log.info(f"âœ… å‰ç«¯è¿‡æ»¤å®Œæˆ: æ˜¾ç¤º {visible_count}/{len(self.cached_items)} è¡Œ")

        # Bug Fix: Calculate stats based on VISIBLE items, not all cached items.
        visible_items = []
        for row in range(self.table.rowCount()):
            if not self.table.isRowHidden(row):
                id_item = self.table.item(row, 8)
                if id_item and id_item.text():
                    item = self.cached_items_map.get(int(id_item.text()))
                    if item:
                        visible_items.append(item)
        
        stats = self._calculate_stats_from_items(visible_items)
        self.filter_panel.update_stats(stats)
        
        self.lbl_status.setText(f"æ€»è®¡: {self.total_items} æ¡ | å½“å‰é¡µ: {len(self.cached_items)} æ¡ | æ˜¾ç¤º: {visible_count} æ¡")

    def _get_type_icon(self, item):
        if item.item_type == 'url': return "ğŸ”—"
        if item.item_type == 'image': return "ğŸ–¼ï¸"
        if item.item_type == 'file' and item.file_path:
            if os.path.exists(item.file_path):
                if os.path.isdir(item.file_path): return "ğŸ“‚"
                ext = os.path.splitext(item.file_path)[1].lower()
                if ext in ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.m4a', '.wma']: return "ğŸµ"
                if ext in ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.ico', '.webp']: return "ğŸ–¼ï¸"
                if ext in ['.mp4', '.mkv', '.avi', '.mov', '.wmv']: return "ğŸ¬"
                return "ğŸ“„"
            return "ğŸ“„"
        return "ğŸ“"

    def _get_item_type_key(self, item):
        if item.item_type == 'text': return 'text'
        if item.item_type == 'url': return 'url'
        if item.item_type == 'file' and item.file_path:
            if os.path.exists(item.file_path):
                if os.path.isdir(item.file_path): return 'folder'
                _, ext = os.path.splitext(item.file_path)
                return ext.lstrip('.').upper() if ext else 'FILE'
            return 'FILE'
        if item.item_type == 'image':
            path = item.image_path or item.file_path
            if path:
                _, ext = os.path.splitext(path)
                return ext.lstrip('.').upper() if ext else 'IMAGE'
            return 'IMAGE'
        return 'text'

    def _calculate_stats_from_items(self, items):
        from data.database import Tag
        stats = {'tags': {}, 'stars': {}, 'colors': {}, 'types': {}, 'date_create': {}, 'date_modify': {}}
        session = self.db.get_session()
        try:
            all_tags_in_db = {tag.name for tag in session.query(Tag).all()}
            for item in items:
                stats['stars'][item.star_level] = stats['stars'].get(item.star_level, 0) + 1
                if item.custom_color:
                    stats['colors'][item.custom_color] = stats['colors'].get(item.custom_color, 0) + 1
                for tag in item.tags:
                    stats['tags'][tag.name] = stats['tags'].get(tag.name, 0) + 1
                stats['types'][self._get_item_type_key(item)] = stats['types'].get(self._get_item_type_key(item), 0) + 1
        finally:
            session.close()
        
        final_tags = {tag_name: 0 for tag_name in all_tags_in_db}
        final_tags.update(stats['tags'])
        stats['tags'] = list(final_tags.items())
        
        def get_date_label(dt):
            today = datetime.now().date()
            if dt.date() == today: return "ä»Šæ—¥"
            if dt.date() == today - timedelta(days=1): return "æ˜¨æ—¥"
            if dt.date() >= today - timedelta(days=7): return "å‘¨å†…"
            if dt.date() >= today - timedelta(days=14): return "ä¸¤å‘¨"
            if dt.month == today.month and dt.year == today.year: return "æœ¬æœˆ"
            first_day_curr = today.replace(day=1)
            last_day_last = first_day_curr - timedelta(days=1)
            first_day_last = last_day_last.replace(day=1)
            if first_day_last <= dt.date() <= last_day_last: return "ä¸Šæœˆ"
            return None

        for item in items:
            label = get_date_label(item.created_at)
            if label:
                stats['date_create'][label] = stats['date_create'].get(label, 0) + 1
            if item.modified_at:
                label = get_date_label(item.modified_at)
                if label:
                    stats['date_modify'][label] = stats['date_modify'].get(label, 0) + 1
        return stats

    def show_header_menu(self, pos):
        col = self.table.horizontalHeader().logicalIndexAt(pos)
        menu = QMenu()
        menu.addAction("â† å·¦å¯¹é½").triggered.connect(lambda: self.set_col_align(col, Qt.AlignLeft | Qt.AlignVCenter))
        menu.addAction("â†” å±…ä¸­").triggered.connect(lambda: self.set_col_align(col, Qt.AlignCenter))
        menu.addAction("â†’ å³å¯¹é½").triggered.connect(lambda: self.set_col_align(col, Qt.AlignRight | Qt.AlignVCenter))
        menu.exec_(self.table.horizontalHeader().mapToGlobal(pos))
        
    def set_col_align(self, col, align):
        self.col_alignments[col] = int(align)
        for row in range(self.table.rowCount()):
            table_item = self.table.item(row, col)
            if table_item:
                table_item.setTextAlignment(align)
        self.schedule_save_state()

    def on_display_count_changed(self, count):
        self.page_size = count
        self.load_data(reset_page=True)

    def toggle_pin(self, checked):
        if platform.system() == "Windows":
            try:
                log.info(f"ğŸ“Œ åˆ‡æ¢çª—å£ç½®é¡¶çŠ¶æ€: {checked}")
                self.is_pinned = checked
                hwnd = int(self.winId())
                flag = HWND_TOPMOST if checked else HWND_NOTOPMOST
                SetWindowPos(hwnd, flag, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE)
                self.schedule_save_state()
            except Exception as e:
                log.error(f"âŒ ç½®é¡¶è®¾ç½®å¤±è´¥: {e}", exc_info=True)

    def auto_clean(self):
        if QMessageBox.question(self, "ç¡®è®¤", "åˆ é™¤21å¤©å‰æœªé”å®šçš„æ—§æ•°æ®?") == QMessageBox.Yes:
             count = self.db.auto_delete_old_data(days=21)
             QMessageBox.information(self, "å®Œæˆ", f"æ¸…ç†äº† {count} æ¡æ—§æ•°æ®")
             self.load_data()

    def toggle_edit_mode(self, checked):
        self.edit_mode = checked
        self.table.setEditTriggers(QAbstractItemView.DoubleClicked if checked else QAbstractItemView.NoEditTriggers)
        self.schedule_save_state()

    def on_table_double_click(self, item):
        if self.edit_mode:
            return
        self.copy_and_paste_item()

    def on_item_changed(self, item):
        if not self.edit_mode:
            return
        
        row, col = item.row(), item.column()
        item_id = int(self.table.item(row, 8).text())
        if col == 1:
            self.db.update_item(item_id, content=item.text().strip())
        elif col == 2:
            self.db.update_item(item_id, note=item.text().strip())
        
        self.load_data()

    def copy_and_paste_item(self):
        if self.current_item_id:
            session = self.db.get_session()
            from data.database import ClipboardItem
            obj = session.query(ClipboardItem).get(self.current_item_id)
            if obj:
                self._processing_clipboard = True
                try:
                    if obj.item_type == 'image' and obj.data_blob:
                        image = QImage()
                        image.loadFromData(obj.data_blob)
                        self.clipboard.setImage(image)
                    else:
                        self.clipboard.setText(obj.content)
                finally:
                    self._processing_clipboard = False
                
                if self.last_external_hwnd and platform.system() == "Windows":
                    self.showMinimized()
                    try:
                        ctypes.windll.user32.SetForegroundWindow(self.last_external_hwnd)
                        if ctypes.windll.user32.IsIconic(self.last_external_hwnd):
                            ctypes.windll.user32.ShowWindow(self.last_external_hwnd, 9)
                    except:
                        pass
                    QTimer.singleShot(100, self._send_ctrl_v)
                else:
                    self.lbl_status.setText("âœ… å·²å¤åˆ¶")
            session.close()

    def _send_ctrl_v(self):
        if platform.system() == "Windows":
            ctypes.windll.user32.keybd_event(0x11, 0, 0, 0) # CTRL
            ctypes.windll.user32.keybd_event(0x56, 0, 0, 0) # V
            ctypes.windll.user32.keybd_event(0x56, 2, 0) # V up
            ctypes.windll.user32.keybd_event(0x11, 2, 0) # CTRL up

    def update_detail_panel(self):
        rows = self.table.selectionModel().selectedRows()
        has_selection = bool(rows)
        self.tag_panel.setEnabled(has_selection)

        if not rows:
            self.detail_panel.clear()
            return
        
        item = self.table.item(rows[0].row(), 8)
        if not item or not item.text():
            log.warning("âš ï¸ é€‰ä¸­è¡Œçš„IDåˆ—ä¸ºç©º")
            return
        
        item_id = int(item.text())
        log.debug(f"ğŸ“‹ æ›´æ–°è¯¦æƒ…é¢æ¿ï¼Œé¡¹ç›®ID: {item_id}")
        session = self.db.get_session()
        from data.database import ClipboardItem
        item_obj = session.query(ClipboardItem).options(joinedload(ClipboardItem.tags), joinedload(ClipboardItem.partition)).get(item_id)
        
        if item_obj:
            tags = [t.name for t in item_obj.tags]
            path_parts = []
            curr = item_obj.partition
            while curr:
                path_parts.append(curr.name)
                curr = session.query(Partition).get(curr.parent_id)
            path_parts.reverse()
            group_name = path_parts[0] if path_parts else None
            partition_name = " -> ".join(path_parts) if path_parts else None

            self.detail_panel.load_item(item_obj.content, item_obj.note, tags, group_name=group_name, partition_name=partition_name, item_type=item_obj.item_type, image_path=item_obj.image_path, file_path=item_obj.file_path, image_blob=item_obj.data_blob)
            self.current_item_id = item_id
        session.close()

    def reorder_items(self, new_ids):
        self.db.update_sort_order(new_ids)

    def save_note(self, text):
        if self.current_item_id:
            self.db.update_item(self.current_item_id, note=text)
            self.load_data()
    
    def on_tags_added(self, tags):
        if self.current_item_id:
            self.db.add_tags_to_items([self.current_item_id], tags)
            self.update_detail_panel()
            self.load_data()
            self.partition_panel.refresh_partitions()

    def on_tag_panel_commit_tags(self, tags):
        rows = self.table.selectionModel().selectedRows()
        if not rows or not tags:
            return
        
        item_ids = [int(self.table.item(r.row(), 8).text()) for r in rows if self.table.item(r.row(), 8) and self.table.item(r.row(), 8).text()]
        if item_ids:
            self.db.add_tags_to_items(item_ids, tags)
            self.load_data()
            self.update_detail_panel()
            self.partition_panel.refresh_partitions()
            log.info(f"âœ… å·²ä¸º {len(item_ids)} ä¸ªé¡¹ç›®æ‰¹é‡æ·»åŠ æ ‡ç­¾: {tags}")

    def remove_tag(self, tag):
        if self.current_item_id: 
            self.db.remove_tag_from_item(self.current_item_id, tag)
            self.update_detail_panel()
            self.load_data()
            self.partition_panel.refresh_partitions()

    def toggle_theme(self):
        self.apply_theme("light" if self.current_theme == "dark" else "dark")

    def apply_theme(self, name):
        self.current_theme = name
        app = QApplication.instance()
        if name == "dark":
            app.setStyleSheet(themes.dark.STYLESHEET)
        else:
            app.setStyleSheet(themes.light.STYLESHEET)
    
    def toolbar_set_color(self):
        rows = self.table.selectionModel().selectedRows()
        if not rows:
            return
        
        item_ids = [int(self.table.item(r.row(), 8).text()) for r in rows if self.table.item(r.row(), 8) and self.table.item(r.row(), 8).text()]
        if item_ids:
            self.set_custom_color(item_ids)

    def set_custom_color(self, item_ids):
        dlg = ColorSelectorDialog(self)
        if dlg.exec_():
            self.batch_set_color(item_ids, dlg.selected_color or "")

    def batch_set_color(self, ids, clr):
        session = self.db.get_session()
        try:
            from data.database import ClipboardItem
            count = session.query(ClipboardItem).filter(ClipboardItem.id.in_(ids)).update({'custom_color': clr}, synchronize_session=False)
            session.commit()
            log.info(f"âœ… æˆåŠŸè®¾ç½® {count} ä¸ªé¡¹ç›®çš„é¢œè‰²")
            self.load_data()
        except Exception as e:
            log.error(f"âŒ è®¾ç½®é¢œè‰²å¤±è´¥: {e}", exc_info=True)
            session.rollback()
        finally:
            session.close()
        self.schedule_save_state()

    def select_item_in_table(self, item_id_to_select):
        log.debug(f"æ»šåŠ¨åˆ°é¡¹ç›®: {item_id_to_select}")
        for row in range(self.table.rowCount()):
            item = self.table.item(row, 8)
            if item and item.text() == str(item_id_to_select):
                self.table.blockSignals(True)
                self.table.selectRow(row)
                self.table.scrollToItem(item, QAbstractItemView.ScrollHint.PositionAtCenter)
                self.table.blockSignals(False)
                log.info(f"âœ… å·²åœ¨è¡¨æ ¼ä¸­é«˜äº®æ˜¾ç¤ºé¡¹ç›® {item_id_to_select}")
                return
        log.warning(f"âš ï¸ æœªèƒ½åœ¨å½“å‰æ˜¾ç¤ºçš„è¡¨æ ¼ä¸­æ‰¾åˆ°é¡¹ç›®ID: {item_id_to_select}")
    
    def on_tag_panel_add_tag(self, tag_input=None):
        if not tag_input:
            dlg = TagDialog(self.db, self)
            if dlg.exec_():
                self.tag_panel.refresh_tags(self.db)
            return

        tags_to_add = tag_input if isinstance(tag_input, list) else [tag_input]
        session = self.db.get_session()
        from data.database import Tag
        try:
            has_new = False
            for tag_name in [t.strip() for t in tags_to_add if t.strip()]:
                if not session.query(Tag).filter_by(name=tag_name).first():
                    session.add(Tag(name=tag_name))
                    has_new = True
            if has_new:
                session.commit()
                self.tag_panel.refresh_tags(self.db)
        except Exception as e:
            log.error(f"æ·»åŠ æ ‡ç­¾å¤±è´¥: {e}")
        finally:
            session.close()
    
    def on_tag_selected(self, tag_name):
        log.info(f"ğŸ·ï¸ æ ‡ç­¾è¢«é€‰ä¸­: {tag_name}")

    def handle_item_selection_in_partition(self, item_id):
        log.debug(f"æ¥æ”¶åˆ°ä¾§è¾¹æ é«˜äº®è¯·æ±‚ï¼Œé¡¹ç›®ID: {item_id}ï¼Œå°†åœ¨åŠ è½½åå¤„ç†ã€‚")
        self.item_id_to_select_after_load = item_id
```

## æ–‡ä»¶: ui\panels.py

```python
ï»¿# -*- coding: utf-8 -*-
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QTextEdit, QLabel, QLineEdit, QPushButton, QHBoxLayout, QScrollArea
from PyQt5.QtCore import Qt, pyqtSignal

class DetailPanel(QWidget):
    update_note_signal = pyqtSignal(str)
    add_tag_signal = pyqtSignal()
    remove_tag_signal = pyqtSignal(str)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(10, 10, 10, 10)
        
        self.preview = QTextEdit()
        self.preview.setReadOnly(True)
        self.preview.setPlaceholderText("é€‰æ‹©æ¡ç›®ä»¥é¢„è§ˆ...")
        self.layout.addWidget(self.preview, 1)
        
        self.layout.addWidget(QLabel("ğŸ“ å¤‡æ³¨:"))
        self.note_edit = QLineEdit()
        self.note_edit.returnPressed.connect(lambda: self.update_note_signal.emit(self.note_edit.text()))
        self.layout.addWidget(self.note_edit)
        
        self.layout.addSpacing(15)
        self.layout.addWidget(QLabel("ğŸ·ï¸ å½“å‰æ ‡ç­¾:"))
        self.tag_container = QWidget()
        self.tag_layout = QHBoxLayout(self.tag_container)
        self.tag_layout.setAlignment(Qt.AlignLeft)
        self.tag_layout.setContentsMargins(0, 0, 0, 0)
        
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setWidget(self.tag_container)
        scroll.setFixedHeight(60)
        scroll.setStyleSheet("border: none; background: transparent;")
        self.layout.addWidget(scroll)
        
        btn_add = QPushButton("+ æ·»åŠ æ ‡ç­¾")
        btn_add.clicked.connect(self.add_tag_signal.emit)
        self.layout.addWidget(btn_add)
        
    def load_item(self, content, note, tags):
        self.preview.setText(content)
        self.note_edit.setText(note)
        for i in reversed(range(self.tag_layout.count())): 
            self.tag_layout.itemAt(i).widget().deleteLater()
            
        for tag_name in tags:
            btn = QPushButton(f"{tag_name} âœ•")
            btn.setStyleSheet("QPushButton { background: #313244; border-radius: 10px; padding: 2px 8px; color: #89b4fa; border: 1px solid #89b4fa; } QPushButton:hover { background: #45475a; color: #f38ba8; border-color: #f38ba8; }")
            btn.setCursor(Qt.PointingHandCursor)
            btn.clicked.connect(lambda _, t=tag_name: self.remove_tag_signal.emit(t))
            self.tag_layout.addWidget(btn)
```

## æ–‡ä»¶: ui\panel_detail.py

```python
# -*- coding: utf-8 -*-
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QTextEdit, QLabel, 
                             QLineEdit, QPushButton, QScrollArea, QFrame, QSizePolicy, QGraphicsDropShadowEffect)
from PyQt5.QtCore import Qt, pyqtSignal, QSize
from PyQt5.QtGui import QPixmap, QIcon, QMouseEvent, QColor
import os
from .flow_layout import FlowLayout  # å¯¼å…¥æ–°çš„å¸ƒå±€ç®¡ç†å™¨
from .widgets.tag_widget import TagWidget


class DetailPanel(QWidget):
    update_note_signal = pyqtSignal(str)
    tags_added_signal = pyqtSignal(list) # æ–°çš„ä¿¡å·ï¼Œç”¨äºæäº¤æ ‡ç­¾åˆ—è¡¨
    remove_tag_signal = pyqtSignal(str)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAttribute(Qt.WA_StyledBackground, True)
            
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(10, 10, 10, 12) # ç¼©å‡å†…è¾¹è·ï¼ŒæŠŠç©ºé—´è¿˜ç»™æ–‡å­—
        self.layout.setSpacing(12) 
        
        # 0. æ‰€å±åˆ†åŒº/åˆ†ç»„ä¿¡æ¯
        partition_info_layout = QHBoxLayout()
        self.lbl_group = QLabel("åˆ†ç»„: --")
        self.lbl_group.setObjectName("PartitionInfoLabel")
        self.lbl_partition = QLabel("åˆ†åŒº: --")
        self.lbl_partition.setObjectName("PartitionInfoLabel")
        partition_info_layout.addWidget(self.lbl_group)
        partition_info_layout.addSpacing(20)
        partition_info_layout.addWidget(self.lbl_partition)
        partition_info_layout.addStretch()
        self.layout.addLayout(partition_info_layout)

        # 1. å†…å®¹é¢„è§ˆæ¨¡å—
        # æ–‡æœ¬é¢„è§ˆç»„ä»¶
        self.preview = QTextEdit()
        self.preview.setObjectName("PreviewBox")
        self.preview.setReadOnly(True)
        self.preview.setPlaceholderText("æš‚æ— å†…å®¹...")
        self.preview.textChanged.connect(self._update_preview_height) # æ–‡æœ¬å˜åŒ–æ—¶æ›´æ–°é«˜åº¦
        self.layout.addWidget(self.preview)
        
        # å›¾ç‰‡é¢„è§ˆç»„ä»¶å®¹å™¨ (ç”¨äºæ‰¿è½½é˜´å½±)
        self.image_container = QWidget()
        self.image_container_layout = QVBoxLayout(self.image_container)
        self.image_container_layout.setContentsMargins(10, 10, 10, 10) # é¢„ç•™é˜´å½±æ˜¾ç¤ºç©ºé—´
        self.image_container_layout.setAlignment(Qt.AlignCenter) # å…³é”®ï¼šç¡®ä¿å†…éƒ¨ç»„ä»¶å±…ä¸­
        
        self.image_label = QLabel()
        self.image_label.setObjectName("ImageBox")
        self.image_label.setAlignment(Qt.AlignCenter)
        
        # ä¸ºå›¾ç‰‡å¢åŠ ç‰©ç†é˜´å½±
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(15)
        shadow.setXOffset(0)
        shadow.setYOffset(4)
        shadow.setColor(QColor(0, 0, 0, 180))
        self.image_label.setGraphicsEffect(shadow)
        
        self.image_container_layout.addWidget(self.image_label)
        self.image_container.hide()
        self.layout.addWidget(self.image_container)

        # 2. å¤‡æ³¨æ¨¡å—
        note_container = QWidget()
        note_layout = QVBoxLayout(note_container)
        note_layout.setContentsMargins(0, 0, 0, 0)
        note_layout.setSpacing(4)
        
        lbl_note = QLabel("å¤‡æ³¨:")
        lbl_note.setObjectName("SectionTitle")
        note_layout.addWidget(lbl_note)
        
        self.note_edit = QLineEdit()
        self.note_edit.setObjectName("NoteInput")
        self.note_edit.setPlaceholderText("ç‚¹å‡»æ·»åŠ å¤‡æ³¨ä¿¡æ¯...")
        self.note_edit.setEnabled(False) # é»˜è®¤ç¦ç”¨
        self.note_edit.returnPressed.connect(lambda: self.update_note_signal.emit(self.note_edit.text()))
        note_layout.addWidget(self.note_edit)
        
        self.layout.addWidget(note_container)
        
        # 3. æ ‡ç­¾æ¨¡å—
        tag_container_widget = QWidget()
        tag_main_layout = QVBoxLayout(tag_container_widget)
        tag_main_layout.setContentsMargins(0, 0, 0, 0)
        tag_main_layout.setSpacing(8)
        
        # æ ‡ç­¾å¤´
        header_line = QHBoxLayout()
        lbl_tags = QLabel("æ ‡ç­¾:")
        lbl_tags.setObjectName("SectionTitle")
        header_line.addWidget(lbl_tags)
        header_line.addStretch()
        tag_main_layout.addLayout(header_line)
        
        # æ ‡ç­¾æµå¼åŒºåŸŸ (æ›¿æ¢ä¸º FlowLayout)
        self.tag_content = QWidget()
        self.tag_content.setObjectName("TagContainer")
        self.tag_layout = FlowLayout(self.tag_content, spacing=6) # ä½¿ç”¨æ–°çš„å¸ƒå±€
        self.tag_layout.setContentsMargins(0, 0, 0, 0)
        
        tag_main_layout.addWidget(self.tag_content)
        
        self.layout.addWidget(tag_container_widget)

        # æ–°å¢ï¼šæ ‡ç­¾è¾“å…¥æ¡†ï¼ˆç§»åŠ¨åˆ°ä¸»å¸ƒå±€çš„æœ«å°¾ï¼‰
        self.tag_input = QLineEdit()
        self.tag_input.setObjectName("NoteInput") # å¤ç”¨å¤‡æ³¨è¾“å…¥æ¡†çš„æ ·å¼
        self.tag_input.setPlaceholderText("è¾“å…¥æ ‡ç­¾ï¼Œç”¨é€—å·åˆ†éš”...")
        self.tag_input.returnPressed.connect(self._on_tags_submitted)
        self.tag_input.setEnabled(False) # é»˜è®¤ç¦ç”¨

        # æ·»åŠ ä¸€ä¸ªå¼¹ç°§ï¼Œå°†æ‰€æœ‰å†…å®¹æ¨åˆ°é¡¶éƒ¨
        self.layout.addStretch(1)
        self.layout.addWidget(self.tag_input)

    def load_item(self, content, note, tags, group_name=None, partition_name=None, item_type='text', image_path=None, file_path=None, image_blob=None):
        # è®¾ç½®åˆ†åŒºä¿¡æ¯
        self.lbl_group.setText(f"åˆ†ç»„: {group_name or '--'}")
        self.lbl_partition.setText(f"åˆ†åŒº: {partition_name or 'æœªåˆ†ç±»'}")

        # è®¾ç½®å¤‡æ³¨
        self.note_edit.setText(note)
        self.note_edit.setCursorPosition(0)
        
        pixmap = QPixmap()
        can_show_image = False

        if item_type == 'image':
            if image_blob:
                can_show_image = pixmap.loadFromData(image_blob)
            else: # å…¼å®¹æ—§æ•°æ®
                path_to_try = image_path or file_path
                if path_to_try and os.path.exists(path_to_try):
                    can_show_image = pixmap.load(path_to_try)

        if can_show_image:
            self.preview.hide()
            self.image_container.show()
            self.image_label.show()
            max_w = self.width() - 40
            scaled_pixmap = pixmap.scaled(max_w, max_w, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.image_label.setPixmap(scaled_pixmap)
            self.image_label.setFixedSize(scaled_pixmap.size())
        else:
            self.image_container.hide()
            self.image_label.hide()
            self.preview.show()
            self.preview.setText(content)

        # åŠ è½½æ•°æ®åï¼Œå¯ç”¨äº¤äº’ç»„ä»¶
        self.note_edit.setEnabled(True)
        self.tag_input.setEnabled(True)
        
        # åˆ·æ–°æ ‡ç­¾å’Œé«˜åº¦
        self._refresh_tags(tags)
        self._update_preview_height()

    def _update_preview_height(self):
        """æ™ºèƒ½è®¡ç®—å¹¶è®¾ç½®é¢„è§ˆæ¡†çš„é«˜åº¦"""
        # ä»…åœ¨æ–‡æœ¬é¢„è§ˆå¯è§æ—¶æ“ä½œ
        if self.preview.isVisible():
            # è·å–æ–‡æ¡£çš„å®é™…é«˜åº¦
            doc_height = self.preview.document().size().height()
            
            # è·å–è¾¹è· (approax.)
            margins = self.preview.contentsMargins()
            # é¢å¤–å¢åŠ 5åƒç´ çš„ç¼“å†²ç©ºé—´ï¼Œé¿å…å› ç»†å¾®è®¡ç®—è¯¯å·®å¯¼è‡´ä¸å¿…è¦çš„æ»šåŠ¨æ¡å‡ºç°
            content_height = doc_height + margins.top() + margins.bottom() + 5
            
            # æœ€å¤§é«˜åº¦ä¸èƒ½è¶…è¿‡å®½åº¦
            max_h = self.preview.width()
            
            # è®¾ç½®å›ºå®šé«˜åº¦
            final_height = min(content_height, max_h)
            self.preview.setFixedHeight(int(final_height))

    def _refresh_tags(self, tags):
        # æ¸…ç©ºæ—§æ ‡ç­¾
        while self.tag_layout.count():
            item = self.tag_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()
            
        if not tags:
            lbl_empty = QLabel("æ— æ ‡ç­¾")
            lbl_empty.setObjectName("EmptyTagLabel")
            self.tag_layout.addWidget(lbl_empty)
            return

        for tag_name in tags:
            tag_widget = TagWidget(tag_name)
            tag_widget.removed.connect(self.remove_tag_signal.emit)
            self.tag_layout.addWidget(tag_widget)

    def clear(self):
        self.lbl_group.setText("åˆ†ç»„: --")
        self.lbl_partition.setText("åˆ†åŒº: --")
        self.preview.clear()
        self.note_edit.clear()
        
        # æ¸…ç©ºæ•°æ®æ—¶ï¼Œç¦ç”¨äº¤äº’ç»„ä»¶
        self.note_edit.setEnabled(False)
        self.tag_input.setEnabled(False)
        
        self._refresh_tags([])
        self.image_container.hide()
        self.image_label.hide()
        self.preview.show()

    def resizeEvent(self, event):
        """é‡å†™ resize äº‹ä»¶ï¼Œä»¥ä¾¿åœ¨é¢æ¿å®½åº¦å˜åŒ–æ—¶æ›´æ–°é¢„è§ˆé«˜åº¦"""
        super().resizeEvent(event)
        self._update_preview_height()

    def _on_tags_submitted(self):
        """å¤„ç†æ ‡ç­¾è¾“å…¥æ¡†çš„å›è½¦äº‹ä»¶"""
        text = self.tag_input.text().strip()
        if text:
            # åŒæ—¶æ”¯æŒä¸­è‹±æ–‡é€—å·åˆ†å‰²
            tags = [tag.strip() for tag in text.replace('ï¼Œ', ',').split(',') if tag.strip()]
            if tags:
                self.tags_added_signal.emit(tags)
            self.tag_input.clear()
```

## æ–‡ä»¶: ui\panel_filter.py

```python
# -*- coding: utf-8 -*-
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QTreeWidget, QTreeWidgetItem, QPushButton
from PyQt5.QtCore import Qt, pyqtSignal, QTimer
from core.shared import get_color_icon
import logging

log = logging.getLogger("FilterPanel")

class FilterPanel(QWidget):
    filterChanged = pyqtSignal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # ç§»é™¤æ‰€æœ‰å†…è”æ ·å¼ï¼Œç”±å…¨å±€ä¸»é¢˜æ§åˆ¶
        
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0) # ä¿æŒ 0 è¾¹è·ä»¥æ”¯æŒé«˜äº®å…¨å®½
        self.layout.setSpacing(0)
        
        self.tree = QTreeWidget()
        self.tree.setHeaderHidden(True)
        self.tree.setIndentation(20) # å§‹ç»ˆä¿æŒ 20px ç¼©è¿›ä»¥ç¡®ä¿å±‚çº§æ¸…æ™°
        self.tree.setFocusPolicy(Qt.NoFocus)
        self.tree.setRootIsDecorated(True) # æ˜¾å¼æ¢å¤å±‚çº§ç®­å¤´æ˜¾ç¤º
        self.tree.setUniformRowHeights(True)
        self.tree.setAnimated(True)
        self.tree.setAllColumnsShowFocus(True) # æ ¸å¿ƒï¼šè®©é€‰ä¸­é«˜äº®æ¨ªå‘é“ºæ»¡
        
        self.tree.itemChanged.connect(self._on_item_changed)
        self.tree.itemClicked.connect(self._on_item_clicked)
        self.layout.addWidget(self.tree)
        
        # æ·»åŠ é‡ç½®æŒ‰é’®
        self.btn_reset = QPushButton("é‡ç½®å‹¾é€‰")
        self.btn_reset.clicked.connect(self.reset_filters)
        self.layout.addWidget(self.btn_reset)

        self._block_item_click = False
        self.roots = {}
        
        # å®šä¹‰ç»“æ„
        order = [
            ('stars', 'â­  è¯„çº§ç­›é€‰'),
            ('colors', 'ğŸ¨  é¢œè‰²æ ‡è®°'),
            ('types', 'ğŸ“‚  æ–‡ä»¶ç±»å‹'),
            ('date_create', 'ğŸ“…  åˆ›å»ºæ—¶é—´'),
            ('date_modify', 'ğŸ“  ä¿®æ”¹æ—¶é—´'),
            ('tags', 'ğŸ·ï¸  æ ‡ç­¾äº‘'),
        ]
        
        font_header = self.tree.font()
        font_header.setBold(True)
        font_header.setPointSize(10) # ç¨å¾®å°ä¸€ç‚¹çš„æ ‡é¢˜å­—
        
        for key, label in order:
            item = QTreeWidgetItem(self.tree)
            item.setText(0, label)
            item.setExpanded(True)
            item.setFlags(Qt.ItemIsEnabled) # æ ¹èŠ‚ç‚¹ä¸å¯é€‰ä¸­ï¼Œåªä½œä¸ºæ ‡é¢˜
            
            # è®¾ç½®æ ‡é¢˜æ ·å¼ (ç¨å¾®æš—ä¸€ç‚¹çš„é¢œè‰²)
            item.setFont(0, font_header)
            
            # å¢åŠ ä¸€ç‚¹é—´è· (é€šè¿‡æ·»åŠ ç©ºçš„å­èŠ‚ç‚¹å ä½æˆ–è€…CSS margin)
            # è¿™é‡Œä¾èµ–CSS margin-top å®ç°åˆ†ç»„æ„Ÿ
            
            self.roots[key] = item
            
        self._add_fixed_date_options('date_create')
        self._add_fixed_date_options('date_modify')

    def _add_fixed_date_options(self, key):
        root = self.roots[key]
        options = ["ä»Šæ—¥", "æ˜¨æ—¥", "å‘¨å†…", "ä¸¤å‘¨", "æœ¬æœˆ", "ä¸Šæœˆ"]
        for opt in options:
            child = QTreeWidgetItem(root)
            child.setText(0, opt)
            child.setData(0, Qt.UserRole, opt)
            child.setCheckState(0, Qt.Unchecked)

    def _on_item_changed(self, item, col):
        """å‹¾é€‰å˜åŒ–æ—¶ï¼Œå‘å°„ä¿¡å·é€šçŸ¥ä¸»çª—å£åº”ç”¨å‰ç«¯è¿‡æ»¤"""
        # === æ ¸å¿ƒä¿®æ”¹ï¼šåªå‘å°„ä¿¡å·ï¼Œä¸åšå…¶ä»–æ“ä½œ ===
        self.filterChanged.emit()
        
        # ä¿ç•™ç‚¹å‡»é”å®šé€»è¾‘ï¼ˆé˜²æ­¢æ„å¤–è§¦å‘ï¼‰
        self._block_item_click = True
        QTimer.singleShot(100, lambda: setattr(self, '_block_item_click', False))

    def _on_item_clicked(self, item, column):
        if self._block_item_click: return
        
        # å¦‚æœç‚¹å‡»çš„æ˜¯æ ¹èŠ‚ç‚¹ï¼ˆä¸»åˆ†ç±»ï¼‰ï¼Œåˆ™åˆ‡æ¢å…¶å±•å¼€/æŠ˜å çŠ¶æ€
        if item.parent() is None:
            item.setExpanded(not item.isExpanded())
        # å¦‚æœç‚¹å‡»çš„æ˜¯å­èŠ‚ç‚¹ï¼Œåˆ™åˆ‡æ¢å…¶å¤é€‰æ¡†çŠ¶æ€
        elif item.flags() & Qt.ItemIsUserCheckable:
            state = item.checkState(0)
            item.setCheckState(0, Qt.Unchecked if state == Qt.Checked else Qt.Checked)

    def update_stats(self, stats):
        self.tree.blockSignals(True)
        
        # 1. æ˜Ÿçº§
        star_data = []
        for i in range(5, 0, -1):
            star_data.append((i, "â˜…" * i, stats['stars'].get(i, 0)))
        if 0 in stats['stars']: star_data.append((0, "æ— æ˜Ÿçº§", stats['stars'][0]))
        self._refresh('stars', star_data)

        # 2. é¢œè‰²
        self._refresh('colors', [(c, c.upper(), count) for c, count in stats['colors'].items()], is_col=True)
        
        # 3. æ ‡ç­¾
        self._refresh('tags', stats.get('tags', []), is_tag=True)
        
        # 4. æ—¥æœŸ
        self._refresh_date('date_create', stats.get('date_create', {}))
        self._refresh_date('date_modify', stats.get('date_modify', {}))
        
        # 5. ç±»å‹ (ç®€å•å¤„ç†)
        type_labels = {'text': 'æ–‡æœ¬', 'url': 'é“¾æ¥', 'folder': 'æ–‡ä»¶å¤¹', 'image': 'å›¾ç‰‡', 'file': 'æ–‡ä»¶'}
        type_data = []
        for t, count in stats.get('types', {}).items():
            label = type_labels.get(t, t.upper())
            type_data.append((t, label, count))
        self._refresh('types', type_data)
        
        self.tree.blockSignals(False)

    def _refresh(self, key, data, is_tag=False, is_col=False):
        root = self.roots[key]
        checked = {root.child(i).data(0, Qt.UserRole) for i in range(root.childCount()) if root.child(i).checkState(0) == Qt.Checked}
        root.takeChildren()
        
        if not data:
            # ä¸æ˜¾ç¤º"ç©º"ï¼Œç›´æ¥ä¿æŒç©ºç™½æ›´æ¸…çˆ½
            return

        for item_data in data:
            if is_tag:
                if isinstance(item_data, tuple): v, c = item_data; l = v
                else: v = l = item_data; c = 0
            else:
                v, l, c = item_data
            
            # æ•°é‡ä¸º0ä¸”æœªé€‰ä¸­çš„ä¸æ˜¾ç¤º
            if c == 0 and v not in checked: continue
            
            child = QTreeWidgetItem(root)
            # æ ¼å¼åŒ–æ–‡æœ¬ï¼š å·¦ä¾§åç§° ...... å³ä¾§æ•°é‡
            # ç”±äºQTreeWidgetå•åˆ—ä¸æ”¯æŒå¯¹é½ï¼Œæˆ‘ä»¬ç›´æ¥å†™åœ¨ä¸€èµ·
            child.setText(0, f"{l}  ({c})") 
            child.setData(0, Qt.UserRole, v)
            child.setCheckState(0, Qt.Checked if v in checked else Qt.Unchecked)
            if is_col: child.setIcon(0, get_color_icon(v))

    def _refresh_date(self, key, stats):
        root = self.roots[key]
        for i in range(root.childCount()):
            item = root.child(i)
            label = item.data(0, Qt.UserRole)
            count = stats.get(label, 0)
            item.setText(0, f"{label}  ({count})")
            # æ•°é‡ä¸º0ç½®ç° (é€šè¿‡CSSä¸æ˜“æ§åˆ¶å•ä¸ªItemé¢œè‰²ï¼Œè¿™é‡Œç•¥è¿‡)

    def get_checked(self, key):
        root = self.roots.get(key)
        return [root.child(i).data(0, Qt.UserRole) for i in range(root.childCount()) if root.child(i).checkState(0) == Qt.Checked]

    def reset_filters(self):
        """æ¸…ç©ºæ‰€æœ‰ç­›é€‰å™¨çš„å‹¾é€‰çŠ¶æ€"""
        self.tree.blockSignals(True)
        for key, root_item in self.roots.items():
            for i in range(root_item.childCount()):
                child = root_item.child(i)
                child.setCheckState(0, Qt.Unchecked)
        self.tree.blockSignals(False)
        self.filterChanged.emit() # æ‰‹åŠ¨è§¦å‘ä¸€æ¬¡æ›´æ–°
```

## æ–‡ä»¶: ui\panel_partition.py

```python
# -*- coding: utf-8 -*-
import logging
import random
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QTreeWidget, QTreeWidgetItem, 
                             QMenu, QInputDialog, QMessageBox, QLineEdit, QColorDialog,
                             QAbstractItemView, QStyle, QTreeWidgetItemIterator)
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QFont, QIcon, QPixmap, QColor, QPainter

log = logging.getLogger(__name__)


class PartitionTreeWidget(QTreeWidget):
    """ä¸€ä¸ªæ”¯æŒå±‚çº§åˆ†åŒºæ‹–æ”¾çš„ QTreeWidget å­ç±»ã€‚"""
    partitionsUpdated = pyqtSignal()

    def __init__(self, db_manager, parent=None):
        super().__init__(parent)
        self.db = db_manager
        
        self.setHeaderHidden(True)
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDropIndicatorShown(True)
        self.setDragDropMode(QAbstractItemView.InternalMove)
        self.setIndentation(20) # æ¢å¤ç¼©è¿›
        self.setSelectionMode(QAbstractItemView.SingleSelection)
        self.setSortingEnabled(False)
        self.setFocusPolicy(Qt.NoFocus) # å½»åº•ç¦ç”¨ç„¦ç‚¹æ¡†æ˜¾ç¤º
        self.setRootIsDecorated(True) # æ¢å¤è£…é¥°çº¿
        self.setAllColumnsShowFocus(True) # å…³é”®ï¼šè®©é«˜äº®æ¨ªè·¨å…¨è¡Œ

    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Delete:
            if selected_item := self.currentItem():
                self.parent()._delete_item(selected_item)
        else:
            super().keyPressEvent(event)

    def dragEnterEvent(self, event):
        if event.mimeData().hasFormat("application/x-clipboard-item-ids"):
            event.acceptProposedAction()
        else:
            super().dragEnterEvent(event)

    def dragMoveEvent(self, event):
        target_item = self.itemAt(event.pos())
        if not target_item:
            event.ignore(); return
        
        target_data = target_item.data(0, Qt.UserRole)
        if not target_data:
            event.ignore(); return
        
        target_type = target_data.get('type')
        
        # å¤–éƒ¨æ‹–æ‹½ï¼šé¡¹ç›®å¯ä»¥è¢«æ‹–åˆ°ä»»ä½•åˆ†åŒºæˆ–å›æ”¶ç«™
        if event.mimeData().hasFormat("application/x-clipboard-item-ids"):
            if target_type in ['partition', 'trash']:
                event.acceptProposedAction()
            else:
                event.ignore()
        # å†…éƒ¨æ‹–æ‹½ï¼šåˆ†åŒºå¯ä»¥è¢«æ‹–åˆ°å…¶ä»–åˆ†åŒºï¼ˆæˆä¸ºå­åˆ†åŒºï¼‰æˆ–å›æ”¶ç«™
        else:
            dragged_item = self.currentItem()
            if not dragged_item:
                event.ignore(); return
            
            dragged_data = dragged_item.data(0, Qt.UserRole)
            if not dragged_data or dragged_data.get('type') != 'partition':
                event.ignore(); return
            
            # é˜»æ­¢å°†ä¸€ä¸ªåˆ†åŒºæ‹–æ”¾åˆ°å®ƒè‡ªå·±çš„å­å­™åˆ†åŒºä¸­
            if self._is_descendant(dragged_item, target_item):
                event.ignore(); return

            if target_type in ['partition', 'trash']:
                event.acceptProposedAction()
            else:
                super().dragMoveEvent(event)

    def dropEvent(self, event):
        target_item = self.itemAt(event.pos())
        if not target_item:
            event.ignore(); return
        target_data = target_item.data(0, Qt.UserRole)
        if not target_data:
            event.ignore(); return
        target_type = target_data.get('type')

        # --- å¤„ç†ä»å¤–éƒ¨è¡¨æ ¼æ‹–æ‹½è¿‡æ¥çš„é¡¹ç›® ---
        if event.mimeData().hasFormat("application/x-clipboard-item-ids"):
            encoded_data = event.mimeData().data("application/x-clipboard-item-ids")
            item_ids = [int(id_str) for id_str in encoded_data.data().decode().split(',') if id_str]
            if not item_ids:
                event.ignore(); return

            if target_type == 'trash':
                self.db.move_items_to_trash(item_ids)
            elif target_type == 'partition':
                partition_id = target_data.get('id')
                is_from_trash = event.mimeData().data("application/x-clipboard-source") == b"trash"
                if is_from_trash:
                    self.db.restore_and_move_items(item_ids, partition_id)
                else:
                    self.db.move_items_to_partition(item_ids, partition_id)
            else:
                event.ignore(); return

            self.partitionsUpdated.emit()
            event.acceptProposedAction()
        # --- å¤„ç†å†…éƒ¨æ‹–æ‹½åˆ†åŒº ---
        else:
            dragged_item = self.currentItem()
            if not dragged_item:
                event.ignore(); return

            if target_type == 'trash':
                self.parent()._delete_item(dragged_item)
            else:
                super().dropEvent(event) # è®©QTreeWidgetå¤„ç†UIç§»åŠ¨
                self._update_partitions_from_tree_state()

    def _update_partitions_from_tree_state(self):
        """éå†æ•´ä¸ªæ ‘ï¼Œå¹¶å°†æ–°çš„å±‚çº§ç»“æ„å’Œé¡ºåºæŒä¹…åŒ–åˆ°æ•°æ®åº“ä¸­"""
        def process_children(parent_item, parent_id_in_db):
            for i in range(parent_item.childCount()):
                item = parent_item.child(i)
                data = item.data(0, Qt.UserRole)
                if data and data.get('type') == 'partition':
                    partition_id = data['id']
                    self.db.update_partition(partition_id, parent_id=parent_id_in_db, sort_index=float(i))
                    process_children(item, partition_id)

        for i in range(self.topLevelItemCount()):
            item = self.topLevelItem(i)
            data = item.data(0, Qt.UserRole)
            # åªå¤„ç†ç”¨æˆ·åˆ›å»ºçš„åˆ†åŒºï¼Œè·³è¿‡é™æ€é¡¹
            if data and data.get('type') == 'partition':
                partition_id = data['id']
                self.db.update_partition(partition_id, parent_id=None, sort_index=float(i))
                process_children(item, partition_id)
        
        log.info("åˆ†åŒºç»“æ„å’Œé¡ºåºå·²é€šè¿‡æ‹–æ”¾æ›´æ–°ã€‚")
        self.partitionsUpdated.emit()
        
    def _is_descendant(self, potential_parent, potential_child):
        """æ£€æŸ¥ potential_child æ˜¯å¦æ˜¯ potential_parent çš„å­å­™"""
        parent = potential_child.parent()
        while parent:
            if parent == potential_parent:
                return True
            parent = parent.parent()
        return False

class PartitionPanel(QWidget):
    """åˆ†åŒºç®¡ç†é¢æ¿"""
    partitionSelectionChanged = pyqtSignal(object)
    partitionsUpdated = pyqtSignal()

    def __init__(self, db_manager, parent=None):
        super().__init__(parent)
        self.db = db_manager
        self._init_ui()
        self.refresh_partitions()

    def _init_ui(self):
        self.layout = QVBoxLayout(self) # Changed 'layout' to 'self.layout'
        self.layout.setContentsMargins(0, 0, 0, 0)  # å·¦å³è¾¹è·è®¾ä¸º 0ï¼Œè®©é«˜äº®æ¡é“ºæ»¡
        
        self.tree = PartitionTreeWidget(self.db, self)
        self.tree.setObjectName("PartitionTree")
        self.tree.setExpandsOnDoubleClick(False)
        self.tree.setItemsExpandable(False)
        self.tree.itemDoubleClicked.connect(self._on_item_double_clicked)
        self.tree.customContextMenuRequested.connect(self._show_context_menu)
        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tree.itemSelectionChanged.connect(self._on_selection_changed)
        self.tree.partitionsUpdated.connect(self.partitionsUpdated.emit)
        
        self.layout.addWidget(self.tree)
        # self.setLayout(self.layout) # QVBoxLayout(self) å·²ç»è‡ªåŠ¨è®¾ç½®äº† layout

    def _on_item_double_clicked(self, item, column):
        if item.data(0, Qt.UserRole).get('type') == 'partition':
            item.setExpanded(not item.isExpanded())

    def _create_color_icon(self, color_str):
        pixmap = QPixmap(16, 16)
        pixmap.fill(Qt.transparent)
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.setBrush(QColor(color_str or "#808080"))
        painter.setPen(Qt.NoPen)
        painter.drawRoundedRect(2, 2, 12, 12, 4, 4)
        painter.end()
        return QIcon(pixmap)
        
    def _add_partition_recursive(self, partitions, parent_item, partition_counts):
        """é€’å½’å‡½æ•°ï¼Œç”¨äºæ„å»ºåˆ†åŒºæ ‘UI"""
        for partition in partitions:
            count = partition_counts.get(partition.id, 0)
            item = QTreeWidgetItem(parent_item, [f"{partition.name} ({count})"])
            item.setData(0, Qt.UserRole, {'type': 'partition', 'id': partition.id, 'color': partition.color})
            item.setIcon(0, self._create_color_icon(partition.color))
            
            if partition.children:
                self._add_partition_recursive(partition.children, item, partition_counts)

    def refresh_partitions(self):
        """ä»æ•°æ®åº“åŠ è½½å¹¶é€’å½’æ˜¾ç¤ºåˆ†åŒº"""
        current_selection = self.get_current_selection()
        self.tree.clear()
        
        counts = self.db.get_partition_item_counts()
        partition_counts = counts.get('partitions', {})

        # -- æ·»åŠ é™æ€é¡¹ --
        static_items = [
            ("å…¨éƒ¨æ•°æ®", {'type': 'all', 'id': -1}, QStyle.SP_DirHomeIcon, counts.get('total', 0)),
            ("ä»Šæ—¥æ•°æ®", {'type': 'today', 'id': -5}, QStyle.SP_FileDialogDetailedView, counts.get('today_modified', 0)),
            ("æœªåˆ†ç±»", {'type': 'uncategorized', 'id': -2}, QStyle.SP_MessageBoxWarning, counts.get('uncategorized', 0)),
            ("æœªæ ‡ç­¾", {'type': 'untagged', 'id': -3}, QStyle.SP_DialogHelpButton, counts.get('untagged', 0)),
            ("å›æ”¶ç«™", {'type': 'trash', 'id': -4}, QStyle.SP_TrashIcon, counts.get('trash', 0)),
        ]
        
        for name, data, icon, count in static_items:
            item = QTreeWidgetItem(self.tree, [f"{name} ({count})"])
            item.setData(0, Qt.UserRole, data)
            item.setFont(0, QFont("Arial", 10, QFont.Bold))
            item.setIcon(0, self.style().standardIcon(icon))
            item.setFlags(item.flags() & ~Qt.ItemIsDragEnabled & ~Qt.ItemIsDropEnabled)

        # -- é€’å½’æ·»åŠ ç”¨æˆ·åˆ†åŒº --
        top_level_partitions = self.db.get_partitions_tree()
        self._add_partition_recursive(top_level_partitions, self.tree, partition_counts)

        self.tree.expandAll()
        self.select_item_by_data(current_selection or {'type': 'all', 'id': -1})

    def select_item_by_data(self, data_to_find):
        if not data_to_find: return
        it = QTreeWidgetItemIterator(self.tree)
        while it.value():
            item = it.value()
            item_data = item.data(0, Qt.UserRole)
            if item_data and item_data.get('id') == data_to_find.get('id') and item_data.get('type') == data_to_find.get('type'):
                self.tree.setCurrentItem(item)
                return
            it += 1

    def _on_selection_changed(self):
        if data := self.get_current_selection():
            self.partitionSelectionChanged.emit(None if data.get('type') == 'all' else data)

    def _show_context_menu(self, pos):
        menu = QMenu()
        item = self.tree.itemAt(pos)
        
        if item:
            item_data = item.data(0, Qt.UserRole)
            if item_data.get('type') == 'partition':
                menu.addAction("æ·»åŠ å­åˆ†åŒº", lambda: self._add_partition(item))
                menu.addAction("è®¾ç½®é¢„è®¾æ ‡ç­¾", lambda: self._set_partition_tags(item))
                menu.addAction("ä¿®æ”¹é¢œè‰²", lambda: self._change_item_color(item))
                menu.addSeparator()
                menu.addAction("é‡å‘½å", lambda: self._rename_item(item))
                menu.addAction("åˆ é™¤", lambda: self._delete_item(item))
            elif item_data.get('type') not in ['all', 'uncategorized', 'untagged', 'trash']:
                 menu.addAction("æ·»åŠ åˆ†åŒº", self._add_partition) # fallback for safety
        else:
            menu.addAction("æ·»åŠ åˆ†åŒº", self._add_partition)
            
        menu.exec_(self.tree.viewport().mapToGlobal(pos))

    def _add_partition(self, parent_item=None):
        name, ok = QInputDialog.getText(self, "æ·»åŠ åˆ†åŒº", "è¯·è¾“å…¥åˆ†åŒºåç§°:", QLineEdit.Normal, "")
        if ok and name:
            parent_id = parent_item.data(0, Qt.UserRole).get('id') if parent_item and parent_item.data(0, Qt.UserRole) else None
            if self.db.add_partition(name, parent_id=parent_id):
                self.partitionsUpdated.emit()

    def _change_item_color(self, item):
        item_data = item.data(0, Qt.UserRole)
        current_color = QColor(item_data.get('color', '#FFFFFF'))
        color = QColorDialog.getColor(current_color, self, "é€‰æ‹©é¢œè‰²")
        if color.isValid():
            self.db.update_partition(item_data['id'], color=color.name())
            self.partitionsUpdated.emit()

    def _rename_item(self, item):
        item_data = item.data(0, Qt.UserRole)
        old_name = item.text(0).split(' (')[0]
        new_name, ok = QInputDialog.getText(self, "é‡å‘½å", "è¯·è¾“å…¥æ–°åç§°:", QLineEdit.Normal, old_name)
        if ok and new_name and new_name != old_name:
            self.db.rename_partition(item_data['id'], new_name)
            self.partitionsUpdated.emit()

    def _delete_item(self, item):
        item_data = item.data(0, Qt.UserRole)
        if item_data.get('type') != 'partition':
            log.warning(f"å°è¯•åˆ é™¤ä¸€ä¸ªéåˆ†åŒºç±»å‹çš„é¡¹ç›®: {item_data.get('type')}")
            return
        
        item_name = item.text(0).split(' (')[0]
        reply = QMessageBox.question(self, "ç¡®è®¤åˆ é™¤", f"ç¡®å®šè¦åˆ é™¤åˆ†åŒº '{item_name}' å—ï¼Ÿ\næ­¤æ“ä½œä¼šå°†å…¶æœ¬èº«åŠå…¶æ‰€æœ‰å­åˆ†åŒºä¸‹çš„å…¨éƒ¨æ•°æ®ç§»è‡³å›æ”¶ç«™ã€‚",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        
        if reply == QMessageBox.Yes:
            if self.db.delete_partition(item_data['id']):
                self.partitionsUpdated.emit()
            else:
                QMessageBox.warning(self, "åˆ é™¤å¤±è´¥", f"æ— æ³•åˆ é™¤åˆ†åŒº '{item_name}'ã€‚")
    
    def _set_partition_tags(self, item):
        item_data = item.data(0, Qt.UserRole)
        current_tags_str = ", ".join(self.db.get_partition_tags(item_data['id']))
        new_tags_str, ok = QInputDialog.getText(self, "è®¾ç½®é¢„è®¾æ ‡ç­¾", "è¯·è¾“å…¥æ ‡ç­¾ï¼ˆç”¨é€—å·åˆ†éš”ï¼‰:", QLineEdit.Normal, current_tags_str)
        if ok:
            tag_names = [tag.strip() for tag in new_tags_str.split(',') if tag.strip()]
            self.db.set_partition_tags(item_data['id'], tag_names)
            self.partitionsUpdated.emit()
            
    def get_current_selection(self):
        return self.tree.currentItem().data(0, Qt.UserRole) if self.tree.currentItem() else None
```

## æ–‡ä»¶: ui\panel_table.py

```python
# -*- coding: utf-8 -*-
import os
from PyQt5.QtWidgets import QTableWidget, QAbstractItemView, QHeaderView, QTableWidgetItem
from PyQt5.QtCore import Qt, pyqtSignal, QSize
from core.shared import get_color_icon, format_size

class TablePanel(QTableWidget):
    reorder_signal = pyqtSignal(list)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.is_trash_view = False
        
        # åŸºç¡€è®¾ç½®
        self.setColumnCount(9)
        self.setHorizontalHeaderLabels(["çŠ¶æ€", "å†…å®¹", "å¤‡æ³¨", "æ˜Ÿçº§", "å¤§å°", "ç±»å‹", "åˆ›å»ºæ—¶é—´", "PATH", "ID"])
        self.hideColumn(7) # éšè— PATH
        self.hideColumn(8) # éšè— ID
        
        # === æ ¸å¿ƒä¿®å¤ï¼šè¡Œé«˜ä¸å›¾æ ‡ ===
        # 1. å¼ºåˆ¶è®¾å®šè¡Œé«˜ï¼Œä¸å†ä¾èµ–è‡ªåŠ¨è®¡ç®—ï¼Œè§£å†³æŒ¤å‹é—®é¢˜
        self.verticalHeader().setDefaultSectionSize(38) 
        # 2. é™åˆ¶å›¾æ ‡å°ºå¯¸ï¼Œé˜²æ­¢å›¾ç‰‡è¿‡å¤§æ’‘æ»¡è¡Œ
        self.setIconSize(QSize(22, 22)) 
        # 3. è®¾ç½®çŠ¶æ€åˆ—å®½
        self.setColumnWidth(0, 50) 
        
        # æ ·å¼ä¸äº¤äº’
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDragDropMode(QAbstractItemView.DragDrop)
        self.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.setShowGrid(False) # ä¸æ˜¾ç¤ºç½‘æ ¼çº¿
        self.setAlternatingRowColors(True) # æ–‘é©¬çº¹
        self.setFocusPolicy(Qt.StrongFocus)
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        
        # è¡¨å¤´äº¤äº’
        header = self.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.Interactive)
        header.setStretchLastSection(True)
        header.setContextMenuPolicy(Qt.CustomContextMenu)
        header.setSectionsMovable(True)
        
        # å‚ç›´è¡¨å¤´ï¼ˆè¡Œå·ï¼‰
        self.verticalHeader().setVisible(True)
        self.verticalHeader().setSectionResizeMode(QHeaderView.Fixed) # å›ºå®šè¡Œé«˜ï¼Œé˜²æ­¢è‡ªåŠ¨å¡Œç¼©
        self.verticalHeader().setDefaultAlignment(Qt.AlignCenter)

        # ç›‘å¬ Viewport (æ»šè½®äº‹ä»¶)
        self.viewport().installEventFilter(self)
        
        # åŠ è½½å­—ä½“è®¾ç½®
        self.load_font_settings()

    def load_font_settings(self):
        from PyQt5.QtCore import QSettings
        settings = QSettings("ClipboardPro", "Settings")
        size = settings.value("table_font_size", 10, type=int)
        font = self.font()
        font.setPointSize(size)
        self.setFont(font)
        # æ ¹æ®å­—ä½“è°ƒæ•´è¡Œé«˜ï¼Œæœ€å° 38px
        self.verticalHeader().setDefaultSectionSize(max(38, size + 20))

    def eventFilter(self, source, event):
        if source == self.viewport() and event.type() == event.Wheel:
            if event.modifiers() == Qt.ControlModifier:
                delta = event.angleDelta().y()
                self.handle_zoom(delta)
                return True
            # é˜²æ­¢è§¦æ‘¸æ¿æ°´å¹³æ¼‚ç§»
            if abs(event.angleDelta().x()) > abs(event.angleDelta().y()):
                return True
        return super().eventFilter(source, event)

    def handle_zoom(self, delta):
        font = self.font()
        size = font.pointSize()
        if delta > 0: size += 1
        else: size = max(8, size - 1)
        font.setPointSize(size)
        self.setFont(font)
        # ç¼©æ”¾æ—¶åŒæ­¥è°ƒæ•´è¡Œé«˜
        self.verticalHeader().setDefaultSectionSize(size + 20)
        
        from PyQt5.QtCore import QSettings
        QSettings("ClipboardPro", "Settings").setValue("table_font_size", size)

    def dropEvent(self, event):
        if event.source() != self: 
            super().dropEvent(event)
            return
        super().dropEvent(event)
        new_ids = []
        for r in range(self.rowCount()):
            item = self.item(r, 8)
            if item: new_ids.append(int(item.text()))
        self.reorder_signal.emit(new_ids)

    def mimeData(self, indexes):
        from PyQt5.QtCore import QMimeData
        mime_data = QMimeData()
        item_ids = []
        unique_rows = {index.row() for index in indexes}
        for row in unique_rows:
            id_item = self.item(row, 8)
            if id_item: item_ids.append(id_item.text())
        if item_ids:
            encoded_data = ",".join(item_ids).encode()
            mime_data.setData("application/x-clipboard-item-ids", encoded_data)
            if self.is_trash_view:
                mime_data.setData("application/x-clipboard-source", b"trash")
        return mime_data

    def populate_table(self, items, col_alignments):
        """å¡«å……è¡¨æ ¼æ•°æ®ï¼Œè¿™æ˜¯ MainWindow è°ƒç”¨çš„æ ¸å¿ƒæ–¹æ³•"""
        self.blockSignals(True)
        self.setRowCount(len(items))
        
        for row, item in enumerate(items):
            # ID (Hidden)
            self.setItem(row, 8, QTableWidgetItem(str(item.id)))
            
            # çŠ¶æ€ä¸å›¾æ ‡
            st_flags = ""
            if item.is_pinned: st_flags += "ğŸ“Œ"
            if item.is_favorite: st_flags += "â¤ï¸"
            if item.is_locked: st_flags += "ğŸ”’"
            
            type_icon = self._get_type_symbol(item)
            display_text = f"{type_icon} {st_flags}".strip()
            
            state_item = QTableWidgetItem(display_text)
            if item.custom_color:
                state_item.setIcon(get_color_icon(item.custom_color))
            # æ–‡æœ¬å±…ä¸­
            state_item.setTextAlignment(Qt.AlignCenter)
            self.setItem(row, 0, state_item)
            
            # å†…å®¹
            content_display = self._get_content_display(item)
            content_item = QTableWidgetItem(content_display)
            content_item.setToolTip(item.content[:500]) # é™åˆ¶Tooltipé•¿åº¦é˜²æ­¢å¡é¡¿
            self.setItem(row, 1, content_item)

            # å…¶ä»–
            self.setItem(row, 2, QTableWidgetItem(item.note))
            self.setItem(row, 3, QTableWidgetItem("â˜…" * item.star_level))
            self.setItem(row, 4, QTableWidgetItem(format_size(item.content)))
            self.setItem(row, 5, QTableWidgetItem(self._get_type_string(item)))
            self.setItem(row, 6, QTableWidgetItem(item.created_at.strftime("%m-%d %H:%M")))
            
            # åº”ç”¨å¯¹é½æ–¹å¼
            for col in range(7):
                # é»˜è®¤: å†…å®¹(1)å’Œå¤‡æ³¨(2)å·¦å¯¹é½ï¼Œå…¶ä»–å±…ä¸­
                default_align = Qt.AlignLeft | Qt.AlignVCenter if col in [1, 2] else Qt.AlignCenter
                align = col_alignments.get(col, default_align)
                
                it = self.item(row, col)
                if it: it.setTextAlignment(align)

        self.blockSignals(False)

    def _get_content_display(self, item):
        if item.item_type == 'file' and item.file_path:
            return os.path.basename(item.file_path)
        elif item.item_type == 'url' and item.url_domain:
            return f"[{item.url_domain}] {item.url_title or ''}"
        elif item.item_type == 'image':
            return "[å›¾ç‰‡] " + (os.path.basename(item.image_path) if item.image_path else "")
        else:
            return item.content.replace('\n', ' ').replace('\r', '').strip()[:150]

    def _get_type_symbol(self, item):
        if item.item_type == 'url': return "ğŸ”—"
        if item.item_type == 'image': return "ğŸ–¼ï¸"
        if item.item_type == 'file': return "ğŸ“‚" if os.path.isdir(item.file_path or "") else "ğŸ“„"
        return "ğŸ“"

    def _get_type_string(self, item):
        if item.item_type == 'file' and item.file_path:
            _, ext = os.path.splitext(item.file_path)
            return ext.upper()[1:] if ext else "FILE"
        return "TXT"
```

## æ–‡ä»¶: ui\panel_tags.py

```python
# -*- coding: utf-8 -*-
from PyQt5.QtWidgets import QWidget, QVBoxLayout
from PyQt5.QtCore import Qt, pyqtSignal, QEvent, QPoint, QTimer
from ui.popup_tag import TagPopup
from ui.widget_tag_input import TagInputWidget

class TagPanel(QWidget):
    """æ ‡ç­¾é¢æ¿ï¼ˆé›†æˆè¾“å…¥ç»„ä»¶å’Œå¼¹çª—ï¼‰"""
    # ä¿¡å·å®šä¹‰
    tag_selected = pyqtSignal(str)
    tags_committed = pyqtSignal(list)    # å›è½¦æäº¤
    add_tag_requested = pyqtSignal(str)  # å…¼å®¹æ—§ä»£ç 
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAttribute(Qt.WA_StyledBackground, True)
        self.setObjectName("TagPanel")
        
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(10, 22, 10, 12) # å·¦å³è¾¹è·è®¾ä¸º 10ï¼Œä¿æŒä¸å·¦ä¾§é¢æ¿ä¸€è‡´
        self.layout.setSpacing(10)
        
        # 1. è¾“å…¥ç»„ä»¶ï¼ˆä¸Šä¸‹ç»“æ„ï¼‰
        self.input_widget = TagInputWidget()
        self.input_widget.line_edit.installEventFilter(self)  # ç›‘å¬åº•å±‚è¾“å…¥æ¡†
        
        # è¿æ¥ä¿¡å·
        self.input_widget.text_changed.connect(self._on_text_changed)
        self.input_widget.tags_committed.connect(self._on_tags_committed)
        # å½“æš‚å­˜åŒºå˜åŒ–æ—¶ï¼ŒåŒæ­¥æ›´æ–°å¼¹çª—çš„å‹¾é€‰çŠ¶æ€
        self.input_widget.tags_changed.connect(self._on_chips_updated)
        
        self.layout.addWidget(self.input_widget)
        self.layout.addStretch()
        
        # 2. æ‚¬æµ®å¼¹çª—
        self.popup = TagPopup(self)
        # è®¾ä¸º Popup æ¨¡å¼ï¼šç‚¹å‡»å¤–éƒ¨è‡ªåŠ¨å…³é—­
        self.popup.setWindowFlags(Qt.Popup | Qt.FramelessWindowHint | Qt.NoDropShadowWindowHint)
        self.popup.setAttribute(Qt.WA_ShowWithoutActivating, True)
        self.popup.setFocusPolicy(Qt.NoFocus)
        self.popup.hide()
        
        # å¼¹çª—ä¿¡å·
        self.popup.tag_selected.connect(self._on_popup_tag_toggle)         # å†å²æ ‡ç­¾å‹¾é€‰
        self.popup.create_tag_requested.connect(self._on_create_new_tag)   # æ–°è¯ç‚¹å‡»
        
        self.cached_tags = []

    def eventFilter(self, obj, event):
        """æ ¸å¿ƒäº¤äº’é€»è¾‘"""
        if obj == self.input_widget.line_edit:
            # === ä¸¥æ ¼æ‰§è¡ŒåŒå‡»é€»è¾‘ ===
            # å•å‡»ä¸å†å“åº”ï¼Œåªæœ‰åŒå‡»æ‰å¼¹å‡ºå†å²
            if event.type() == QEvent.MouseButtonDblClick:
                if not self.popup.isVisible():
                    QTimer.singleShot(50, self._show_history_popup)
                    
        return super().eventFilter(obj, event)

    def _show_history_popup(self):
        """æ˜¾ç¤ºå†å²æ ‡ç­¾é¢æ¿"""
        # å¦‚æœæ­¤æ—¶è¾“å…¥æ¡†æœ‰æ–‡å­—ï¼Œæ˜¾ç¤ºè¿‡æ»¤ç»“æœï¼›æ²¡æ–‡å­—ï¼Œæ˜¾ç¤ºçº¯å†å²
        current_text = self.input_widget.current_text().strip()
        self.popup.load_history(self.cached_tags, self.input_widget.get_tags())
        
        if current_text:
            self.popup.filter_ui(current_text)  # æœ‰å­—æ˜¾ç¤ºç­›é€‰/æ–°è¯
        else:
            self.popup.filter_ui("")  # æ²¡å­—æ˜¾ç¤ºå†å²
            
        self._position_popup()
        self.popup.show()
        
        # ä¿æŒç„¦ç‚¹åœ¨è¾“å…¥æ¡†
        self.input_widget.set_focus()

    def _on_text_changed(self, text):
        """è¾“å…¥æ–‡å­—å˜åŒ– -> å†³ç­–å¼¹å‡ºå†…å®¹"""
        text = text.strip()
        
        if not text:
            # æ— æ–‡å­— -> éšè—å¼¹çª—ï¼ˆä¸å¹²æ‰°ï¼Œæƒ³çœ‹å†å²è¯·åŒå‡»ï¼‰
            if self.popup.isVisible():
                self.popup.hide()
            return

        # æœ‰æ–‡å­— -> ä»…åœ¨å¼¹çª—å·²æ˜¾ç¤ºæ—¶æ›´æ–°è¿‡æ»¤
        # ï¼ˆä¸ä¸»åŠ¨å¼¹å‡ºï¼Œé¿å…è¾“å…¥å¹²æ‰°ï¼‰
        if self.popup.isVisible():
            self.popup.filter_ui(text)
            self.input_widget.set_focus()

    def _position_popup(self):
        """å®šä½å¼¹çª—åˆ°è¾“å…¥ç»„ä»¶æ­£ä¸‹æ–¹ (è€ƒè™‘é˜´å½±è¾¹è·)"""
        if not self.isVisible(): return
        # è¡¥å¿ 10px çš„é˜´å½±å¤–è¾¹è·ï¼Œç¡®ä¿å†…å®¹å¯¹é½è¾“å…¥æ¡†
        pos = self.input_widget.mapToGlobal(QPoint(-10, self.input_widget.height() - 8))
        self.popup.resize(self.input_widget.width() + 20, 320) # å¢åŠ å®½åº¦å’Œé«˜åº¦ä»¥å®¹çº³é˜´å½±
        self.popup.move(pos)
        self.popup.raise_()
    def _on_popup_tag_toggle(self, tag_name, checked):
        """
        å‹¾é€‰å†å²æ ‡ç­¾ -> æ”¾å…¥æš‚å­˜åŒºï¼ˆä¸æäº¤ï¼‰
        """
        if checked:
            self.input_widget.add_chip(tag_name)
        else:
            # å–æ¶ˆå‹¾é€‰ -> ç§»é™¤æš‚å­˜
            for chip in self.input_widget.chips:
                if chip.text() == tag_name:
                    self.input_widget.remove_chip(chip)
                    break
        self.input_widget.set_focus()

    def _on_create_new_tag(self, tag_name):
        """ç‚¹å‡»æ–°è¯ -> æ”¾å…¥æš‚å­˜åŒºï¼ˆä¸æäº¤ï¼‰"""
        self.input_widget.add_chip(tag_name)
        self.input_widget.clear_text()
        self.input_widget.set_focus()
        self.popup.hide()

    def _on_chips_updated(self, tags):
        """æš‚å­˜åŒºå˜åŠ¨ -> åˆ·æ–°å¼¹çª—å†…å®¹å¹¶åŠ¨æ€é‡å®šä½"""
        if self.popup.isVisible():
            self.popup.load_history(self.cached_tags, tags)
            # å…³é”®ï¼šå½“æ ‡ç­¾å¢å‡å¯¼è‡´è¾“å…¥æ¡†é«˜åº¦å˜åŒ–æ—¶ï¼Œå¿…é¡»é‡æ–°è®¡ç®—å¼¹çª—ä½ç½®ï¼Œé˜²æ­¢é®æŒ¡
            QTimer.singleShot(10, self._position_popup) 

    def _on_tags_committed(self, tags):
        """
        å›è½¦ -> æœ€ç»ˆæäº¤åˆ°æ•°æ®åº“
        """
        if tags:
            self.tags_committed.emit(tags)
        self.popup.hide()

    def load_tags(self, tags):
        """åŠ è½½å†å²æ ‡ç­¾åˆ—è¡¨"""
        self.cached_tags = tags

    def refresh_tags(self, db_manager):
        """ä»æ•°æ®åº“åˆ·æ–°æ ‡ç­¾"""
        try:
            stats = db_manager.get_stats()
            self.load_tags(stats.get('tags', []))
        except:
            pass
```

## æ–‡ä»¶: ui\popup_tag.py

```python
# -*- coding: utf-8 -*-
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QLabel, 
                             QFrame, QScrollArea, QPushButton, QGraphicsDropShadowEffect)
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QColor
from .flow_layout import FlowLayout

class TagPopup(QWidget):
    """
    åŠ¨æ€æ ‡ç­¾é€‰æ‹©/åˆ›å»ºå¼¹çª—
    """
    tag_selected = pyqtSignal(str, bool)
    create_tag_requested = pyqtSignal(str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowFlags(Qt.Popup | Qt.FramelessWindowHint | Qt.NoDropShadowWindowHint)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(10, 10, 10, 10)
        self.main_layout.setSpacing(0)
        
        self.container = QFrame()
        self.container.setObjectName("TagPopupContainer")
        self.container.setAttribute(Qt.WA_StyledBackground, True)
        
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(15)
        shadow.setXOffset(0)
        shadow.setYOffset(2)
        shadow.setColor(QColor(0, 0, 0, 150))
        self.container.setGraphicsEffect(shadow)
        
        self.layout_container = QVBoxLayout(self.container)
        self.layout_container.setContentsMargins(8, 8, 8, 8)
        self.layout_container.setSpacing(6)
        
        self.creation_view = QFrame()
        self.creation_layout = QVBoxLayout(self.creation_view)
        self.creation_layout.setContentsMargins(0, 0, 0, 0)
        
        self.btn_create = QPushButton()
        self.btn_create.setCursor(Qt.PointingHandCursor)
        self.btn_create.setObjectName("TagCreateButton")
        self.btn_create.clicked.connect(self._on_create_clicked)
        self.creation_layout.addWidget(self.btn_create)
        self.layout_container.addWidget(self.creation_view)
        
        self.history_view = QWidget()
        self.history_layout = QVBoxLayout(self.history_view)
        self.history_layout.setContentsMargins(0, 0, 0, 0)
        self.history_layout.setSpacing(5)
        
        self.lbl_history = QLabel("æœ€è¿‘ä½¿ç”¨")
        self.lbl_history.setObjectName("TagPopupHeader")
        self.history_layout.addWidget(self.lbl_history)
        
        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.scroll.setFrameShape(QFrame.NoFrame)
        self.scroll.setStyleSheet("background: transparent;")

        self.tags_widget = QWidget()
        self.flow_layout = FlowLayout(self.tags_widget)
        self.flow_layout.setContentsMargins(2, 2, 2, 2)
        self.flow_layout.setSpacing(4)
        self.scroll.setWidget(self.tags_widget)

        self.history_layout.addWidget(self.scroll, 1)
        self.layout_container.addWidget(self.history_view, 1)
        
        self.main_layout.addWidget(self.container)
        
        self.lbl_tip = QLabel("ç§»åŠ¨: â†‘â†“  é€‰ä¸­: Enter  å…³é—­: Esc")
        self.lbl_tip.setAlignment(Qt.AlignRight)
        self.lbl_tip.setObjectName("TagPopupTip")
        self.layout_container.addWidget(self.lbl_tip)
        
        self.current_tags = []
        self.selected_tags = set()
        self.typing_text = ""

    def load_history(self, tags, active_tags=None):
        self.current_tags = tags
        if active_tags:
            self.selected_tags = set(active_tags)
        
        self._populate_tags(self.current_tags)
        self.lbl_history.setText(f"æœ€è¿‘ä½¿ç”¨ ({len(tags)})")
        
        self.creation_view.hide()
        self.history_view.show()

    def filter_ui(self, text):
        text = text.strip()
        self.typing_text = text
        
        filtered_tags = []
        is_exact_match = False
        
        if not text:
            filtered_tags = self.current_tags
        else:
            for name, count in self.current_tags:
                if text.lower() in name.lower():
                    filtered_tags.append((name, count))
                if text.lower() == name.lower():
                    is_exact_match = True
        
        self._populate_tags(filtered_tags)
        
        if not text:
            self.lbl_history.setText(f"æœ€è¿‘ä½¿ç”¨ ({len(filtered_tags)})")
        else:
            self.lbl_history.setText("æœç´¢ç»“æœ")

        if text and not is_exact_match:
            self.creation_view.show()
            self.btn_create.setText(f"+ æ–°å»ºæ ‡ç­¾ \"{text}\"")
        else:
            self.creation_view.hide()
            
        if filtered_tags:
            self.history_view.show()
        else:
            self.history_view.hide()

    def _populate_tags(self, tags):
        while self.flow_layout.count():
            item = self.flow_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        for name, count in tags:
            btn = self._create_tag_btn(name, count)
            self.flow_layout.addWidget(btn)
                
        self._refresh_check_state()

    def _create_tag_btn(self, name, count):
        btn = QPushButton()
        btn.setCheckable(True)
        btn.setCursor(Qt.PointingHandCursor)
        btn.setProperty("tag_name", name)
        btn.setObjectName("TagPopupButton")
        
        btn.setText(f"ğŸ•’ {name}")
        btn.setToolTip(f"å¼•ç”¨æ¬¡æ•°: {count}")
        
        btn.clicked.connect(lambda checked, n=name: self._on_tag_clicked(n, checked))
        return btn

    def _refresh_check_state(self):
        for i in range(self.flow_layout.count()):
            item = self.flow_layout.itemAt(i)
            if item and item.widget():
                btn = item.widget()
                name = btn.property("tag_name")
                is_sel = name in self.selected_tags
                btn.setChecked(is_sel)
                
                if is_sel:
                    btn.setText(f"âœ” {name}")
                    btn.setProperty("selected", True)
                else:
                    btn.setText(f"ğŸ•’ {name}")
                    btn.setProperty("selected", False)

    def _on_tag_clicked(self, name, checked):
        if checked:
            self.selected_tags.add(name)
        else:
            self.selected_tags.discard(name)
        
        self._refresh_check_state()
        self.tag_selected.emit(name, checked)

    def _on_create_clicked(self):
        if self.typing_text:
            self.create_tag_requested.emit(self.typing_text)
            self.hide()
```

## æ–‡ä»¶: ui\tag_widget.py

```python
# coding:utf-8
from PyQt5.QtCore import pyqtSignal, Qt
from PyQt5.QtWidgets import QWidget, QHBoxLayout, QLabel, QPushButton


class TagWidget(QWidget):
    removed = pyqtSignal(str)

    def __init__(self, text, parent=None):
        super().__init__(parent)
        self.text = text
        self.init_ui()

    def init_ui(self):
        layout = QHBoxLayout()
        layout.setContentsMargins(5, 2, 2, 2)
        layout.setSpacing(4)

        self.label = QLabel(self.text)
        self.label.setAttribute(Qt.WA_TranslucentBackground)

        self.close_button = QPushButton("Ã—")
        self.close_button.setFixedSize(16, 16)
        self.close_button.clicked.connect(self.on_remove)

        layout.addWidget(self.label)
        layout.addWidget(self.close_button)

        self.setLayout(layout)
        self.setAttribute(Qt.WA_StyledBackground, True)

    def on_remove(self):
        self.removed.emit(self.text)
```

## æ–‡ä»¶: ui\temp_color_methods.py

```python
def toolbar_set_color(self):
    """ä»æ ‡é¢˜æ é¢œè‰²æŒ‰é’®è®¾ç½®é€‰ä¸­é¡¹çš„é¢œè‰²"""
    rows = self.table.selectionModel().selectedRows()
    if not rows:
        QMessageBox.information(self, "æç¤º", "è¯·å…ˆé€‰æ‹©è¦è®¾ç½®é¢œè‰²çš„é¡¹ç›®")
        return
    
    item_ids = [int(self.table.item(r.row(), 9).text()) for r in rows]
    self.set_custom_color(item_ids)

def set_custom_color(self, item_ids):
    """æ‰“å¼€é¢œè‰²é€‰æ‹©å¯¹è¯æ¡†"""
    from PyQt5.QtWidgets import QColorDialog
    color = QColorDialog.getColor()
    if color.isValid():
        self.batch_set_color(item_ids, color.name())

def batch_set_color(self, ids, clr):
    """æ‰¹é‡è®¾ç½®é¢œè‰²"""
    session = self.db.get_session()
    try:
        from data.database import ClipboardItem
        for item_id in ids:
            if item := session.query(ClipboardItem).get(item_id):
                item.custom_color = clr
        session.commit()
        self.load_data()
    except Exception as e:
        log.error(f"è®¾ç½®é¢œè‰²å¤±è´¥: {e}")
        session.rollback()
    finally:
        session.close()
```

## æ–‡ä»¶: ui\tray_manager.py

```python
import os
from PyQt5.QtWidgets import QSystemTrayIcon, QMenu, QAction, QApplication, QStyle
from PyQt5.QtGui import QIcon
from PyQt5.QtCore import pyqtSignal

class TrayManager(QSystemTrayIcon):
    """ç³»ç»Ÿæ‰˜ç›˜ç®¡ç†å™¨"""
    request_show_quick_panel = pyqtSignal()
    request_quit = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        
        # Load the custom SVG icon
        logo_path = os.path.join("assets", "logo.svg")
        if os.path.exists(logo_path):
            app_icon = QIcon(logo_path)
        else:
            # Fallback to a standard icon if the SVG is not found
            app_icon = QApplication.style().standardIcon(QStyle.SP_ApplicationIcon)
            
        self.setIcon(app_icon)
        
        self.setToolTip("Clipboard Pro")
        
        # åˆ›å»ºèœå•
        menu = QMenu()
        
        show_action = QAction("æ˜¾ç¤º/éšè— å¿«é€Ÿé¢æ¿", self)
        show_action.triggered.connect(self.request_show_quick_panel.emit)
        menu.addAction(show_action)
        
        menu.addSeparator()
        
        quit_action = QAction("é€€å‡º", self)
        quit_action.triggered.connect(self.request_quit.emit)
        menu.addAction(quit_action)
        
        self.setContextMenu(menu)
        
        # è¿æ¥æ‰˜ç›˜å›¾æ ‡çš„æ¿€æ´»äº‹ä»¶ (ä¾‹å¦‚å•å‡»)
        self.activated.connect(self.on_activated)

    def on_activated(self, reason):
        """å¤„ç†æ‰˜ç›˜å›¾æ ‡çš„æ¿€æ´»äº‹ä»¶"""
        # å¦‚æœæ˜¯å•å‡»æˆ–åŒå‡»ï¼Œåˆ™è§¦å‘æ˜¾ç¤º/éšè—é¢æ¿çš„ä¿¡å·
        if reason in (self.Trigger, self.DoubleClick):
            self.request_show_quick_panel.emit()
```

## æ–‡ä»¶: ui\widget_tag_input.py

```python
# -*- coding: utf-8 -*-
from PyQt5.QtWidgets import (QWidget, QLayout, QLineEdit, QLabel, QPushButton, 
                             QFrame, QVBoxLayout, QHBoxLayout, QSizePolicy)
from PyQt5.QtCore import Qt, QRect, QPoint, QSize, pyqtSignal, QEvent
from PyQt5.QtGui import QPalette, QColor

class FlowLayout(QLayout):
    """æµå¼å¸ƒå±€"""
    def __init__(self, parent=None, margin=0, spacing=-1):
        super().__init__(parent)
        if parent is not None: 
            self.setContentsMargins(margin, margin, margin, margin)
        self.setSpacing(spacing)
        self.itemList = []
        
    def __del__(self):
        item = self.takeAt(0)
        while item: 
            item = self.takeAt(0)
            
    def addItem(self, item): 
        self.itemList.append(item)
        
    def count(self): 
        return len(self.itemList)
        
    def itemAt(self, index): 
        return self.itemList[index] if 0 <= index < len(self.itemList) else None
        
    def takeAt(self, index): 
        return self.itemList.pop(index) if 0 <= index < len(self.itemList) else None
        
    def expandingDirections(self): 
        return Qt.Orientations(Qt.Orientation(0))
        
    def hasHeightForWidth(self): 
        return True
        
    def heightForWidth(self, width): 
        return self._doLayout(QRect(0, 0, width, 0), True)
        
    def setGeometry(self, rect): 
        super().setGeometry(rect)
        self._doLayout(rect, False)
        
    def sizeHint(self): 
        return self.minimumSize()
        
    def minimumSize(self):
        size = QSize()
        for item in self.itemList: 
            size = size.expandedTo(item.minimumSize())
        m = self.contentsMargins()
        size += QSize(m.left() + m.right(), m.top() + m.bottom())
        return size
        
    def _doLayout(self, rect, testOnly):
        x, y = rect.x(), rect.y()
        lineHeight = 0
        spacing = self.spacing()
        
        for item in self.itemList:
            wid = item.widget()
            spaceX = spacing + wid.style().layoutSpacing(
                QSizePolicy.PushButton, QSizePolicy.PushButton, Qt.Horizontal)
            spaceY = spacing + wid.style().layoutSpacing(
                QSizePolicy.PushButton, QSizePolicy.PushButton, Qt.Vertical)
            nextX = x + item.sizeHint().width() + spaceX
            
            if nextX - spaceX > rect.right() and lineHeight > 0:
                x = rect.x()
                y = y + lineHeight + spaceY
                nextX = x + item.sizeHint().width() + spaceX
                lineHeight = 0
                
            if not testOnly: 
                item.setGeometry(QRect(QPoint(x, y), item.sizeHint()))
            x = nextX
            lineHeight = max(lineHeight, item.sizeHint().height())
            
        return y + lineHeight - rect.y()


class TagChip(QFrame):
    """æ ‡ç­¾èƒ¶å›Šç»„ä»¶"""
    remove_requested = pyqtSignal()
    
    def __init__(self, text, parent=None):
        super().__init__(parent)
        self.setAttribute(Qt.WA_StyledBackground, True)
        
        layout = QHBoxLayout(self)
        layout.setContentsMargins(6, 2, 4, 2)
        layout.setSpacing(4)
        
        self.lbl = QLabel(text)
        layout.addWidget(self.lbl)
        
        self.btn = QPushButton("Ã—")
        self.btn.setObjectName("TagCloseButton")
        self.btn.setFixedSize(14, 14) # ç¨å¾®å‡å°å°ºå¯¸ä»¥é€‚é… 24px é«˜åº¦
        self.btn.setCursor(Qt.PointingHandCursor)
        self.btn.clicked.connect(self.remove_requested.emit)
        layout.addWidget(self.btn)
        
        self.setFixedHeight(24)
        self.setMinimumWidth(40) # ä»…è®¾ç½®æœ€å°å®½åº¦ï¼Œå…è®¸å…¶æ°´å¹³ä¼¸ç¼©
        self.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Fixed) # å…³é”®ï¼šè®©å°ºå¯¸ç­–ç•¥éšå†…å®¹ä¼¸ç¼©
        self.setAutoFillBackground(True)
        
    def text(self): 
        return self.lbl.text()


class TagInputWidget(QFrame):
    """
    æ ‡ç­¾è¾“å…¥ç»„ä»¶
    ä¸Šæ–¹ï¼šTag Chip æ˜¾ç¤ºåŒºï¼ˆæš‚å­˜åŒºï¼‰
    ä¸‹æ–¹ï¼šè¾“å…¥æ¡†
    """
    tags_committed = pyqtSignal(list)
    tags_changed = pyqtSignal(list)
    text_changed = pyqtSignal(str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setObjectName("TagInputWidget") # è®¾ç½®ObjectName
        self.setAttribute(Qt.WA_StyledBackground, True)
        self.setCursor(Qt.IBeamCursor)
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Minimum)
        
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(8, 6, 8, 6)
        self.main_layout.setSpacing(6)
        
        self.chips_container = QWidget()
        self.chips_container.setObjectName("ChipsContainer") # è®¾ç½®ObjectName
        self.flow_layout = FlowLayout(self.chips_container, margin=0, spacing=4)
        self.main_layout.addWidget(self.chips_container)
        
        self.line_edit = QLineEdit()
        self.line_edit.setPlaceholderText("ä¸ºé€‰ä¸­é¡¹æ·»åŠ æ ‡ç­¾(å›è½¦)...")
        self.line_edit.setFrame(False)
        
        palette = self.line_edit.palette()
        palette.setColor(QPalette.PlaceholderText, QColor("#a6adc8")) # ä½¿ç”¨è°ƒè‰²æ¿ä¸­çš„æ¬¡è¦æ–‡æœ¬è‰²
        self.line_edit.setPalette(palette)
        
        self.line_edit.textChanged.connect(self._on_text_changed)
        self.line_edit.returnPressed.connect(self._on_return)
        self.line_edit.installEventFilter(self)
        
        self.main_layout.addWidget(self.line_edit)
        
        self.chips = []
        
        self._update_chips_visibility()

    def mousePressEvent(self, event):
        self.line_edit.setFocus()
        super().mousePressEvent(event)

    def eventFilter(self, obj, event):
        if obj == self.line_edit and event.type() == QEvent.KeyPress:
            if event.key() == Qt.Key_Backspace and not self.line_edit.text() and self.chips:
                self.remove_chip(self.chips[-1])
                return True
            elif event.text() in (',', 'ï¼Œ'):
                text = self.line_edit.text().strip()
                if text:
                    self.add_chip(text)
                    self.line_edit.clear()
                return True
        return super().eventFilter(obj, event)

    def _on_text_changed(self, text):
        if text.endswith(',') or text.endswith('ï¼Œ'):
            content = text[:-1].strip()
            if content:
                self.add_chip(content)
            self.line_edit.clear()
            return
        self.text_changed.emit(text)

    def _on_return(self):
        text = self.line_edit.text().strip()
        if text:
            self.add_chip(text)
            self.line_edit.clear()
        elif self.chips:
            self.tags_committed.emit([c.text() for c in self.chips])
            self.clear_chips()

    def add_chip(self, text):
        if any(c.text() == text for c in self.chips):
            return
        
        chip = TagChip(text, self.chips_container)
        chip.remove_requested.connect(lambda: self.remove_chip(chip))
        self.flow_layout.addWidget(chip)
        self.chips.append(chip)
        
        self._update_ui_state()

    def remove_chip(self, chip):
        if chip in self.chips:
            self.chips.remove(chip)
            self.flow_layout.removeWidget(chip)
            chip.deleteLater()
            self._update_ui_state()

    def clear_chips(self):
        while self.chips:
            self.remove_chip(self.chips[0])

    def _update_ui_state(self):
        """ç»Ÿä¸€æ›´æ–°UIçŠ¶æ€"""
        has_chips = bool(self.chips)
        self.chips_container.setVisible(has_chips)
        
        if has_chips:
            self.line_edit.setPlaceholderText("ç»§ç»­è¾“å…¥...")
        else:
            self.line_edit.setPlaceholderText("ä¸ºé€‰ä¸­é¡¹æ·»åŠ æ ‡ç­¾(å›è½¦)...")
        
        self.tags_changed.emit([c.text() for c in self.chips])
        self.chips_container.updateGeometry()
        self.updateGeometry()

    def _update_chips_visibility(self):
        self.chips_container.setVisible(bool(self.chips))

    def clear_text(self): 
        self.line_edit.clear()
        
    def get_tags(self): 
        return [c.text() for c in self.chips]
        
    def set_focus(self): 
        self.line_edit.setFocus()
        
    def current_text(self): 
        return self.line_edit.text()
```

## æ–‡ä»¶: ui\__init__.py

```python

```

## æ–‡ä»¶: ui\widgets\tag_widget.py

```python
# coding:utf-8
from PyQt5.QtCore import pyqtSignal, Qt
from PyQt5.QtWidgets import QWidget, QHBoxLayout, QLabel, QPushButton


class TagWidget(QWidget):
    removed = pyqtSignal(str)

    def __init__(self, text, parent=None):
        super().__init__(parent)
        self.text = text
        self.init_ui()

    def init_ui(self):
        layout = QHBoxLayout()
        layout.setContentsMargins(5, 2, 2, 2)
        layout.setSpacing(4)

        self.label = QLabel(self.text)
        self.label.setAttribute(Qt.WA_TranslucentBackground)

        self.close_button = QPushButton("Ã—")
        self.close_button.setObjectName("TagCloseButton") # å…³é”®ï¼šåº”ç”¨ç½®é›¶å†…è¾¹è·æ ·å¼
        self.close_button.setFixedSize(16, 16)
        self.close_button.clicked.connect(self.on_remove)

        layout.addWidget(self.label)
        layout.addWidget(self.close_button)

        self.setLayout(layout)
        self.setObjectName("TagChip") # è®¾ç½® objectName ä»¥åº”ç”¨æ ·å¼
        self.setAttribute(Qt.WA_StyledBackground, True)
        self.setAutoFillBackground(True) # ç¡®ä¿èƒŒæ™¯è‰²èƒ½æ˜¾ç¤º

    def on_remove(self):
        self.removed.emit(self.text)
```

